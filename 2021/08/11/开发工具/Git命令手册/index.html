<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Git命令手册"><meta name="keywords" content="Git"><meta name="author" content="布多"><meta name="copyright" content="布多"><title>Git命令手册 | 布多的博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?f0d94d3f99211c3546490e469f6ecbd8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '6.3.0'
} </script><link rel="alternate" href="/atom.xml" title="布多的博客" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Git%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">2.</span> <span class="toc-text">Git的特点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">2.1.</span> <span class="toc-text">Git 常用命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Git-Config"><span class="toc-number">2.2.</span> <span class="toc-text">Git Config</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Git-Diff"><span class="toc-number">2.3.</span> <span class="toc-text">Git Diff</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Git-Log"><span class="toc-number">2.4.</span> <span class="toc-text">Git Log</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Git-Rebase"><span class="toc-number">2.5.</span> <span class="toc-text">Git Rebase</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Git-Remote"><span class="toc-number">2.6.</span> <span class="toc-text">Git Remote</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Git-Tag"><span class="toc-number">2.7.</span> <span class="toc-text">Git Tag</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Git-Branch"><span class="toc-number">2.8.</span> <span class="toc-text">Git Branch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Git-Merge"><span class="toc-number">2.9.</span> <span class="toc-text">Git Merge</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Git-%E9%82%AE%E7%AE%B1%E5%B7%A5%E4%BD%9C"><span class="toc-number">2.10.</span> <span class="toc-text">Git 邮箱工作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Git-Rerere"><span class="toc-number">2.11.</span> <span class="toc-text">Git Rerere</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Git-%E5%BD%92%E6%A1%A3"><span class="toc-number">2.12.</span> <span class="toc-text">Git 归档</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Git-Stash"><span class="toc-number">2.13.</span> <span class="toc-text">Git Stash</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Git-Add"><span class="toc-number">2.14.</span> <span class="toc-text">Git Add</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Git-Commit"><span class="toc-number">2.15.</span> <span class="toc-text">Git Commit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Git-%E6%90%9C%E7%B4%A2"><span class="toc-number">2.16.</span> <span class="toc-text">Git 搜索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Git-Subtree"><span class="toc-number">2.17.</span> <span class="toc-text">Git Subtree</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Git-Filter"><span class="toc-number">2.18.</span> <span class="toc-text">Git Filter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Git-Show"><span class="toc-number">2.19.</span> <span class="toc-text">Git Show</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Git-Reset"><span class="toc-number">2.20.</span> <span class="toc-text">Git Reset</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Git-Checkout"><span class="toc-number">2.21.</span> <span class="toc-text">Git Checkout</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Git-Revert"><span class="toc-number">2.22.</span> <span class="toc-text">Git Revert</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Git-Blame"><span class="toc-number">2.23.</span> <span class="toc-text">Git Blame</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Git-Bisect"><span class="toc-number">2.24.</span> <span class="toc-text">Git Bisect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Git-Replace"><span class="toc-number">2.25.</span> <span class="toc-text">Git Replace</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Git-%E5%BA%95%E5%B1%82%E5%91%BD%E4%BB%A4"><span class="toc-number">2.26.</span> <span class="toc-text">Git 底层命令</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.jpg"></div><div class="author-info__name text-center">布多</div><div class="author-info__description text-center">前进！前进！！不择手段地前进！！！</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/internetwei">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">17</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">11</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">4</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友链</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.coderqi.com/">齐小胖之家</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/images/backgroundImage.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">布多的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/about">关于</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">Git命令手册</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-11</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">11.1k</span><span class="post-meta__separator">|</span><span>阅读时长: 37 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>由 布多(budo) 发布于 2021-08-11</p>
</blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr>
<p>&nbsp;&nbsp;&nbsp;&nbsp;该手册(以下简称它)不是Git入门教程，如果您想入门Git推荐<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰的Git教程</a></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这只是一篇个人学习Git时顺带记录的命令手册以及对Git的一些理解心得，如有不正确的地方欢迎大家留言指正。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;它包含了Git几乎所有的高级命令和部分底层命令，每个命令都有详细的解释和示例告诉您如何使用，以及使用时需要注意的地方；内容按模块划分，比如和<code>add</code>相关的命令就都会集中在一个模块，大家可以选择自己感兴趣的模块自由阅读，由于某些命令的选项非常多但是并不常用，所以该手册可能没有记录，如果想查看某个命令的所有选项请查阅<a target="_blank" rel="noopener" href="https://git-scm.com/docs">Git命令参考</a>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;有些比较简单的命令这里可能没有记录，文章中的()表示的是全称，例如{u(upstream)}，表示upstream是u的全称，实际使用的时候用@{u}或者@{upstream}都可以。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Git本身是一个内容寻址文件系统，Git的核心部分是一个简单的键值对数据库，你可以向Git仓库中插入任意类型的内容，它会返回一个唯一的键，通过该键可以在任意时刻再次取回该内容。</p>
<blockquote>
<p>Tips： </p>
<ol>
<li><p>Git里一些同名的选项在相似的地方也可以使用。例如<code>--abort</code>选项，和<code>git merge --abort</code>搭配可以撤销合并操作，和<code>git rebase --abort</code>搭配可以撤销rebase操作。</p>
</li>
<li><p>Git里的大部分选项都是可以搭配一起使用的，例如<code>git log --author=&#39;internetwei&#39; --after=&quot;2020-01-01&quot; --before=&quot;2020-06-01&quot; --no-merges -- WXReader/Book/BookRack/BookReader</code><br>这行命令搭配了多达5个选项(指定作者，指定开始时间，指定结束时间，非合并提交，指定路径)， 它的意思是：打印<code>internetwei</code>作者在2020年1月1号到2020年6月1号之间对<code>WXReader/Book/BookRack/BookReader</code>这个文件夹(包括文件夹下所有文件)进行修改的所有提交记录但不包括合并提交。</p>
</li>
<li><p>Git里需要使用哈希值的地方不需要复制整个哈希字符串，通常只需要复制前6~8个字符就够了，如果项目比较大可以扩大到前8~10个，即使是像<code>Linux</code>这样的项目也只需要前10~12个字符即可保证唯一性。</p>
</li>
</ol>
</blockquote>
<h3 id="Git的特点"><a href="#Git的特点" class="headerlink" title="Git的特点"></a>Git的特点</h3><hr>
<ol>
<li><p>Git和SVN(其他版本控制工具)对待文件的区别？</p>
<blockquote>
<p>Git保存的不是文件的差异或变化，而是文件快照(快照可以简单的理解为这个文件的副本)，如果一个文件在提交的时候没有任何变化那么Git只会保留一个链接指向之前存储的内容；而SVN保存的是这个文件提交时的差异变化。
 </p>
</blockquote>
</li>
<li><p>Git如何保证完整性?</p>
<blockquote>
<p>Git所有的数据在存储前都会计算校验和，计算校验和的机制叫做SHA－1散列(hash、哈希)，这是一个由40个16进制字符(0<del>9,a</del>f)组成的字符串，基于文件的内容和目录结构计算出来的(由于相同的文件计算出来的哈希值是一样的，所以当你存储一个文件到Git仓库时，如果Git发现已经有了就只会创建一个链接指向之前存储的那个对象)，计算出来的哈希值就像这样：<code>a6b6695a3594cc79b3c3fa9ef5772df036ec8d8e</code>，校验和的前两个字符用于命名子目录，剩下的38个字符则用作文件名，Git数据库中保存的信息都是以哈希值来索引。</p>
</blockquote>
</li>
<li><p>Git暂存和提交时分别做了什么？</p>
<blockquote>
<p>当你进行暂存操作时，Git会对每个文件计算校验和，然后将这些校验和加入到暂存区等待提交。</p>
<p>当你进行提交操作时，Git会计算每个子目录的校验和以及对所有的文件创建快照并保存快照的索引，然后Git会在仓库中把这些校验和保存为一个树对象，然后Git会创建一个提交对象，它包含一个指向最上层树对象的指针和一个指向父对象的指针(如果是合并提交会有2个父对象，如图1)，还有作者的名称、邮箱地址、提交说明。</p>
</blockquote>
<p> <img src="50c7be27cd9a4bca9c4a75c2f7df54ea~tplv-k3u1fbpfcp-zoom-1.image"> 图1</p>
</li>
<li><p>Git暂存区的作用</p>
<blockquote>
<p>大部分的版本管理(SVN)都没有暂存区的概念，Git的add命令和其他类似工具的add命令也不太一样，其他工具的add命令是将文件加入到版本管理，而Git的add命令有3种作用：1. 将未跟踪的文件加入到版本管理；2. 将已修改的文件内容加入到暂存区；3. 将冲突文件标记为冲突已解决状态。由于Git暂存区的存在，你可以在完成提交前审查你的提交内容，还可以精确的控制每一行的提交内容。例如一个文件有20行是修改BUG，另外有100行是添加新功能，现在我只想提交这个文件的修改BUG的那20行代码，那么只需要把这20行代码加入到暂存区就行了。
 </p>
</blockquote>
</li>
<li><p>Merge的逻辑</p>
<blockquote>
<p>如果Git发现可以快进合并的话那么Git会直接把当前分支指向合并分支的最新提交(快进合并有一个缺点就是当你删除合并分支后会无法知道这个分支以前是从哪个分支合并过来的，如果想禁用快进合并可以使用<code>--no-ff</code>选项，这样Git会创建一个合并提交)，如果不可以快进合并的话Git会使用这两个分支的末端提交对象以及这两个分支的首个公共祖先提交，做一个简单的三方合并。</p>
</blockquote>
</li>
<li><p>GPG签名</p>
<blockquote>
<p>GPG可以签名你的提交或标签，它能够有效的提高Git仓库的安全性，因为它可以证明这个提交或标签是通过你信任的电脑提交的而不是某个冒用你名号的黑客，这相当于赋予了提交对象一种不可更改性，即使黑客通过某种办法拿到了Git仓库的读写权，他也没有办法添加或使用–force修改任何带有你GPG签名的提交或标签。</p>
<p>由于Git的作者名称和邮箱地址是可以随意填写的，如果有人将他的作者名称和邮箱地址改成和你的一样，然后通过某种方式将代码推送到了你的仓库中……这可能会导致你或其他人遭受损失，使用GPG签名可以尽量避免这种情况的发生。使用GPG签名过的提交在Github上显示如图2，你可以点击标签查看具体的签名信息。<br> <img src="5e21c63b735445c6b17e2d4790a291a1~tplv-k3u1fbpfcp-zoom-1.image"> 图2
 </p>
</blockquote>
</li>
<li><p>HEAD是什么？</p>
<blockquote>
<p>HEAD本质就是一个指针，也可以叫做符号指针，因为通常情况下它指向一个分支(符号)，通过它可以获取你仓库当前的状态，可以使用<code>git symbolic-ref HEAD</code>查看当前HEAD的状态。</p>
<p>当HEAD指向一个具体的提交对象而不是分支引用时，Git会提示您处于“游离状态”，“游离状态”表示你当前不处于任何分支，所以你不能进行提交，只能查看提交快照的内容，也可以进行修改运行，如果你想要进行提交则需要先创建一个分支，“游离状态”通常用于调试或回滚某次提交。
 </p>
</blockquote>
</li>
<li><p>HEAD^和HEAD~的区别？</p>
<blockquote>
<p>当后面不跟数字的时候^和~表示的意思相同，都表示第1个父提交对象；如果后面跟上数字就有差别了，^后面只能跟数字1或者数字2，^1表示当前对象的第1父提交，^2表示当前对象的第2父提交，只有合并提交对象才有第2父提交，第1父提交就是合并时接受合并的分支，第2父提交就是合并时被合并的那个分支；~后面理论上可以跟任意大于0的数字，~1表示当前提交对象的第1个父提交对象，~2表示当前提交对象的第2个父提交对象，以此类推，~2和~~表达同一个意思，不过当你想表示第100个父提交时，显然用~100比写100个~更现实，~和^可以组合使用，例如<code>git show HEAD~2^2</code>这行命令表示查看当前提交的第2个父提交的第2父提交内容。
 </p>
</blockquote>
</li>
<li><p>Git中危险的命令</p>
<blockquote>
<p>在Git中任何已提交的内容几乎都是可以恢复的(那些被覆盖的提交也可以恢复)，但是未提交的内容丢失后可能再也找不回了，任何可能会导致工作区内容丢失的命令都是危险的命令，在Git中危险的命令总共可以分为3类:</p>
<ol>
<li>所有带<code>-f</code>选项的命令，<code>-f</code>的全称是<code>--force</code>，它表示强制的意思，例如<code>git push -f</code>表示强行将本地仓库推送到远程仓库，<code>git switch -f dev</code>表示强行切换到dev分支，总之使用<code>-f</code>选项时请小心。</li>
<li><code>git reset</code>命令总共有3个选项，<code>--soft</code>、<code>--mixed</code>、<code>--hard</code>，其中只有<code>--hard</code>选项是危险的命令，其他两个都是安全的，当你使用<code>--hard</code>选项时Git会使用仓库中指定的快照内容覆盖工作区。</li>
<li><code>git checkout</code>命令的本质是操纵HEAD指针，它的后面可以是分支名表示切换分支，也可以是文件路径，如果后面是文件路径，那么它就是一个危险的命令，Git会使用仓库中指定的快照内容覆盖工作区的指定文件(建议使用switch命令来切换分支，防止误操作导致丢失文件内容)。</li>
</ol>
</blockquote>
</li>
<li><p>checkout和reset的区别</p>
<blockquote>
<p>很多人容易把<code>checkout</code>和<code>reset</code>弄混，因为它们都可以用来回滚历史提交，虽然最终效果是一样的，但是实现过程确不一样；简单的说checkout命令会直接修改HEAD指针的指向，而reset命令修改的是HEAD指针指向的对象。</p>
<p>假设master分支有一个提交对象(ab4adf)，你想回滚到这次提交，Git提供了2种方式：<code>git checkout ab4adf</code>和<code>git reset --hard ab4adf</code>都可以达到你的目的，但它们的实现机制略微不一样；<code>git checkout ab4adf</code>会把HEAD指针直接指向ab4adf这个提交对象，然后再使用ab4adf这个提交对象的快照内容覆盖工作区的内容来达到目的(如果你细心观察的话会发现Git会提示你当前进入了HEAD游离状态)，如图3所示；<code>git reset --hard ab4adf</code>的实现就稍微复杂一些，它会操纵HEAD指针指向的对象(这里是master分支)指向ab4adf这次提交，然后再使用ab4adf这次提交中的快照内容覆盖暂存区和工作区的内容，如图4所示。<br><img src="%E6%88%AA%E5%B1%8F2021-08-03%2015.49.02.png"> 图3<br><img src="%E6%88%AA%E5%B1%8F2021-08-03%2015.49.49.png"> 图4</p>
</blockquote>
</li>
<li><p>Git协议的区别</p>
<blockquote>
<p>HTTP协议</p>
<blockquote>
<p>HTTP协议有2个版本，一种是哑协议(只能通过GET方式读取仓库内容)，另一种是智能协议，哑协议由于自身问题已经基本退出舞台了；相比SSH协议，HTTP协议可以使用用户名、密码授权是一个优势，就算不知道用户名和密码也可以获取项目，这很适合开源项目的推广，另一个优势就是HTTPS协议被广泛使用，一般的企业防火墙都会允许这些端口的数据通过；唯一的缺点就是在一些服务器上，架设HTTPS协议的服务端稍微棘手一些</p>
<blockquote>
<p>在使用HTTPS协议时，可能要重复输入用户名和密码，这时可以执行<code>git config --global credential.helper cache</code>命令来将用户名和密码临时缓存到内存中，可以使用<code>--timeout &lt;seconds&gt;</code>选项控制保留时长，默认是900秒(15分钟)</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<p>SSH协议</p>
<blockquote>
<p>架设SSH协议相对简单，SSH守护进程很常见，多数管理员都会使用，多数操作系统都包含它及相关的管理工具，相对于HTTPS协议它不用输入用户名和密码也更加方便；它的缺点是不支持匿名访问Git仓库，即使只是读取数据，使用者也必须通过SSH访问你的主机，所以SSH不利于开源项目</p>
</blockquote>
</blockquote>
<blockquote>
<p>Git协议</p>
<blockquote>
<p>是所有协议里传输速度最快的，因为没有加密和授权的开销；它的缺点是由于没有加密和授权，要么谁都可以克隆这个仓库，要么谁也不能，它也是最难架设的协议，还要求防火墙开放9418端口，但是企业防火墙一般都不会开放这个非标准端口。Git协议一般和其他协议(例如HTTPS)搭配使用，使用Git协议进行拉取，使用HTTPS协议进行推送。</p>
</blockquote>
</blockquote>
<blockquote>
<p>Local协议</p>
<blockquote>
<p>一般不会用到，所有没有去了解这方面的知识，有兴趣的可以自行搜索</p>
</blockquote>
</blockquote>
</li>
</ol>
<h4 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h4><ul>
<li><p><code>git help &lt;verb&gt;</code> 获取指定Git命令的帮助文档</p>
<blockquote>
<p>示例：</p>
<p><code>git help add</code> 获取add命令的帮助文档</p>
<p><code>-a</code> 列出所有的Git命令</p>
<p><code>-c(--config)</code> 列出所有可用的配置变量</p>
<p><code>git add -h</code> 简易版的帮助文档</p>
<blockquote>
<p>等价命令：</p>
<p>git &lt;verb&gt; –help</p>
<p>man git-&lt;verb&gt;
  </p>
</blockquote>
</blockquote>
</li>
<li><p><code>git rm &lt;path&gt;</code> 删除指定文件</p>
<blockquote>
<p><code>--cached(--staged)</code> 从暂存区删除指定文件</p>
<blockquote>
<p>如果不小心把要忽略的文件添加到了Git仓库中，后续即使在忽略文件中声明也还是会在每次提交时提示你该文件未暂存；这时可以使用该命令从暂存区删除指定文件，该操作不会影响工作区。</p>
</blockquote>
<p><code>-n(--try-run)</code> 列出需要删除的文件
  </p>
</blockquote>
</li>
<li><p><code>git describe &lt;commit&gt;</code> 根据指定提交对象生成一个字符串构建号。它由提交对象最近的标签名、自该标签之后的提交数目和你所描述的提交的部分哈希值构成(可以为提交附上一个可读的名称)。</p>
</li>
<li><p><code>git reflog</code> 显示所有的引用日志</p>
<blockquote>
<p>reflog的本质只是记录HEAD指针发生变化的记录，它只存在于本地仓库，一般情况下Git只会保留最近几个月(默认是90天)的记录
  </p>
</blockquote>
</li>
<li><p><code>git reflog --date=local --all | grep &lt;分支名&gt;</code> 获取指定分支的HEAD变更记录</p>
<blockquote>
<p>可以用来查看某个分支是基于哪个分支创建的，由于reflog所以只能在创建分支的那台电脑上才能生效并且时间太长也会失效。
  </p>
</blockquote>
</li>
<li><p><code>git clean</code> 移除那些没有被Git跟踪的文件，该命令需要搭配以下选项执行</p>
<blockquote>
<p><code>-d</code> 递归删除子目录下的文件&#x2F;文件夹</p>
<p><code>-f</code>如果<code>clean.requireForce</code>没有被设置为false，则必须要使用<code>-f</code>告诉Git需要删除那些文件</p>
<p><code>-n(--dry-run)</code> 只显示那些会被移除的文件</p>
<p><code>-x</code> 默认情况下不会删除被忽略的文件，-x表示将移除那些被忽略的文件</p>
<p><code>-X</code> 仅删除被忽略的未跟踪文件
  </p>
</blockquote>
</li>
<li><p><code>git gc</code> 手动对Git仓库进行打包优化</p>
<blockquote>
<p><code>--aggressive</code> 加上此选项Git将会花费更多时间优化仓库</p>
</blockquote>
</li>
<li><p><code>git fsck</code> 验证数据库中对象的有效性</p>
<blockquote>
<p><code>--unreachable</code> 打印那些存在但无法从任何节点访问的对象
  </p>
</blockquote>
</li>
<li><p><code>git restore</code> 恢复工作区的文件</p>
<blockquote>
<p><code>--staged &lt;path&gt;</code> 将指定文件从暂存区移除</p>
<p><code>-s(--source) &lt;tree_id&gt; &lt;path&gt;</code> 使用指定树中的文件恢复工作区的指定文件</p>
</blockquote>
</li>
<li><p><code>git clone -d &lt;分支名&gt; &lt;path&gt; --depth=&lt;number&gt;</code> 克隆指定仓库下指定分支的number条提交历史</p>
<blockquote>
<p>示例：</p>
<p><code>git clone -b master &lt;path&gt; --depth=1</code> 只克隆远程仓库的master分支的最近一条提交</p>
</blockquote>
</li>
</ul>
<h4 id="Git-Config"><a href="#Git-Config" class="headerlink" title="Git Config"></a>Git Config</h4><ul>
<li><p><code>git config --list</code> 查看Git配置信息，配置信息可能会重复，如果存在重复Git会以最后一个值为准。</p>
<blockquote>
<p><code>--show-origin</code> 显示该配置的来源(路径)</p>
</blockquote>
</li>
<li><p><code>git config &lt;范围&gt; &lt;选项&gt; &lt;值&gt;</code> 在指定范围内设置指定配置信息。</p>
<blockquote>
<p>示例：</p>
<p><code>git config --global user.name &#39;author&#39;</code> 在全局范围内设置提交者的名称。<br>Git Config总共有3个范围，分别是system、global、local(默认值)，权重依次递增，system的影响范围是最大的，针对当前电脑下的所有Git仓库都生效；global针对当前用户下的所有Git仓库生效；local只对当前Git仓库生效。
  </p>
</blockquote>
</li>
<li><p><code>git config --global merge.conflictstyle diff3</code> 修改合并冲突样式为diff3，这种样式下会额外显示base的内容，如图5。</p>
<p>  <img src="%E6%88%AA%E5%B1%8F2021-08-10%2010.03.08.png"> 图5</p>
</li>
<li><p><code>git config --global help.autocorrect 50</code> 设置该选项后，当Git匹配了相似的命令时会在倒计时结束后自动执行该命令</p>
</li>
<li><p><code>git config --global core.autocrlf true</code> 启用该功能的话当你提交时Git会自动把回车和换行转换成一个换行符，而在检出代码时把一个换行符转换成回车和换行。</p>
<blockquote>
<p>在Windows的某些编辑器中，换行符是由回车符和换行符2个命令组成的，而在macOS和Linux系统中换行符只有一个符号。如果同一个项目在Windows和其他平台上开发，可能会遇到空格冲突。</p>
<p><code>input</code> 设置为input告诉Git在提交时把回车和换行转换成换行，检出时不转换</p>
</blockquote>
</li>
<li><p><code>core.whitespace</code> 空格处理方案，Git提供了6种处理多余空白字符的主要选项，3项默认开启，3项默认关闭</p>
<blockquote>
<p>默认开启：blank-at-eol(查找行尾的空格)，blank-at-eof(盯住文件底部的空行)，space-before-tab(警惕行头tab前面的空格)</p>
<p>默认关闭：indent-with-non-tab(揪出以空格而非tab开头的行，你可以用tabwidth选项控制它)，tab-in-indent(监视在行头表示缩进的tab)，cr-at-eol(告诉Git忽略行尾的回车)</p>
</blockquote>
</li>
</ul>
<p>如果想关闭某个选项，可以在输入设置选项时不指定它或在它前面加个 －</p>
<ul>
<li><p><code>git config &lt;范围&gt; alias.&lt;别名&gt; &#39;&lt;全名&gt;&#39;</code> 在指定范围内设置一个Git别名。</p>
<blockquote>
<p>示例：</p>
<p><code>git config --global alias.st &#39;status&#39;</code> 在全局范围内给status设置一个别名st。</p>
<p>别名通常用来简化命令，如果想给非Git命令起别名，例如gitk，可以这样设置<code>git config --global alias.gitk &#39;!gitk&#39;</code>，当你调用”git gitk”时会执行”gitk”命令。</p>
<blockquote>
<p>一些常用的别名：</p>
<p><code>git config --global alias.co checkout</code></p>
<p><code>git config --global alias.br branch</code></p>
<p><code>git config --global alias.ci commit</code></p>
<p><code>git config --global alias.st status</code></p>
<p><code>git config --global alias.s &#39;status -s&#39;</code></p>
<p><code>git config --global alias.last &#39;log -1&#39;</code>
  </p>
</blockquote>
</blockquote>
</li>
<li><p><code>git config &lt;范围&gt; --unset alias.&lt;name&gt;</code> 删除指定别名</p>
</li>
</ul>
<h4 id="Git-Diff"><a href="#Git-Diff" class="headerlink" title="Git Diff"></a>Git Diff</h4><ul>
<li><p><code>git diff</code> 显示工作区和暂存区之间的差异</p>
<blockquote>
<p><code>--cached(--staged)</code> 显示暂存区和最新提交之前的差异</p>
<p><code>--check</code> 打印所有可能的空格错误</p>
<p><code>--ours</code> 冲突时查看合并引入了什么</p>
<p><code>--theirs -b</code> 冲突时查看合并的结果与另一边有什么不同，-b表示去除空格</p>
<p><code>--base</code> 冲突时查看文件在两边是如何改动的</p>
</blockquote>
</li>
</ul>
<h4 id="Git-Log"><a href="#Git-Log" class="headerlink" title="Git Log"></a>Git Log</h4><ul>
<li><p><code>git log</code> 显示当前分支下的提交历史</p>
<blockquote>
<p><code>-n</code> 显示指定数量的提交记录，例如<code>git log -2</code>显示最近2条提交记录</p>
<p><code>--show-signature</code> 显示GPG签名信息</p>
<p><code>--stat</code> 显示提交时的简略信息</p>
<p><code>--abbrev-commit</code> 显示简短的哈希值</p>
<p><code>--relative-date</code> 显示一个相对时间(例如 9 hours ago)</p>
<p><code>--graph</code> 在日志旁以ASCII图形显示分支和合并历史</p>
<p><code>--oneline</code> –pretty&#x3D;oneline和–abbrev-commit的缩写</p>
<p><code>--pretty=</code>  使用其他格式显示提交历史</p>
<blockquote>
<p><code>oneline</code> 将每条提交放在一行显示</p>
<p><code>short</code> 不显示提交时间</p>
<p><code>full</code> 不显示提交时间但额外显示提交者信息</p>
<p><code>fuller</code> 显示提交者信息以及提交时间</p>
<p><code>format</code> 自定义显示风格(自定义风格可以不受Git版本影响)</p>
<blockquote>
<p>示例：</p>
<p><code>git log --pretty=format:&quot;%Cred%h%Creset - %C(yellow)%an%Creset, %C(green)%ar%Creset : %s&quot;</code> 一行显示简写的提交哈希值 - 作者名称, 提交相对时间 : 提交说明。</p>
<p>format可接受的选项如下：</p>
<p><code>%H</code> 提交的完整哈希值</p>
<p><code>%h</code> 提交的简写哈希值</p>
<p><code>%T</code> 树的完整哈希值</p>
<p><code>%t</code> 树的简写哈希值</p>
<p><code>%P</code> 父提交的完整哈希值</p>
<p><code>%p</code> 父提交的简写哈希值</p>
<p><code>%an</code> 作者的名称</p>
<p><code>%ae</code> 作者的电子邮件地址</p>
<p><code>%ad</code> 作者的修订日期</p>
<p><code>%ar</code> 作者的修订日期，按多久以前的方式显示，例如20 hours ago</p>
<p><code>%cn</code> 提交者的名称</p>
<p><code>%ce</code> 提交者的电子邮件地址</p>
<p><code>%cd</code> 提交日期</p>
<p><code>%cr</code> 提交日期，按多久以前的方式显示</p>
<p><code>%s</code> 提交说明</p>
<p>Git支持的颜色选项：</p>
<p>normal、black、red、green、yellow、blue、magenta、cyan、white</p>
<p>Git支持的字体属性</p>
<p>bold、dim、ul、blink、reverse</p>
</blockquote>
</blockquote>
<p><code>--author</code> 显示和指定作者的提交记录</p>
<p><code>--committer</code> 显示和指定提交者的提交记录</p>
<p><code>--grep</code> 显示提交说明中包含指定字符串的提交记录</p>
<p><code>-S</code> 显示对指定字符串进行了修改的提交记录(常用来查找某个函数的修改提交记录)</p>
<p><code>-G &lt;正则表达式&gt;</code> 使用正则查找相关的提交记录</p>
<p><code>-- &lt;path&gt;</code> 显示指定路径下的修改记录(常用来和其他选项搭配查找某个文件下某个函数的修改提交记录，一般写在最后)</p>
<p><code>-L</code> 显示指定文件中指定函数的相关修改提交记录</p>
<blockquote>
<p>示例：</p>
<p><code>git log -L :firstApplication:WXReader/AppDelegate.m</code> 显示AppDelegate.m文件下与firstApplication相关的修改提交</p>
</blockquote>
<p><code>--no-merges</code> 不显示合并提交</p>
<p><code>--after(--since)</code> 显示指定时间之后的提交记录</p>
<p><code>--before(--until)</code> 显示指定时间之前的提交记录</p>
<blockquote>
<p><code>--after</code>和<code>--before</code>可以搭配指定的时间值，例如”2008-08-08”，也可以是”2 years 1 day 3 minutes ago”、”2.weeaks”这样的相对日期</p>
<p>示例：</p>
<p><code>git log --author=&#39;internetwei&#39; --after=&quot;2020-01-01&quot; --before=&quot;2020-06-01&quot; --no-merges -- WXReader/Book/BookRack/BookReader</code> 显示作者internetwei在2020年1月1号到2020年6月1号之间对<code>WXReader/Book/BookRack/BookReader</code>这个文件夹(包括文件夹下所有的文件)有关的所有修改提交但不包括合并提交</p>
</blockquote>
<p><code>&lt;分支1&gt;..&lt;分支2&gt;</code> 显示分支2有但分支1没有的提交记录(常用来检查分支哪些提交未推送)</p>
<blockquote>
<p>和..语法等价的命令：</p>
<p><code>git log ^&lt;分支1&gt; &lt;分支2&gt;</code></p>
<p><code>git log &lt;分支2&gt; --not &lt;分支1&gt;</code></p>
<p>上面两种命令是..语法的扩展，除了查询2个引用，还支持查询超过2个引用，例如<code>git log refA refB ^refC</code>表示显示所有被<code>refA</code>或<code>refB</code>包含但不被<code>refC</code>包含的提交记录</p>
</blockquote>
<p><code>&lt;分支1&gt;...&lt;分支2&gt;</code> 显示分支1和分支2不共有的提交</p>
<blockquote>
<p><code>--left-right</code> 和…等类似语法搭配使用，可以用&lt;、&gt;表示左右分支
  </p>
</blockquote>
</blockquote>
</li>
<li><p><code>git shortlog</code> 显示当前分支的修改日志文档</p>
<blockquote>
<p>示例：</p>
<p><code>git shortlog --no-merges master --not v1.0</code> 显示master分支从v1.0标签后的所有非合并提交提交日志</p>
</blockquote>
</li>
</ul>
<h4 id="Git-Rebase"><a href="#Git-Rebase" class="headerlink" title="Git Rebase"></a>Git Rebase</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Merge和Rebase的区别：</span><br><span class="line"></span><br><span class="line">在Git中用来整合不同分支的修改有两种办法，一种是merge，另一种是rebase，这两种方案最终的结果没有任何区别，只不过提交历史不一样罢了，Rebase是将一系列的提交按照原有次序依次应用到另一个分支上，这样做可以使提交历史更加整洁；而合并是把最终结果合在一起。</span><br><span class="line"></span><br><span class="line">提取某次提交中引入的补丁和修改，然后在当前分支的基础上应用一次，这种操作就叫做rebase。</span><br><span class="line"></span><br><span class="line">rebase后的提交历史如图6，merge提交历史如图7，同样的提交，使用merge和rebase的区别一目了然。</span><br><span class="line"></span><br><span class="line">你可以自由选择`rebase`或`merge`，不过如果你选择`rebase`的话，请记住只对尚未推送或分享给别人的提交进行`rebase`操作。</span><br></pre></td></tr></table></figure>
<p><img src="%E6%88%AA%E5%B1%8F2021-08-03%2010.45.35.png"> 图6</p>
<p><img src="%E6%88%AA%E5%B1%8F2021-08-03%2010.49.53.png"> 图7</p>
<ul>
<li><p><code>git rebase &lt;分支&gt;</code> 将当前分支上的提交依次变基到目标分支上</p>
</li>
<li><p><code>git rebase &lt;分支1&gt; &lt;分支2&gt;</code> 将分支2上的提交依次变基到分支1上</p>
<blockquote>
<p>示例：</p>
<p><code>git rebase master experiment</code> 将experiment分支上的提交内容依次变基到master分支上，如图8</p>
<p><img src="0b1bc478bd2f48d5a25d5b886ec99f8d~tplv-k3u1fbpfcp-zoom-1.image"> 图8</p>
<p>切换到master分支再合并experiment分支就不会有分叉的提交历史了，如图9</p>
<p><img src="6518e127a0e446b8b790c21f620f7c26~tplv-k3u1fbpfcp-zoom-1.image"> 图9</p>
<blockquote>
<p>rebase的原理：</p>
<ol>
<li><p>首先找到这2个分支的最近共同祖先C2</p>
</li>
<li><p>然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件</p>
</li>
<li><p>然后将当前分支指向目标基底C3</p>
</li>
<li><p>最后以此将之前保存的临时文件的修改依次应用</p>
</li>
</ol>
</blockquote>
</blockquote>
</li>
<li><p><code>git rebase --onto &lt;分支1&gt; &lt;分支2&gt; &lt;分支3&gt;</code> 找到分支3在分支2分歧后的提交，然后把这些提交在分支1上依次应用一遍</p>
<blockquote>
<p>示例：</p>
<p><code>git rebase --onto master server client</code> 找到client分支，找出它从server分支分歧之后的提交，然后把这些提交在master分支上重放一遍，如图10所示</p>
</blockquote>
<p>  <img src="567d0c68f2854ef08fa29313a8ecaee7~tplv-k3u1fbpfcp-zoom-1.image"> 图10</p>
</li>
<li><p><code>git rebase -i &lt;区间&gt;</code> 对指定区间内的提交进行交互式变基</p>
<blockquote>
<p>示例：</p>
<p><code>git rebase -i HEAD~2</code> 对最近3次提交进行交互式变基，交互式变基的功能非常强大，可以实现“将任意提交压缩成一个提交”、“将一个提交拆成多个提交”、“修改任意提交的提交说明”、“重新排序”、“移除提交”等功能</p>
</blockquote>
</li>
<li><p><code>git commit --amend</code> 修改最新的提交信息</p>
<blockquote>
<p>虽然它是commit开头的命令，不过它的本质就是rebase操作，所以把它放在rebase里</p>
<p>该命令有2个作用：</p>
<ol>
<li><p>修改最新的提交说明；确保当前暂存区是干净的，然后运行此命令，它会将你带到提交说明编辑框，重新编辑提交信息然后保存退出即可。</p>
</li>
<li><p>补充提交文件；例如上次提交时忘记添加一个文件，或者上次提交的文件又有修改了，而这次修改应该和上次提交是一起的；首先将需要补充提交的文件添加到暂存区，确保暂存区的文件是你要补充提交的，然后运行此命令，编辑提交信息保存退出即可。</p>
</li>
</ol>
</blockquote>
</li>
<li><p><code>git cherry-pick &lt;commit&gt;</code> 将指定提交的修改在当前分支的基础上重放一遍并提交</p>
</li>
</ul>
<h4 id="Git-Remote"><a href="#Git-Remote" class="headerlink" title="Git Remote"></a>Git Remote</h4><ul>
<li><p><code>git remote</code> 显示所有远程仓库的名称</p>
<blockquote>
<p><code>-v</code> 显示远程仓库的具体信息</p>
<p><code>show &lt;仓库名&gt;</code> 显示指定远程仓库的详细信息</p>
<p><code>ls-remote &lt;仓库名&gt;</code> 显示指定远程仓库的完整引用列表</p>
<p><code>prune &lt;仓库名&gt;</code> 删除本地镜像仓库存在但远程已删除的分支信息</p>
<p><code>git remote set-url &lt;仓库名&gt; &lt;url&gt;</code> 修改指定仓库的地址
  </p>
</blockquote>
</li>
<li><p><code>git fetch &lt;仓库名&gt;</code> 拉取指定仓库的信息并更新本地的仓库信息(这只会更新本地的远程镜像仓库，不会修改本地分支和工作区内容)</p>
</li>
<li><p><code>git pull</code> 拉取上游分支的新提交并合并，它是<code>fetch</code>和<code>merge</code>2个命令的缩写</p>
<blockquote>
<p>pull 命令需要该分支拥有上游分支，如果没有上游分支会提示错误信息，它会运行<code>git fetch</code>将远程仓库的信息拉取下来，然后运行<code>git merge</code>合并远程的提交</p>
</blockquote>
</li>
<li><p><code>git branch -u(--set-upstream-to) &lt;远程分支引用&gt;</code> 设置&#x2F;修改当前分支的上游分支引用</p>
<blockquote>
<p><code>git branch -u origin/dev</code> 设置&#x2F;修改当前分支的上游分支为origin仓库的dev分支</p>
<p>当某个分支拥有上游分支后，可以使用{u(upstream)}代替上游分支</p>
</blockquote>
</li>
<li><p><code>git push</code> 将当前分支的新提交推送到上游分支</p>
<blockquote>
<p><code>git push origin refs/head/dev:refs/head/dev</code> 这是推送命令的全称，将本地dev分支推送到远程dev分支上</p>
<p><code>git push origin v1.0</code> 推送指定标签到远程仓库(默认推送并不会推送标签)</p>
<p><code>git push origin --tags</code> 推送所有标签到远程仓库</p>
<p><code>git push origin --delete dev</code> 删除远程仓库的dev分支</p>
<p><code>git push origin --delete v1.0</code> 删除远程仓库的v1.0分支</p>
<p><code>git push origin --delete</code>命令实际是<code>git push origin :refs/head/dev</code>，推送一个空对象覆盖远程仓库的dev分支(这么做只是从服务器上移除一个指针，Git通常会将数据保存一段时间直到垃圾回收机制运行。</p>
</blockquote>
</li>
</ul>
<h4 id="Git-Tag"><a href="#Git-Tag" class="headerlink" title="Git Tag"></a>Git Tag</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tag和Branch的区别：</span><br><span class="line"></span><br><span class="line">相同点：都是一个指向commit对象的指针</span><br><span class="line"></span><br><span class="line">不同点：Tag的位置是固定的，永远指向一个具体的commit对象。而Branch会随着分支的提交或回滚变化位置。</span><br><span class="line"></span><br><span class="line">轻量Tag和附注Tag的区别：</span><br><span class="line"></span><br><span class="line">轻量Tag就像一个不会改变的分支，它只是某个特定提交的引用；而附注Tag则是一个完整的Git对象，它包含打标签者的相关信息、打标签的时间、打标签的说明，还支持GPG签名和验证。</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>git tag &lt;标签名&gt;</code> 给当前提交创建一个轻量Tag</p>
<blockquote>
<p><code>-a</code> 创建一个附注Tag</p>
<p><code>&lt;hash&gt;</code> 尾随一个哈希值，可以给指定提交创建Tag</p>
<p><code>-s</code> 使用GPG对标签进行签名</p>
<p><code>-l(--list) &quot;v1.*&quot;</code> 显示所有以”v1.”开头的标签，支持正则匹配</p>
<p><code>-v</code> 使用GPG验证签名(前提是签名者的公钥需要在你的钥匙链中)</p>
</blockquote>
</li>
</ul>
<h4 id="Git-Branch"><a href="#Git-Branch" class="headerlink" title="Git Branch"></a>Git Branch</h4><ul>
<li><p><code>git branch</code> 显示所有本地分支</p>
<blockquote>
<p><code>-v</code> 显示分支对应的最新提交</p>
<p><code>-vv</code> 显示分支与上游分支的落后&#x2F;领先情况</p>
<p><code>-merged</code> 显示与当前分支已合并的分支</p>
<p><code>--no-merged</code> 显示与当前分支未合并的分支</p>
</blockquote>
</li>
</ul>
<h4 id="Git-Merge"><a href="#Git-Merge" class="headerlink" title="Git Merge"></a>Git Merge</h4><ul>
<li><p><code>git merge &lt;分支名&gt;</code> 合并指定分支</p>
<blockquote>
<p><code>--squash</code> 将合并产生的多个提交压缩成一个提交</p>
<p><code>--verify-signature</code> 拒绝合并那些GPG签名验证不通过的提交</p>
<p><code>-Xignore-space-change</code> 将一个空白符与多个连续的空白字符视作等价</p>
<p><code>-Xignore-all-space</code> 合并时完全忽略空白修改</p>
<p><code>-Xours</code> 遇到冲突时保留当前分支的修改内容</p>
<p><code>-Xtheirs</code> 遇到冲突时保留目标分支的修改内容
  </p>
</blockquote>
</li>
<li><p><code>git merge-base &lt;分支1&gt; &lt;分支2&gt;</code> 获取2个分支最近的公共提交</p>
</li>
<li><p><code>git merge --verity-signature -S &lt;分支名&gt;</code> 生成一个签名的合并提交</p>
</li>
<li><p><code>git merge -s ours &lt;分支名&gt;</code> 做一次假的合并，记录一个以两边分支作为父结点的新合并提交，但是它甚至根本不关注你正合并入的分支，它只会简单地把当前分支的代码当作合并结果记录下来</p>
<blockquote>
<p>假如你有一个分叉的release分支并且在上面做了一些你想要在未来某个时候合并回master的工作，与此同时master分支上的某些bugfix需要向后移植回release分支，你可以合并bugfix分支进入release分支同时也merge -s ours 合并进入你的master分支(即使那个修复已经在那里了)这样当你之后再次合并release分支时，就不会有来自bugfix的冲突。</p>
</blockquote>
</li>
</ul>
<h4 id="Git-邮箱工作"><a href="#Git-邮箱工作" class="headerlink" title="Git 邮箱工作"></a>Git 邮箱工作</h4><ul>
<li><p><code>git format-patch -M &lt;分支名&gt;</code> 生成当前分支和指定分支之间不共有的提交补丁文件到根目录下(有几个提交就会生成几个补丁文件)</p>
<blockquote>
<p>示例：</p>
<p><code>git format-patch -M origin/master</code> 生成当前分支和origin&#x2F;master分支之间不共有的提交补丁文件到根目录下(这会生成一份可以邮寄的mbox格式的文件，它将每一个提交转换为一封电子邮件)。<code>-M</code>表示允许Git检查是否有对文件重命名的提交</p>
</blockquote>
</li>
<li><p><code>git apply --check &lt;path&gt;</code> 检查指定路径下的补丁内容是否可以被应用</p>
</li>
<li><p><code>git apply &lt;path&gt;</code> 应用指定路径下的补丁内容</p>
</li>
<li><p><code>git am &lt;path&gt;</code> 和<code>git apply</code>功能类似，不过比它更智能</p>
<blockquote>
<p><code>--resolved</code> 继续应用下一个补丁</p>
<p><code>-3</code> 表示当应用补丁发生冲突时Git会尝试进行三方合并，该选项默认是关闭的</p>
<p><code>am</code>的含义：应用(Apply)一系列来自邮箱(Mailbox)的补丁</p>
<p><code>git apply</code>用于应用<code>git diff</code>或<code>Unix diff</code>命令创建的补丁，它和<code>patch -p1</code>命令几乎是等效的，但是<code>git apply</code>更加严格，相对于<code>patch</code>来说它能够接受的模糊匹配更少，<code>git apply</code>采用了一种”要么全部应用，要么就全部撤销”的模型，即补丁只有全部内容都被应用和全部不被应用两种状态，如果补丁是用<code>git format-patch</code>来创建的，那么建议使用<code>git am</code>来应用补丁，只有对老式的补丁，你才必须使用<code>git apply</code></p>
</blockquote>
</li>
</ul>
<h4 id="Git-Rerere"><a href="#Git-Rerere" class="headerlink" title="Git Rerere"></a>Git Rerere</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Rerere是“重用已记录的冲突解决方案”的意思，它是一种简化冲突解决的方法，当启动rerere时，Git会维护一些成功合并之前和之后的镜像，当Git发现之前已经修复过类似的冲突时，便会使用之前的修复方案而不需要你的干预</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>git config --global rerere.enabled true</code> 启用Rerere功能</p>
<blockquote>
<p>对于已经创建的仓库如果想启动Rerere功能，需要手动在.git文件夹下创建一个rr-cache文件夹</p>
<p>开启Rerere后会增加本地仓库的体积，rr-cache文件夹只存在于本地仓库，不会推送到远程
  </p>
</blockquote>
</li>
<li><p><code>git checkout --conflict=merge &lt;path&gt;</code> 将指定文件恢复到Rerere执行前的状态</p>
</li>
</ul>
<h4 id="Git-归档"><a href="#Git-归档" class="headerlink" title="Git 归档"></a>Git 归档</h4><ul>
<li><p><code>git archive &lt;commit&gt; --prefix=&#39;&lt;解压后的文件名&gt;/&#39; | gzip &gt; &lt;压缩包的名称&gt;.tar.gz</code> 基于指定提交对象创建一个当前所有快照内容的压缩文件</p>
<blockquote>
<p>示例：</p>
<p><code>git archive master --prefix=&#39;project/&#39; &gt; gzip &gt; master.tar.gz</code> 基于master最新提交的所有快照内容创建一个tar.gz压缩文件</p>
<p>git archive master –prefix&#x3D;’project&#x2F;‘ –format&#x3D;zip &gt; `git describe master`.zip 基于master最新提交的所有快照内容创建一个zip压缩文件
  </p>
</blockquote>
</li>
<li><p><code>git bundle</code> 对分支进行打包</p>
<blockquote>
<p>示例：</p>
<p><code>git bundle create repo.bundle HEAD master</code> 对master分支的所有提交历史进行打包
  </p>
</blockquote>
</li>
<li><p><code>git bundle verify &lt;path&gt;</code> 检查指定bundle包是否合法</p>
</li>
<li><p><code>git bundle list-heads &lt;path&gt;</code> 列出指定bundle包的引用</p>
</li>
</ul>
<h4 id="Git-Stash"><a href="#Git-Stash" class="headerlink" title="Git Stash"></a>Git Stash</h4><ul>
<li><p><code>git stash</code> 贮藏所有已跟踪的未提交文件，并还原暂存区和工作区的修改变化</p>
<blockquote>
<p><code>-u(--include-untracked)</code> 贮藏所有已跟踪和未跟踪的文件(不包括忽略文件)</p>
<p><code>-a(--all)</code> 贮藏所有文件(包括忽略文件)</p>
<p><code>--keep-index</code> 保存到贮藏的同时不清空暂存区的内容</p>
<p><code>list</code> 查看所有贮藏文件列表</p>
<p><code>apply</code> 恢复最新的贮藏文件但不删除，可以指定某个贮藏文件</p>
<p><code>pop</code> 和apply命令一样但是会自动删除贮藏文件(仅在恢复成功时自动删除)</p>
<p><code>--index</code> 如果在<code>pop</code>和<code>apply</code>时加上此选项会把贮藏前在暂存区的内容重新加到暂存区中，默认全部恢复在工作区
  </p>
</blockquote>
</li>
<li><p><code>git stash &lt;贮藏文件&gt; &lt;分支名&gt;</code> 使用指定贮藏文件创建一个分支</p>
</li>
</ul>
<h4 id="Git-Add"><a href="#Git-Add" class="headerlink" title="Git Add"></a>Git Add</h4><ul>
<li><p><code>git add</code> 将文件加入到暂存区中</p>
<blockquote>
<p><code>-i(--interactive)</code> 使用交互式终端模式进行暂存</p>
<p><code>-p(--patch)</code> 自定义暂存补丁文件(该命令只是-i的一个子命令)</p>
</blockquote>
</li>
</ul>
<h4 id="Git-Commit"><a href="#Git-Commit" class="headerlink" title="Git Commit"></a>Git Commit</h4><ul>
<li><p><code>git commit</code> 将暂存区的文件提交到Git仓库</p>
<blockquote>
<p><code>-S</code> 使用GPG签名此次提交</p>
<p><code>-m &quot;注释&quot;</code> 使用指定注释作为提交内容</p>
<p><code>-a</code> 将已跟踪的所有文件加入到暂存区(未跟踪的文件不会加入到暂存区)</p>
<p><code>-am</code> -a和-m这2个命令的缩写</p>
</blockquote>
</li>
</ul>
<h4 id="Git-搜索"><a href="#Git-搜索" class="headerlink" title="Git 搜索"></a>Git 搜索</h4><ul>
<li><p><code>git grep &lt;字符串&gt;</code> 在工作区中搜索指定字符串出现的所有位置</p>
<blockquote>
<p>示例：</p>
<p><code>git grep --break --heading -n -e &#39;#define&#39; --and \( -e kEncryptionSecret -e kEncryptionKey \) v4.6.0</code> 查看在v4.6.0标签的Git代码库中定义了常量名包含”kEncryptionSecret”或”kEncryptionKey”这两个字符串的位置</p>
<p><code>-n(--line-number)</code> 显示在文件中的行数</p>
<p><code>-c(--count)</code> 显示在文件中匹配的数量</p>
<p><code>-p(--show-function)</code> 显示该字符串上下文内容</p>
</blockquote>
</li>
</ul>
<h4 id="Git-Subtree"><a href="#Git-Subtree" class="headerlink" title="Git Subtree"></a>Git Subtree</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这里没有提到 git submodule(子模块)，因为使用子模块相比Subtree更麻烦，例如在有子模块的仓库中切换分支需要重新初始化一下子模块，git subtree可以实现git submodule的功能，并且比git submodule更简单。</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>git subtree add --prefix=&lt;path&gt; &lt;link&gt; &lt;分支名&gt;</code> 添加指定仓库下的指定分支内容到指定路径下</p>
<blockquote>
<p>示例：</p>
<p><code>git subtree add --prefix=sub/libpng &lt;link&gt; master</code> 拉取指定仓库下master分支到sub&#x2F;libpng文件夹下
  </p>
</blockquote>
</li>
<li><p><code>git subtree pull --prefix=&lt;path&gt; &lt;link&gt; &lt;分支名&gt;</code> 拉取子树的修改提交</p>
</li>
<li><p><code>git subtree push --prefix=&lt;path&gt; &lt;link&gt; &lt;分支名&gt;</code> 推送子树的修改提交</p>
</li>
</ul>
<h4 id="Git-Filter"><a href="#Git-Filter" class="headerlink" title="Git Filter"></a>Git Filter</h4><ul>
<li><p><code>git filter-branch</code> 重写提交历史</p>
<blockquote>
<p>示例：</p>
<p><code>git filter-branch --tree-filter &#39;rm -f password.txt&#39; HEAD</code> 从Git仓库中删除password.txt，–tree-filter表示检出项目的每一个提交后运行指定的命令然后重新提交结果，如果要让上述命令在所有分支上运行，可以加上–all</p>
<p><code>git filter-branch --subdirectory-filter trunk HEAD</code> 将trunk子目录设置为项目的根目录，Git会自动移除所有不影响子目录的提交</p>
</blockquote>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git filter-branch --commit-filter &#x27;</span><br><span class="line">if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;internetwei@foxmail.com&quot; ];</span><br><span class="line">then</span><br><span class="line">        GIT_AUTHOR_NAME=&quot;Scott Chacon&quot;;</span><br><span class="line">        GIT_AUTHOR_EMAIL=&quot;schacon@example.com&quot;;</span><br><span class="line">        git commit-tree &quot;$@&quot;;</span><br><span class="line">else</span><br><span class="line">        git commit-tree &quot;$@&quot;;</span><br><span class="line">fi&#x27; HEAD </span><br><span class="line"></span><br><span class="line">遍历所有提交，如果作者邮件地址是internetwei@foxmail.com则修改作者名称和邮件地址(即使某个提交不用修改但是它的哈希值也会更改)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>git filter-repo</code> 重写提交历史</p>
<blockquote>
<p>Git官方建议使用git filter-repo而不是git filter-branch，因为git filter-branch在重写提交历史时充满大量的陷阱，性能也很低，它的设计架构在接口的每一层都存在泄漏，这使得它几乎不可能在不向后兼容的情况下更改设计的任何内容。相比较而言git filter-repo的功能更多，而且性能也高出很多(有资料说用git filter-repo几个小时完成的任务用git filter-branch需要等待3个月)。</p>
<p><code>git filter-repo --path-rename &lt;old_name:new_name&gt;</code> 遍历提交历史，将作者名从old_name修改为new_name</p>
<p><code>--tag-rename &lt;old_tag:new_tag&gt;</code> 遍历提交历史，重命名以old开头的标签并以new开头，例如<code>--tag-rename foo:bar</code>会将foo-1.2改为bar-1.2</p>
<p>想学习git filter-repo请查看<a target="_blank" rel="noopener" href="https://htmlpreview.github.io/?https://github.com/newren/git-filter-repo/blob/docs/html/git-filter-repo.html">git filter-repo命令手册</a></p>
</blockquote>
</li>
</ul>
<h4 id="Git-Show"><a href="#Git-Show" class="headerlink" title="Git Show"></a>Git Show</h4><ul>
<li><p><code>git show &lt;分支名&gt;@&#123;yesterday&#125;</code> 查看指定分支在昨天的最后一次提交对象</p>
<blockquote>
<p>yesterday可以是其他任意Git可以识别的时间
  </p>
</blockquote>
</li>
<li><p><code>git show &lt;commit&gt;:&lt;path&gt;</code> 查看指定提交下指定文件的内容</p>
</li>
</ul>
<h4 id="Git-Reset"><a href="#Git-Reset" class="headerlink" title="Git Reset"></a>Git Reset</h4><ul>
<li><p><code>git reset --soft &lt;commit&gt;</code> 将当前分支移动到指定提交上(这样做会导致Git仓库和暂存区与工作区的内容不一致，而暂存区和工作区的内容一致，所以Git会提示你进行commit操作和Git仓库保持一致)，如图11。</p>
<p>   <img src="646fd8d8cf5941a1a2a3bbd2c140423c~tplv-k3u1fbpfcp-zoom-1.image"> 图11</p>
</li>
<li><p><code>git reset --mixed &lt;commit&gt;</code> 默认行为，将当前分支移动到指定提交上并且更新暂存区的内容(这样做会导致Git仓库和暂存区的内容一致，但是和工作区的内容不一致，这时Git会提交你进行add操作将需要提交的文件添加到暂存区)，如图12</p>
<p>   <img src="aefb6b8501144712b39ccb51ad152e54~tplv-k3u1fbpfcp-zoom-1.image"> 图12</p>
</li>
<li><p><code>git reset --hard &lt;commit&gt;</code> 将当前分支移动到指定提交上并且更新暂存区和工作区的内容，这也是reset唯一危险的命令(这样做Git会使用版本库中的内容更新(覆盖)暂存区和工作区的内容)，如图13</p>
<p>   <img src="63c1aeeafb13499885b805f05815048a~tplv-k3u1fbpfcp-zoom-1.image"> 图13</p>
</li>
<li><p><code>git reset &lt;path&gt;</code> 将指定文件从暂存区中删除</p>
<blockquote>
<p>它本质上调用的是<code>git reset --mixed HEAD &lt;path&gt;</code>命令，使用版本库中的指定文件覆盖暂存区的文件，所以它可以将文件从暂存区中移除</p>
</blockquote>
</li>
</ul>
<h4 id="Git-Checkout"><a href="#Git-Checkout" class="headerlink" title="Git Checkout"></a>Git Checkout</h4><ul>
<li><p><code>git checkout -b &lt;分支名&gt;</code> 创建并切换到指定分支</p>
<blockquote>
<p>该命令其实是<code>git branch &lt;分支名&gt;</code>和<code>git checkout &lt;分支名&gt;</code>的缩写</p>
<p>切换分支建议使用<code>git switch &lt;分支名&gt;</code>，一是因为switch比checkout更容易理解，二是因为switch命令比checkout命令更安全(例如本地有一个文件名和某一个分支同名，当你使用git checkout &lt;文件&#x2F;分支名&gt; 时可能会不小心覆盖工作区的内容)</p>
</blockquote>
</li>
<li><p><code>git checkout -- &lt;path&gt;</code> 撤销工作区指定文件的修改</p>
<blockquote>
<p>该命令会使用当前版本库中的指定文件覆盖工作区的指定文件，如果工作区的文件有任何修改将会丢失</p>
</blockquote>
</li>
</ul>
<h4 id="Git-Revert"><a href="#Git-Revert" class="headerlink" title="Git Revert"></a>Git Revert</h4><ul>
<li><p><code>git revert &lt;commit&gt;</code> 还原指定提交的内容</p>
<blockquote>
<p>该命令用于将某次提交的内容重置并生成一次新提交</p>
</blockquote>
</li>
</ul>
<h4 id="Git-Blame"><a href="#Git-Blame" class="headerlink" title="Git Blame"></a>Git Blame</h4><ul>
<li><p><code>git blame -L &lt;range&gt; &lt;path&gt;</code> 查看指定文件中指定范围内的修改提交记录</p>
<blockquote>
<p>示例：</p>
<p><code>git blame -L 68,100 WXYZ_BookReaderViewController.m</code> 查看WXYZ_BookReaderViewController.m文件有关第68到100行的修改提交记录</p>
<p><code>-C</code> 该选项表示Git会分析你正在标注的文件，并且尝试找出文件中代码片段的原始出处</p>
</blockquote>
</li>
</ul>
<h4 id="Git-Bisect"><a href="#Git-Bisect" class="headerlink" title="Git Bisect"></a>Git Bisect</h4><ul>
<li><p><code>git bisect</code> 使用二分搜索查找引入错误的提交</p>
<blockquote>
<p>使用流程：</p>
<p><code>git bisect start</code> 启动二分查找</p>
<p><code>git bisect bad</code> 告诉Git当前提交是有问题的</p>
<p><code>git bisect good &lt;commit&gt;</code> 告诉Git没有问题的提交是哪一次</p>
<p><code>git bisect good</code> 告诉Git当前提交没有问题</p>
<p><code>git bisect reset</code> 结束二分查找</p>
<p><code>git biesect start &lt;bad_id&gt; &lt;good_id&gt;</code> 快速执行二分查找，第一个参数是不正常的提交，第二个参数是正常的提交</p>
<p><code>git bisect run &lt;path&gt;</code> 执行脚本进行二分查找</p>
</blockquote>
</li>
</ul>
<h4 id="Git-Replace"><a href="#Git-Replace" class="headerlink" title="Git Replace"></a>Git Replace</h4><ul>
<li><p><code>git replace</code> 替换指定对象</p>
<blockquote>
<p><code>git replace &lt;commit1&gt; &lt;commit2&gt;</code> 将commit1替换为commit2</p>
</blockquote>
</li>
</ul>
<h4 id="Git-底层命令"><a href="#Git-底层命令" class="headerlink" title="Git 底层命令"></a>Git 底层命令</h4><ul>
<li><p><code>git ls-files</code> 显示有关索引和工作树中文件的信息</p>
<blockquote>
<p><code>-u(--unmerged)</code> 显示冲突对象的哈希值</p>
<p><code>-s(--stage)</code> 显示暂存区当前状态
  </p>
</blockquote>
</li>
<li><p><code>git rev-list</code> 按时间倒序列出提交对象</p>
<blockquote>
<p><code>--count &lt;分支名&gt;</code> 查看指定分支的提交数量
  </p>
</blockquote>
</li>
<li><p><code>git cat-file</code> 查看指定对象的内容或类型和大小信息</p>
<blockquote>
<p><code>-p</code> 获取指定对象的内容或类型信息</p>
<p><code>-t</code> 获取指定对象的类型</p>
<p><code>-s</code> 获取指定对象的大小
  </p>
</blockquote>
</li>
<li><p><code>git ls-tree</code> 列出树对象的内容</p>
<blockquote>
<p><code>-r</code> 递归子树对象下的内容
  </p>
</blockquote>
</li>
<li><p><code>git update-ref</code> 更新存储在ref中的对象名称</p>
<blockquote>
<p>示例：</p>
<p><code>git update-ref refs/tags/v1.0 c7cfb9</code> 给指定提交对象添加一个轻量标签
  </p>
</blockquote>
</li>
<li><p><code>git count-objects -v</code> 查看仓库的详细占用空间</p>
</li>
<li><p><code>git for-each-ref</code> 显示所有的引用</p>
</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">布多</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://budo.top/2021/08/11/开发工具/Git命令手册/">https://budo.top/2021/08/11/开发工具/Git命令手册/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://budo.top">布多的博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Git/">Git</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/01/20/iOS/ObjC%20%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"><i class="fa fa-chevron-left">  </i><span>ObjC 开发规范</span></a></div><div class="next-post pull-right"><a href="/2021/08/07/iOS/ObjC%20%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/"><span>ObjC 风格指南</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="lv-container" data-id="city" data-uid="MTAyMC81MzU5Ny8zMDA3MA=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div><footer class="footer-bg" style="background-image: url(/images/backgroundImage.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2025 By 布多</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>