<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="iOS 开发者必备：深入理解 for-in 循环的实现原理"><meta name="keywords" content="底层原理"><meta name="author" content="布多"><meta name="copyright" content="布多"><title>iOS 开发者必备：深入理解 for-in 循环的实现原理 | 布多的博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?f0d94d3f99211c3546490e469f6ecbd8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '6.3.0'
} </script><link rel="alternate" href="/atom.xml" title="布多的博客" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for-in-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">for-in 底层实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NSArray-%E7%9A%84-for-in-%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.</span> <span class="toc-text">NSArray 的 for-in 实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">实战应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.jpg"></div><div class="author-info__name text-center">布多</div><div class="author-info__description text-center">前进！前进！！不择手段地前进！！！</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/internetwei">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">19</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">4</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友链</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.coderqi.com/">齐小胖之家</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/images/backgroundImage.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">布多的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/about">关于</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">iOS 开发者必备：深入理解 for-in 循环的实现原理</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2025-05-20</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/">iOS</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">3.1k</span><span class="post-meta__separator">|</span><span>阅读时长: 10 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>由 布多(budo) 发布于 2025-05-20</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 iOS 开发中，for-in 循环以其简洁优雅的语法和高效的遍历性能，成为了开发者遍历集合对象的首选方式。然而，你是否曾好奇过：为什么 for-in 循环能够如此高效地遍历集合对象？它的底层究竟是如何实现的？本文将深入剖析 ObjC 中 for-in 遍历的底层实现原理，从 NSFastEnumeration 协议到快速枚举器的具体实现，带你揭开 for-in 遍历的神秘面纱。通过理解其底层机制，你将能够更好地运用这一重要技术，并在实际开发中做出更优的技术选择。</p>
<p>注：虽然 Swift 中的 for-in 语法与 ObjC 类似，但它们的底层实现原理并不相同，本文主要聚焦于 ObjC 中的实现细节。</p>
<h2 id="for-in-底层实现原理"><a href="#for-in-底层实现原理" class="headerlink" title="for-in 底层实现原理"></a>for-in 底层实现原理</h2><p>让我们通过一个简单的示例代码，来开始探索 for-in 遍历的底层实现原理：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *arr = @[@<span class="number">1</span>, @<span class="number">2</span>, @<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSNumber</span> *number <span class="keyword">in</span> arr) &#123;</span><br><span class="line">        printf(<span class="string">&quot;num: %ld\n&quot;</span>, [number integerValue]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了深入理解 for-in 循环的底层实现原理，我们可以使用 <code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-18.0.0 main.m</code> 命令将 ObjC 代码转换为 C++ 代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__objcFastEnumerationState</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    一个用于追踪迭代状态的值，一般是内部已经遍历过的对象数量。</span></span><br><span class="line"><span class="comment">    在每次调用协议方法时会更新。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> state;</span><br><span class="line">	<span class="comment">// 一个指向包含当前批次对象的 C 数组指针</span></span><br><span class="line">	<span class="type">void</span> **itemsPtr;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    在一个可变子类中，mutationsPtr 被设置为指向一个值，每当容器被修改（添加、删除、重新排序）时，这个值将被改变。</span></span><br><span class="line"><span class="comment">    这个值在调用者处被缓存，并在每次迭代时进行比较。如果在迭代过程中发生变化，则调用相应函数处理（一般是抛出异常）。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> *mutationsPtr;</span><br><span class="line">	<span class="comment">// 保留数组，用于存储额外的状态信息。</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> extra[<span class="number">5</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里省略了 arr 数组的初始化相关代码</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        NSNumber *number;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">__objcFastEnumerationState</span> enumState = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="comment">// 一个用于存储当前批次对象的 C 数组</span></span><br><span class="line">        id __rw_items[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        等同于：[arr countByEnumeratingWithState:&amp;enumState objects:__rw_items count:16]</span></span><br><span class="line"><span class="comment">        这个方法会返回当前批次需要遍历的对象数量。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> limit = <span class="built_in">objc_msgSend</span>(arr,</span><br><span class="line">                                                <span class="built_in">sel_registerName</span>(<span class="string">&quot;countByEnumeratingWithState:objects:count:&quot;</span>),</span><br><span class="line">                                                &amp;enumState,</span><br><span class="line">                                                __rw_items,</span><br><span class="line">                                                <span class="number">16</span>);</span><br><span class="line">        <span class="comment">// 如果 limit 大于 0，说明有对象需要遍历</span></span><br><span class="line">        <span class="keyword">if</span> (limit) &#123;</span><br><span class="line">            <span class="comment">// 缓存当前集合的修改状态，用于检测遍历过程中是否对集合进行了修改操作。</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> startMutations = *enumState.mutationsPtr;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 当前批次对象的索引，从 0 开始</span></span><br><span class="line">                <span class="type">unsigned</span> <span class="type">long</span> counter = <span class="number">0</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">// 检查遍历过程中是否对集合进行了修改操作，如果修改了则抛出异常</span></span><br><span class="line">                    <span class="keyword">if</span> (startMutations != *enumState.mutationsPtr) &#123;</span><br><span class="line">                        <span class="built_in">objc_enumerationMutation</span>(arr);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 取出当前批次的对象，并执行循环体内的代码</span></span><br><span class="line">                    number = (NSNumber *)enumState.itemsPtr[counter++];</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;num: %ld\n&quot;</span>, <span class="built_in">objc_msgSend</span>(number, <span class="built_in">sel_registerName</span>(<span class="string">&quot;integerValue&quot;</span>)));</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="comment">// 遍历当前批次的对象，直到遍历完当前批次的所有对象</span></span><br><span class="line">                &#125; <span class="keyword">while</span> (counter &lt; limit);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获取下一批次需要遍历的对象，直到没有需要遍历的对象为止。</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (limit = <span class="built_in">objc_msgSend</span>(arr,</span><br><span class="line">                                        <span class="built_in">sel_registerName</span>(<span class="string">&quot;countByEnumeratingWithState:objects:count:&quot;</span>),</span><br><span class="line">                                        &amp;enumState,</span><br><span class="line">                                        __rw_items,</span><br><span class="line">                                        <span class="number">16</span>));</span><br><span class="line">            number = (NSNumber *)<span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            number = (NSNumber *)<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过分析转换后的代码，我们可以清晰地看到 for-in 遍历的实现原理是依靠 2 层 do-while 循环加上 <code>countByEnumeratingWithState:objects:count:</code> 方法来实现的。总结如下：</p>
<ol>
<li>调用 <code>countByEnumeratingWithState:objects:count:</code> 方法获取当前批次需要遍历的对象；</li>
<li>遍历当前批次的所有对象，并执行 for-in 循环体内的代码；</li>
<li>重复执行步骤一和步骤二，直到没有需要遍历的对象为止。</li>
</ol>
<h2 id="NSArray-的-for-in-实现"><a href="#NSArray-的-for-in-实现" class="headerlink" title="NSArray 的 for-in 实现"></a>NSArray 的 for-in 实现</h2><p>虽然苹果没有开源 NSArray 的 <code>countByEnumeratingWithState:objects:count:</code> 方法实现，但我们可以通过分析 <a target="_blank" rel="noopener" href="https://github.com/mlcldh/GNUstepBase">GNUStep</a> 开源项目中的实现来理解其工作原理。<a target="_blank" rel="noopener" href="https://github.com/mlcldh/GNUstepBase">GNUStep</a> 是一个开源库，它将 ObjC 的 Cocoa 库重新实现了一遍，虽然它不是苹果官方源码，但还是具有一定的参考价值。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSUInteger</span>)countByEnumeratingWithState:(<span class="built_in">NSFastEnumerationState</span> *)state</span><br><span class="line">                                  objects:(__<span class="keyword">unsafe_unretained</span> <span class="type">id</span> [])stackbuf</span><br><span class="line">                                    count:(<span class="built_in">NSUInteger</span>)len &#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> count;</span><br><span class="line">    </span><br><span class="line">    state-&gt;mutationsPtr = (<span class="type">unsigned</span> <span class="type">long</span> *)&amp;state-&gt;mutationsPtr;</span><br><span class="line">    <span class="comment">// 计算当前批次需要遍历的对象数量</span></span><br><span class="line">    count = MIN(len, [<span class="keyword">self</span> count] - state-&gt;state);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查数组中是否还有未遍历的对象</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        IMP imp = [<span class="keyword">self</span> methodForSelector:<span class="keyword">@selector</span>(objectAtIndex:)];</span><br><span class="line">        <span class="comment">// 当前遍历的索引</span></span><br><span class="line">        <span class="type">int</span> p = state-&gt;state;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++, p++) &#123;</span><br><span class="line">            <span class="comment">// 获取数组中的对象，并填充到缓冲区。</span></span><br><span class="line">            stackbuf[i] = (*imp)(<span class="keyword">self</span>, <span class="keyword">@selector</span>(objectAtIndex:), p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新 state，表示已经遍历过的对象数量。</span></span><br><span class="line">        state-&gt;state += count;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将缓冲区赋值给 state-&gt;itemsPtr，表示当前批次需要遍历的对象</span></span><br><span class="line">    state-&gt;itemsPtr = stackbuf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前批次需要遍历的对象数量</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过分析 <a target="_blank" rel="noopener" href="https://github.com/mlcldh/GNUstepBase">GNUStep</a> 的实现，我们可以大致理解 NSArray 是如何实现快速枚举的。<code>countByEnumeratingWithState:objects:count:</code> 方法是 for-in 循环的核心，它的实现逻辑可以分为以下几个关键步骤：</p>
<ol>
<li>批量计算：根据缓冲区大小和剩余未遍历对象数量，计算当前批次可以返回的对象数量，避免一次性加载过多数据；</li>
<li>批量获取：通过 <code>objectAtIndex:</code> 方法批量获取数组元素，并填充到缓冲区中，减少方法调用开销；</li>
<li>状态更新：更新遍历状态，记录已遍历的对象数量，确保遍历的连续性；</li>
<li>指针设置：将缓冲区的起始地址赋值给 state-&gt;itemsPtr，供 for-in 循环直接访问，提高访问效率；</li>
<li>数量返回：返回当前批次实际获取的对象数量。</li>
</ol>
<p>这种批量获取的设计是 for-in 循环性能优异的关键。与传统的 for 循环相比，for-in 循环通过一次性返回多个元素的方式，显著减少了方法调用的次数，从而提升了遍历效率。同时，for-in 循环还实现了完善的修改检测机制，确保遍历过程的安全性：</p>
<ul>
<li>集合对象在 state-&gt;mutationsPtr 中维护一个修改计数器，用于追踪集合的修改状态</li>
<li>每次对集合进行修改操作时，这个计数器的值都会自动更新</li>
<li>for-in 循环在每次迭代时都会检查这个值，确保遍历过程中集合未被修改</li>
<li>一旦检测到集合在遍历过程中被修改，立即抛出异常，防止数据不一致</li>
</ul>
<p>这种设计巧妙地平衡了性能和安全性，使得 for-in 循环既能高效地遍历集合对象，又能保证遍历过程的安全性，这也是它成为 iOS 开发中首选遍历方式的重要原因。</p>
<p>你可能会有这样的疑问：<code>countByEnumeratingWithState:objects:count:</code> 方法内部不也是通过遍历获取元素吗？为什么把外面的遍历操作挪到里面就能提高性能呢？</p>
<p>你可以这样去想，假设现在有 1000 个货物要从上海运到北京，如果是普通的 for 循环，它的逻辑大致是这样的：每次遍历到 1 个对象时，就安排一辆车从北京开到上海，然后把货物从上海运到北京再使用。相当于你要从北京-上海往返 1000 次，才能把所有货物运到北京。</p>
<p>而 for-in 循环的逻辑是这样的：当你需要遍历时，安排一辆车从北京开到上海，与之前不一样的是这次拉 16 个货物（这个 16 就是缓冲区大小）运到北京。当你需要使用第 2～16 个货物时，直接从车上拿就行，不需要再安排车从北京开到上海。通过对比可以发现，前者需要往返 1000 次，而这种方案只需要往返 <code>1000 / 16 ≈ 63</code> 次。这就是 for-in 循环性能优异的关键。遍历的数量越多，for-in 循环的性能优势就越明显。</p>
<p>下面是我在单线程下对不同遍历方式做的一个性能基准测试（测试机型：iPhone 14，系统版本：iOS 18.0）：</p>
<p><img src="performance_test.jpg" alt="性能对比图表"></p>
<p>可以看到 for-in 循环的性能是最好的，而 while 循环的性能是最差的，两者差了 3 倍左右。</p>
<p>测试代码我放在这里，感兴趣的可以自己运行看看：<a target="_blank" rel="noopener" href="https://github.com/internetWei/iOS_traversal_test">iOS 不同遍历方式性能测试</a></p>
<h2 id="实战应用"><a href="#实战应用" class="headerlink" title="实战应用"></a>实战应用</h2><p>通过前面的分析，我们已经深入理解了 for-in 循环的底层实现机制。现在，让我们动手实现一个支持 for-in 循环的自定义类，在实践中加深对 NSFastEnumeration 协议的理解。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WXLFastEnumeration</span> : <span class="title">NSObject</span>&lt;<span class="title">NSFastEnumeration</span>&gt;</span></span><br><span class="line">- (<span class="type">void</span>)addObject:(<span class="type">id</span>)obj;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">WXLFastEnumeration</span> </span>&#123;</span><br><span class="line">    <span class="type">id</span> _arr[<span class="number">34</span>];</span><br><span class="line">    <span class="type">int</span> _idx;</span><br><span class="line">    <span class="built_in">NSInteger</span> _changeCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)addObject:(<span class="type">id</span>)obj &#123;</span><br><span class="line">    _arr[_idx++] = obj;</span><br><span class="line">    changeCount += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)countByEnumeratingWithState:(<span class="built_in">NSFastEnumerationState</span> *)state</span><br><span class="line">                                  objects:(__<span class="keyword">unsafe_unretained</span> <span class="type">id</span> [])buffer</span><br><span class="line">                                    count:(<span class="built_in">NSUInteger</span>)len &#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> count = <span class="number">0</span>;</span><br><span class="line">    state-&gt;mutationsPtr = (<span class="type">unsigned</span> <span class="type">long</span> *)&amp;changeCount;</span><br><span class="line">    count = MIN(len, _idx - state-&gt;state);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        memcpy(buffer, (<span class="keyword">const</span> <span class="type">void</span> *)&amp;_arr[state-&gt;state], <span class="keyword">sizeof</span>(<span class="type">id</span>) * count);</span><br><span class="line">        state-&gt;state += count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    state-&gt;itemsPtr = buffer;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    WXLFastEnumeration *fast = [[WXLFastEnumeration alloc] init];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">33</span>; i++) &#123;</span><br><span class="line">        [fast addObject:@(i)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSNumber</span> *num <span class="keyword">in</span> fast) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;num: %@&quot;</span>, num);</span><br><span class="line">        <span class="keyword">if</span> ([num integerValue] == <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="comment">// 删除以下注释测试崩溃场景</span></span><br><span class="line">            <span class="comment">// [fast addObject:@(34)];</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我使用了 memcpy 函数替代了 GNUStep 实现中的逐元素复制。通过这个对比，你应该能更直观地理解为什么 for-in 循环在遍历大量数据时比传统的 for 循环性能更好。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文的深入分析，我们可以看到 for-in 循环的实现原理主要包含以下几个方面：</p>
<ol>
<li><p><strong>NSFastEnumeration 协议</strong>：作为 for-in 循环的核心，NSFastEnumeration 协议定义了 <code>countByEnumeratingWithState:objects:count:</code> 方法，使集合对象能够批量返回元素。这种设计避免了频繁的方法调用，为性能优化奠定了基础。</p>
</li>
<li><p><strong>批量处理机制</strong>：for-in 循环采用缓冲区（buffer）批量获取元素，而不是传统的逐个获取。这种批量处理方式显著提升了遍历效率，特别是在处理大规模数据时，性能优势更为明显。</p>
</li>
<li><p><strong>状态管理</strong>：通过 NSFastEnumerationState 结构体，for-in 循环实现了遍历状态的精确管理。它不仅记录当前遍历位置，还通过 mutationsPtr 实现了对集合修改的实时检测，确保了遍历过程的可靠性。</p>
</li>
<li><p><strong>安全性保障</strong>：for-in 循环在每次遍历开始时都会进行集合修改检测，一旦发现集合被修改，立即抛出异常。这种机制有效防止了遍历过程中的数据不一致问题，为开发者提供了可靠的安全保障。</p>
</li>
<li><p><strong>双层循环设计</strong>：for-in 循环采用了两层 do-while 循环的巧妙设计。外层循环负责批量获取数据到缓冲区，内层循环则专注于处理缓冲区中的元素。这种设计既保证了遍历的连续性，又充分利用了批量处理的性能优势。</p>
</li>
</ol>
<p>理解这些实现原理，对于 iOS 开发者来说至关重要。它不仅帮助我们更好地使用 for-in 循环，还能指导我们在实际开发中做出更明智的技术选择。例如，在处理大量数据时，我们可以充分利用 for-in 循环的批量处理优势；而在需要修改集合的场景下，我们则需要特别注意避免在遍历过程中修改集合，以防止异常发生。</p>
<p>总的来说，for-in 循环是 ObjC 中一个设计精妙的语法特性。它通过批量处理、状态管理和安全检测等机制，在保证使用便利性的同时，也兼顾了性能和安全性。深入理解其实现原理，能够帮助我们在 iOS 开发中更好地运用这一特性，写出更高效、更可靠的代码。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">布多</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://budo.top/2025/05/20/iOS/iOS 开发者必备：深入理解 for-in 循环的实现原理/">https://budo.top/2025/05/20/iOS/iOS 开发者必备：深入理解 for-in 循环的实现原理/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://budo.top">布多的博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">底层原理</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2025/05/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%9A%84%E7%A7%98%E5%AF%86%EF%BC%9AUnicode%20%E5%92%8C%20UTF%20%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"><i class="fa fa-chevron-left">  </i><span>字符编码的秘密：Unicode 和 UTF 到底是什么？</span></a></div><div class="next-post pull-right"><a href="/2025/05/18/iOS/iOS%20%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E9%82%A3%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%9F%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82%E6%8E%A2%E7%A7%98/"><span>iOS 如何找到那个方法？消息机制底层探秘</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="lv-container" data-id="city" data-uid="MTAyMC81MzU5Ny8zMDA3MA=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div><footer class="footer-bg" style="background-image: url(/images/backgroundImage.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2025 By 布多</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>