<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="AutoreleasePool：iOS 内存管理乐章中的隐秘旋律"><meta name="keywords" content="内存管理"><meta name="author" content="布多"><meta name="copyright" content="布多"><title>AutoreleasePool：iOS 内存管理乐章中的隐秘旋律 | 布多的博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?f0d94d3f99211c3546490e469f6ecbd8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '6.3.0'
} </script><link rel="alternate" href="/atom.xml" title="布多的博客" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%AD%E5%BC%80-AutoreleasePool-%E7%9A%84%E9%9D%A2%E7%BA%B1"><span class="toc-number">1.</span> <span class="toc-text">揭开 AutoreleasePool 的面纱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E5%BA%95%E5%B1%82%EF%BC%9AAutoreleasePool-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">深入底层：AutoreleasePool 的实现机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#autoreleasing-%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.1.</span> <span class="toc-text">__autoreleasing 修饰符的内部实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AutoreleasePoolPage%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E7%9F%B3"><span class="toc-number">2.2.</span> <span class="toc-text">AutoreleasePoolPage：内存管理的基石</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#autoreleasepool-%E7%9A%84%E4%BC%98%E9%9B%85%E4%B9%8B%E9%81%93"><span class="toc-number">2.3.</span> <span class="toc-text">@autoreleasepool 的优雅之道</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E-AutoreleasePool%EF%BC%9A%E7%BA%A0%E7%BC%A0%E7%9A%84%E5%8F%8C%E8%9E%BA%E6%97%8B"><span class="toc-number">3.</span> <span class="toc-text">线程与 AutoreleasePool：纠缠的双螺旋</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9ATLS-%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">性能优化：TLS 机制解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E8%AF%AF%E5%8C%BA%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">5.</span> <span class="toc-text">常见误区与最佳实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">技术总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">7.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.jpg"></div><div class="author-info__name text-center">布多</div><div class="author-info__description text-center">前进！前进！！不择手段地前进！！！</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/internetwei">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">13</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">10</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">4</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友链</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.coderqi.com/">齐小胖之家</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/images/backgroundImage.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">布多的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/about">关于</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">AutoreleasePool：iOS 内存管理乐章中的隐秘旋律</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2025-03-30</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/">iOS</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">5.9k</span><span class="post-meta__separator">|</span><span>阅读时长: 20 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>由 布多(budo) 发布于 2025-03-30</p>
</blockquote>
<h2 id="揭开-AutoreleasePool-的面纱"><a href="#揭开-AutoreleasePool-的面纱" class="headerlink" title="揭开 AutoreleasePool 的面纱"></a>揭开 AutoreleasePool 的面纱</h2><p>AutoreleasePool（中文也叫自动释放池）是 iOS 内存管理机制中的一个重要组成部分。它优雅地解决了对象生命周期管理的问题 - 通过延迟对象的释放时机，在合适的时间点统一回收内存资源。</p>
<p>这个精妙的设计背后有着怎样的实现原理呢？让我们一起深入 <a target="_blank" rel="noopener" href="https://github.com/apple-oss-distributions/objc4/">objc4</a> 开源项目的源码，去探索 AutoreleasePool 的底层实现细节。</p>
<blockquote>
<p>📝 本文使用的 Runtime 版本是 <a target="_blank" rel="noopener" href="https://github.com/apple-oss-distributions/objc4/tree/objc4-906">objc4-906</a>。为了方便阅读，我对代码样式和排版略作了修改，并删减了一些不影响主逻辑的冗余代码。</p>
<p>🔧 我在 <a target="_blank" rel="noopener" href="https://github.com/internetWei/ObjCRuntimes">这里</a> 维护了一个可以直接运行调试的 Runtime 项目，欢迎大家下载调试源码。</p>
</blockquote>
<h2 id="深入底层：AutoreleasePool-的实现机制"><a href="#深入底层：AutoreleasePool-的实现机制" class="headerlink" title="深入底层：AutoreleasePool 的实现机制"></a>深入底层：AutoreleasePool 的实现机制</h2><p>在 ARC 环境下，我们作为开发者能够接触到 AutoreleasePool 的场景主要有两种：</p>
<ol>
<li><p>使用 <code>__autoreleasing</code> 修饰符</p>
<ul>
<li>将对象注册到自动释放池中</li>
<li>实现对象的延迟释放机制</li>
</ul>
</li>
<li><p>使用 <code>@autoreleasepool &#123;&#125;</code> 语法块</p>
<ul>
<li>精确控制内存的释放时机</li>
<li>有效控制内存峰值</li>
</ul>
</li>
</ol>
<p>让我们一起深入源码和汇编层面，揭开这两种使用场景背后的技术实现细节。</p>
<h3 id="autoreleasing-修饰符的内部实现"><a href="#autoreleasing-修饰符的内部实现" class="headerlink" title="__autoreleasing 修饰符的内部实现"></a>__autoreleasing 修饰符的内部实现</h3><p><img src="objc_autorelease%E5%85%A5%E5%8F%A3.png"></p>
<p>从断点的汇编代码中我们可以发现，当我们使用 __autoreleasing 修饰一个对象时，系统会自动将其转换为对 objc_autorelease 函数的调用。这个操作等同于在 MRC 环境下手动调用对象的 autorelease 方法，它们在底层实现上是完全一致的。</p>
<p>让我们深入 Runtime 源码，一探 objc_autorelease 的内部实现。以下是经过整理的核心代码（如果觉得代码太长可以先跳过，后面会有详细解释）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">id <span class="title">objc_autorelease</span><span class="params">(id obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;<span class="built_in">autorelease</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">id <span class="title">objc_object::autorelease</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     检查该对象是否有自定义的引用计数(RR = Retain/Release)实现，</span></span><br><span class="line"><span class="comment">     ARC 肯定没有，MRC 一般也不会自定义这些方法实现。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(!<span class="built_in">ISA</span>()-&gt;<span class="built_in">hasCustomRR</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rootAutorelease</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">objc_msgSend</span>(<span class="keyword">this</span>, @<span class="built_in">selector</span>(autorelease));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">id <span class="title">objc_object::rootAutorelease</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果对象正在释放，不要加入到 AutoreleasePool 中。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isa</span>().<span class="built_in">isDeallocating</span>()) <span class="keyword">return</span> (id)<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      如果对象有使用返回值优化的话，不要加入到 AutoreleasePool 中。</span></span><br><span class="line"><span class="comment">      后面的章节《性能优化：TLS 机制解析》会对该机制进行说明。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">prepareOptimizedReturn</span>((id)<span class="keyword">this</span>, <span class="literal">true</span>, ReturnAtPlus1)) <span class="keyword">return</span> (id)<span class="keyword">this</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果是类对象，不要加入到 AutoreleasePool 中。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(<span class="built_in">isClass</span>())) <span class="keyword">return</span> (id)<span class="keyword">this</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rootAutorelease2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">id <span class="title">objc_object::rootAutorelease2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::<span class="built_in">autorelease</span>((id)<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：从这里开始，后面都是 AutoreleasePoolPage 的内部函数。</span></span><br><span class="line"><span class="function"><span class="type">static</span> id <span class="title">autorelease</span><span class="params">(id obj)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">autoreleaseFast</span>(obj);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">id *<span class="title">autoreleaseFast</span><span class="params">(id obj)</span> </span>&#123;</span><br><span class="line">    AutoreleasePoolPage *page = <span class="built_in">hotPage</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (page &amp;&amp; !page-&gt;<span class="built_in">full</span>()) &#123;</span><br><span class="line">        <span class="comment">// 当前页未满，直接添加</span></span><br><span class="line">        <span class="keyword">return</span> page-&gt;<span class="built_in">add</span>(obj);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page) &#123;</span><br><span class="line">        <span class="comment">// 当前页已满，创建新页添加</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">autoreleaseFullPage</span>(obj, page);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前线程中还没有 Page，创建一个并添加对象。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">autoreleaseNoPage</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">id *<span class="title">add</span><span class="params">(id obj)</span> </span>&#123;</span><br><span class="line">    id *ret;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    下面的这段代码的逻辑大致是：如果启用了对象合并优化方案，</span></span><br><span class="line"><span class="comment">    则将重复调用 autorelease 的对象进行合并，</span></span><br><span class="line"><span class="comment">    这么做的目的是为了减少同一个对象被多次重复的添加到自动释放池。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    一般这种场景会出现在循环中，例如以下代码，</span></span><br><span class="line"><span class="comment">    如果未优化的话就会在 Page 中存放 10 个 Person 对象；</span></span><br><span class="line"><span class="comment">    优化后只会存放 1 个 Person 对象。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; 10; i++) &#123;</span></span><br><span class="line"><span class="comment">        __autoreleasing Person *per = [[Person alloc] init];</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (!DisableAutoreleaseCoalescing || </span><br><span class="line">        !DisableAutoreleaseCoalescingLRU) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!DisableAutoreleaseCoalescingLRU) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">empty</span>() &amp;&amp; (obj != POOL_BOUNDARY)) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                获取 Page 最后的存储对象，检查与当前对象是否相同，</span></span><br><span class="line"><span class="comment">                如果相同则进行合并。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                AutoreleasePoolEntry *topEntry = (AutoreleasePoolEntry *)next - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 向前最多查找 4 个对象</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">uintptr_t</span> offset = <span class="number">0</span>; offset &lt; <span class="number">4</span>; offset++) &#123;</span><br><span class="line">                    AutoreleasePoolEntry *offsetEntry = topEntry - offset;</span><br><span class="line">                    <span class="comment">// 检查是否越界或遇到池边界（POOL_BOUNDARY）</span></span><br><span class="line">                    <span class="keyword">if</span> (offsetEntry &lt;= (AutoreleasePoolEntry*)<span class="built_in">begin</span>() || </span><br><span class="line">                        *(id *)offsetEntry == POOL_BOUNDARY) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 找到相同的对象且计数未达上限</span></span><br><span class="line">                    <span class="keyword">if</span> (offsetEntry-&gt;<span class="built_in">getPointer</span>() == (<span class="type">uintptr_t</span>)obj &amp;&amp; </span><br><span class="line">                        offsetEntry-&gt;<span class="built_in">getCount</span>() &lt; AutoreleasePoolEntry::maxCount) &#123;</span><br><span class="line">                        <span class="comment">// 通过内存移动，将匹配的对象移动到池顶。</span></span><br><span class="line">                        <span class="keyword">if</span> (offset &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            AutoreleasePoolEntry found = *offsetEntry;</span><br><span class="line">                            <span class="built_in">memmove</span>(offsetEntry, offsetEntry + <span class="number">1</span>, offset * <span class="built_in">sizeof</span>(*offsetEntry));</span><br><span class="line">                            *topEntry = found;</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 增加这个对象的计数。</span></span><br><span class="line">                        topEntry-&gt;<span class="built_in">incrementCount</span>();</span><br><span class="line">                        ret = (id *)topEntry;</span><br><span class="line">                        <span class="keyword">goto</span> done;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">empty</span>() &amp;&amp; (obj != POOL_BOUNDARY)) &#123;</span><br><span class="line">                <span class="comment">// 仅检查池顶前一个对象和当前对象是否一致。</span></span><br><span class="line">                AutoreleasePoolEntry *prevEntry = (AutoreleasePoolEntry *)next - <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 直接合并到前一个对象。</span></span><br><span class="line">                <span class="keyword">if</span> (prevEntry-&gt;<span class="built_in">getPointer</span>() == (<span class="type">uintptr_t</span>)obj &amp;&amp; </span><br><span class="line">                    prevEntry-&gt;<span class="built_in">getCount</span>() &lt; AutoreleasePoolEntry::maxCount) &#123;</span><br><span class="line">                    prevEntry-&gt;<span class="built_in">incrementCount</span>();</span><br><span class="line">                    ret = (id *)prevEntry;</span><br><span class="line">                    <span class="keyword">goto</span> done;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = next;</span><br><span class="line">    *next++ = obj;</span><br><span class="line"></span><br><span class="line"> done:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">id *<span class="title">autoreleaseFullPage</span><span class="params">(id obj, AutoreleasePoolPage *page)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取下一个 Page 对象，</span></span><br><span class="line"><span class="comment">    如果它不存在或者存满了就创建一个新的。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (page-&gt;child) page = page-&gt;child;</span><br><span class="line">        <span class="keyword">else</span> page = <span class="keyword">new</span> <span class="built_in">AutoreleasePoolPage</span>(page);</span><br><span class="line">    &#125; <span class="keyword">while</span> (page-&gt;<span class="built_in">full</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将当前 Page 设置为 hot。</span></span><br><span class="line">    <span class="built_in">setHotPage</span>(page);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将对象添加到 Page 中。</span></span><br><span class="line">    <span class="keyword">return</span> page-&gt;<span class="built_in">add</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">id *<span class="title">autoreleaseNoPage</span><span class="params">(id obj)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> pushExtraBoundary = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     首次创建自动释放池时，会用一个占位符表示空池。</span></span><br><span class="line"><span class="comment">     此时若添加对象，需先补一个边界。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">haveEmptyPoolPlaceholder</span>()) &#123;</span><br><span class="line">        pushExtraBoundary = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接使用空占位符，避免创建真实的池结构。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (obj == POOL_BOUNDARY) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">setEmptyPoolPlaceholder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 Page，并设置为 hot。</span></span><br><span class="line">    AutoreleasePoolPage *page = <span class="keyword">new</span> <span class="built_in">AutoreleasePoolPage</span>(nil);</span><br><span class="line">    <span class="built_in">setHotPage</span>(page);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pushExtraBoundary) &#123;</span><br><span class="line">        page-&gt;<span class="built_in">add</span>(POOL_BOUNDARY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> page-&gt;<span class="built_in">add</span>(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的函数调用流程大致如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">objc_autorelease</span><br><span class="line">└── autorelease</span><br><span class="line">    └── rootAutorelease</span><br><span class="line">        └── rootAutorelease2</span><br><span class="line">            └── AutoreleasePoolPage::autorelease</span><br><span class="line">                └── AutoreleasePoolPage::autoreleaseFast</span><br></pre></td></tr></table></figure>

<p>从上面的代码分析中我们可以看到，当一个对象被标记为 autoreleasing 时，系统会通过一系列函数调用最终将其加入到 AutoreleasePoolPage 中。这个过程主要由 autoreleaseFast 函数完成，它负责管理对象的具体存储工作。在 autoreleaseFast 函数内部，系统会获取当前线程的 hotPage（所谓的 hotPage，其实就是双向链表的尾节点），然后根据 page 状态决定执行逻辑：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>状态</th>
<th>执行逻辑</th>
</tr>
</thead>
<tbody><tr>
<td>逻辑一</td>
<td>page 存在且未满</td>
<td>直接调用 add 函数将对象添加到 Page 中</td>
</tr>
<tr>
<td>逻辑二</td>
<td>page 存在但已满</td>
<td>调用 autoreleaseFullPage 创建新 Page，然后添加对象</td>
</tr>
<tr>
<td>逻辑三</td>
<td>page 不存在</td>
<td>直接创建新 Page，然后添加对象</td>
</tr>
</tbody></table>
<p>这里有一个有趣的优化细节：系统并不是直接存放对象的地址，而是将其包装成一个 AutoreleasePoolEntry 对象。这样设计的原因在于系统采用了 “对象合并优化” 方案 - 当多个相同对象被重复加入 Page 时，系统只会保留第一个对象，并通过 count 值记录该对象被重复加入的次数。这种优化可以有效减少内存占用（具体细节请阅读上面的 add 函数）。</p>
<p>至此，autoreleasing 对象就完成了它进入 AutoreleasePool 的全过程。</p>
<p>在上述实现中，有一个核心类型值得我们特别关注 - AutoreleasePoolPage。作为存储数据的底层结构，它在整个自动释放池机制中扮演着至关重要的角色。接下来，让我们深入分析这个关键组件。</p>
<h3 id="AutoreleasePoolPage：内存管理的基石"><a href="#AutoreleasePoolPage：内存管理的基石" class="headerlink" title="AutoreleasePoolPage：内存管理的基石"></a>AutoreleasePoolPage：内存管理的基石</h3><p>让我们一起来看看 AutoreleasePoolPage 这个核心类的内部结构。为了便于理解，我对源码进行了精简和注释，保留了最关键的部分：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AutoreleasePoolPage</span> &#123;</span><br><span class="line">    <span class="type">magic_t</span> magic;                <span class="comment">// 魔数，用于校验 Page 的有效性和完整性</span></span><br><span class="line">    __unsafe_unretained id *next; <span class="comment">// 指向当前 Page 中下一个可用的存储位置</span></span><br><span class="line">    <span class="type">objc_thread_t</span> thread;         <span class="comment">// 当前 Page 所属的线程，每个线程都有自己的 AutoreleasePool</span></span><br><span class="line">    AutoreleasePoolPage *parent;  <span class="comment">// 指向双向链表中的前一个 Page</span></span><br><span class="line">    AutoreleasePoolPage *child;   <span class="comment">// 指向双向链表中的后一个 Page</span></span><br><span class="line">    <span class="type">uint32_t</span> depth;               <span class="comment">// 当前 Page 在双向链表中的深度，从 0 开始</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     用于性能调试和监控。记录 AutoreleasePool 历史存储对象数量的最大值。</span></span><br><span class="line"><span class="comment">     目前的逻辑是当对象数量超过阈值(256)时，会触发日志记录，包含：</span></span><br><span class="line"><span class="comment">     - 当前线程信息</span></span><br><span class="line"><span class="comment">     - 对象存储数量</span></span><br><span class="line"><span class="comment">     - 完整调用栈</span></span><br><span class="line"><span class="comment">     这些信息有助于排查内存使用异常的情况。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint32_t</span> hiwat;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Page 大小固定为 4KB(4096字节)，与系统内存页大小对齐</span></span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> <span class="type">const</span> SIZE = <span class="number">1</span> &lt;&lt; <span class="number">12</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重写 new 操作符，确保分配的内存按 SIZE 对齐</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="type">void</span> *result = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">posix_memalign</span>(&amp;result, SIZE, SIZE);</span><br><span class="line">        <span class="built_in">ASSERT</span>(r == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了更直观地理解 AutoreleasePoolPage 的内存结构，我绘制了一张简图：</p>
<p><img src="AutoreleasePoolPage%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p>
<p>结合 AutoreleasePoolPage 的内部结构和前面分析的函数执行流程，我们可以更清晰地理解 AutoreleasePool 的底层实现。它本质上是一个普通的双向链表结构，其中每个节点都是一个 AutoreleasePoolPage 对象。这些对象通过 parent 和 child 指针相互连接，形成了一个完整的内存管理链条。每个 Page 不仅承担着节点的角色，还肩负着数据存储的重任，是整个自动释放池机制的核心载体。</p>
<p>在内存管理的层面上，AutoreleasePoolPage 的设计也体现了深思熟虑。通过查看其 new 方法的实现，我们可以看到每个 Page 的大小被设定为 4096 字节。这个看似随意的数字其实暗含玄机 - 它与现代操作系统的内存页大小完美对齐。这种设计带来了多重优势：</p>
<ul>
<li>减少内存碎片，提高内存利用效率；</li>
<li>实现更高效的内存分配；</li>
<li>确保内存访问的连续性，降低系统中断频率；</li>
<li>优化缓存命中率，提升整体性能。</li>
</ul>
<p>这些细节的优化，让 AutoreleasePool 在实现优雅的同时，也保持了极高的运行效率。</p>
<h3 id="autoreleasepool-的优雅之道"><a href="#autoreleasepool-的优雅之道" class="headerlink" title="@autoreleasepool 的优雅之道"></a>@autoreleasepool 的优雅之道</h3><p><code>@autoreleasepool &#123;&#125;</code> 是我们在项目中经常使用的另一个重要特性。这个看似简单的语法块背后，隐藏着编译器的巧妙转换和 Runtime 的精密配合。让我们揭开它的神秘面纱，一探其实现原理。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原代码：</span></span><br><span class="line">@autoreleasepool &#123;    </span><br><span class="line">__autoreleasing Person *per = [Person createPerson]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后：</span></span><br><span class="line">atautoreleasepoolobj = <span class="built_in">objc_autoreleasePoolPush</span>(); <span class="comment">// 对应 @autorelease &#123;</span></span><br><span class="line">__autoreleasing Person *per = [Person createPerson];</span><br><span class="line"><span class="built_in">objc_autoreleasePoolPop</span>(atautoreleasepoolobj); <span class="comment">// 对应 &#125;</span></span><br></pre></td></tr></table></figure>

<p>通过查看下面的汇编代码截图，我们可以清晰地看到编译器确实将 @autoreleasepool 语法块转换成了 objc_autoreleasePoolPush 和 objc_autoreleasePoolPop 的函数调用。这种转换不仅保证了代码的执行效率，还为开发者提供了一种优雅的内存管理方式：</p>
<p><img src="@autorelease%E5%8E%9F%E7%90%86.png"></p>
<p>让我们来看看 objc_autoreleasePoolPush 函数的内部实现。为了便于理解，我将相关代码进行了精简和整理：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * <span class="title">objc_autoreleasePoolPush</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::<span class="built_in">push</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">push</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ReturnAutoreleaseInfo info = <span class="built_in">getReturnAutoreleaseInfo</span>();</span><br><span class="line">    <span class="comment">// 将 TLS 中的对象转移至当前释放池。</span></span><br><span class="line">    <span class="built_in">moveTLSAutoreleaseToPool</span>(info);</span><br><span class="line">    <span class="comment">// 插入一个池边界。</span></span><br><span class="line">    id *dest = <span class="built_in">autoreleaseFast</span>(POOL_BOUNDARY);</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段逻辑非常简洁优雅：它通过调用 autoreleaseFast 函数，在当前的 AutoreleasePool 中插入一个边界标记（POOL_BOUNDARY）。这个边界标记就像是一个书签，标记着当前自动释放池的范围起点。</p>
<p>让我们继续探索 objc_autoreleasePoolPop 的实现细节。下面是经过精简的核心代码，我们将分步骤详细解析其工作原理（如果觉得代码太长可以先跳过，稍后我们会详细解释其工作原理）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">objc_autoreleasePoolPop</span><span class="params">(<span class="type">void</span> *ctxt)</span> </span>&#123;</span><br><span class="line">    AutoreleasePoolPage::<span class="built_in">pop</span>(ctxt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">void</span> *token)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 清理 TLS 中的残留对象，确保其生命周期与当前池同步。</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">releaseReturnAutoreleaseTLS</span>());</span><br><span class="line">    </span><br><span class="line">    AutoreleasePoolPage *page;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// EMPTY_POOL_PLACEHOLDER 表示清空 Pool 中的所有对象。</span></span><br><span class="line">    <span class="keyword">if</span> (token == (<span class="type">void</span>*)EMPTY_POOL_PLACEHOLDER) &#123;</span><br><span class="line">        page = <span class="built_in">hotPage</span>();</span><br><span class="line">        <span class="keyword">if</span> (!page) &#123;</span><br><span class="line">            <span class="comment">// 从未使用的池直接清除占位符</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">setHotPage</span>(nil);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        获取 Pool 的起始页。内部逻辑如下：</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">        AutoreleasePoolPage *coldPage() &#123;</span></span><br><span class="line"><span class="comment">            // 先拿到尾节点。</span></span><br><span class="line"><span class="comment">            AutoreleasePoolPage *result = hotPage();</span></span><br><span class="line"><span class="comment">            if (result) &#123;</span></span><br><span class="line"><span class="comment">                // 不断获取链表中的前一个节点，直到第一个。</span></span><br><span class="line"><span class="comment">                while (result-&gt;parent) &#123;</span></span><br><span class="line"><span class="comment">                    result = result-&gt;parent;</span></span><br><span class="line"><span class="comment">                    result-&gt;fastcheck();</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            return result;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        page = <span class="built_in">coldPage</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 把 stop 设置为第一页的起点。</span></span><br><span class="line">        token = page-&gt;<span class="built_in">begin</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        page = <span class="built_in">pageForPointer</span>(token);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    id *stop = (id *)token;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     这段逻辑的意思是：</span></span><br><span class="line"><span class="comment">     如果 stop 不是池边界(POOL_BOUNDARY)就需要进行检查：</span></span><br><span class="line"><span class="comment">     如果 stop 是这一页的起点，并且这一页已经是第一页了。</span></span><br><span class="line"><span class="comment">     说明需要清理链表中的所有数据，这是正常情况。</span></span><br><span class="line"><span class="comment">     反之，这是不正常的，调用 badPop。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (*stop != POOL_BOUNDARY) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stop == page-&gt;<span class="built_in">begin</span>()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">badPop</span>(token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">popPage</span>(token, page, stop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">popPage</span><span class="params">(<span class="type">void</span> *token, AutoreleasePoolPage *page, id *stop)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     从尾部一直往前释放对象，直到遇到 stop。</span></span><br><span class="line"><span class="comment">     这一步执行完后，只是释放了 Page 内的数据，Page 对象并未销毁。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    page-&gt;<span class="built_in">releaseUntil</span>(stop);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     如果这一页的数据被删完了，就把这个 Page 对象释放掉，</span></span><br><span class="line"><span class="comment">     并把它的父 Page 设为 hotPage。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (page-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        AutoreleasePoolPage *parent = page-&gt;parent;</span><br><span class="line">        page-&gt;<span class="built_in">kill</span>();</span><br><span class="line">        <span class="built_in">setHotPage</span>(parent);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         如果当前 Page 上的数据小于 Page 总容量的一半，</span></span><br><span class="line"><span class="comment">         则把下一个 Page 释放掉（因为这个 Page 还能存很多数据，</span></span><br><span class="line"><span class="comment">         可能很久都用不到下一页）；</span></span><br><span class="line"><span class="comment">         反之，把下下一个 Page 释放掉（这一页快存满了，</span></span><br><span class="line"><span class="comment">         可能很快就要用到下一页了）。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (page-&gt;<span class="built_in">lessThanHalfFull</span>()) &#123;</span><br><span class="line">            page-&gt;child-&gt;<span class="built_in">kill</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child-&gt;child) &#123;</span><br><span class="line">            page-&gt;child-&gt;child-&gt;<span class="built_in">kill</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">releaseUntil</span><span class="params">(id *stop)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 从 next 开始，一直往前释放对象，直到遇到 stop。</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">this</span>-&gt;next != stop) &#123;</span><br><span class="line">            AutoreleasePoolPage *page = <span class="built_in">hotPage</span>();</span><br><span class="line">            <span class="comment">// 如果当前 Page 为空，则往前找父 Page。</span></span><br><span class="line">            <span class="keyword">while</span> (page-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                page = page-&gt;parent;</span><br><span class="line">                <span class="built_in">setHotPage</span>(page);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获取当前 Page 的最后一个对象。</span></span><br><span class="line">            AutoreleasePoolEntry* entry = (AutoreleasePoolEntry*) --page-&gt;next;</span><br><span class="line">            <span class="comment">// 获取对象。</span></span><br><span class="line">            id obj = (id)entry-&gt;<span class="built_in">getPointer</span>();</span><br><span class="line">            <span class="comment">// 获取对象的引用计数。</span></span><br><span class="line">            <span class="type">int</span> count = (<span class="type">int</span>)entry-&gt;<span class="built_in">getCount</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">            将原先存放数据的那块空间赋值为一个魔数 SCRIBBLE，</span></span><br><span class="line"><span class="comment">            这么做的目的是方便后期检查 Page 是否被破坏。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="built_in">memset</span>((<span class="type">void</span>*)page-&gt;next, SCRIBBLE, <span class="built_in">sizeof</span>(*page-&gt;next));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 obj 不是边界标记，则执行释放操作。</span></span><br><span class="line">            <span class="keyword">if</span> (obj != POOL_BOUNDARY) &#123;</span><br><span class="line">                <span class="comment">// 执行指定次数的释放操作。</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count + <span class="number">1</span>; i++) &#123;</span><br><span class="line">                    <span class="built_in">objc_release</span>(obj);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 清空 TLS 中的临时对象，确保它们和 Page 的生命周期是相同的。</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">releaseReturnAutoreleaseTLS</span>());</span><br><span class="line">    <span class="built_in">setHotPage</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放的逻辑稍微复杂一些，我们来梳理一下。当我们调用 pop 函数时，系统会按照以下流程进行对象的释放操作：</p>
<ol>
<li>首先，objc_autoreleasePoolPop 函数会被调用，它是整个释放流程的入口。</li>
<li>然后，pop 函数会被调用，它负责处理具体的释放逻辑。</li>
<li>接着，popPage 函数会被调用，它负责管理 Page 的释放。</li>
<li>最后，releaseUntil 函数会被调用，它负责执行实际的对象释放操作。</li>
</ol>
<p>完整的函数调用流程如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">objc_autoreleasePoolPop</span><br><span class="line">└── pop</span><br><span class="line">    └── popPage</span><br><span class="line">        └── releaseUntil</span><br></pre></td></tr></table></figure>

<p>在这些函数中，releaseUntil 和 popPage 扮演着尤为关键的角色：</p>
<p>releaseUntil 函数负责对象的具体释放工作。它会按照先进后出（LIFO）的顺序，将 Page 中的对象逐一释放。在这个过程中，它不仅要处理普通对象的释放，还要考虑对象合并优化带来的特殊情况，确保每个对象都能得到正确的释放次数。同时，它还会通过魔数（SCRIBBLE）标记已释放的内存空间，这么做的目的是方便后期进行内存完整性检查。</p>
<p>popPage 函数则专注于 Page 对象本身的管理和释放。它维护着 AutoreleasePool 的整体结构，确保当 Page 中所有的对象都被释放完后，Page 本身能够被正确地释放，从而保持整个池结构的高效运转。</p>
<p>通过上述分析，我们已经深入理解了 AutoreleasePool 的核心工作原理：系统通过精心设计的入池(Push)和出池(Pop)机制，在保证内存管理安全性的同时，也实现了极高的运行效率。这种双向链表结构不仅让对象的生命周期管理变得优雅，还通过诸如对象合并等优化手段提升了运行性能。</p>
<p>在掌握了这些底层实现细节后，我们将进一步探讨 AutoreleasePool 在多线程环境下的行为特征，以及在实际开发中的最佳实践方案。这些知识将帮助我们更好地驾驭这个强大的内存管理工具。</p>
<h2 id="线程与-AutoreleasePool：纠缠的双螺旋"><a href="#线程与-AutoreleasePool：纠缠的双螺旋" class="headerlink" title="线程与 AutoreleasePool：纠缠的双螺旋"></a>线程与 AutoreleasePool：纠缠的双螺旋</h2><p>AutoreleasePool 和线程是一一对应的关系，每个线程都拥有自己独立的 AutoreleasePool。从实现上看，它是一个由 AutoreleasePoolPage 对象组成的双向链表结构，线程通过 TLS (Thread Local Storage) 机制持有这个链表的尾节点（也就是 hotPage）。</p>
<p>关于 AutoreleasePool 的释放时机，这是一个经常被开发者讨论的话题。特别是被 __autoreleasing 修饰的对象，它们具体在什么时候被释放？</p>
<p>经过深入研究，我发现不同场景下对象的释放时机是不同的。让我们逐一分析：</p>
<p>场景一：主线程中的 autorelease 对象</p>
<ul>
<li>由 RunLoop 来管理释放时机</li>
<li>通常在当前任务执行完成后释放</li>
<li>具体时机可以通过下图来理解：</li>
</ul>
<p><img src="mainthread.png"></p>
<p>场景二：GCD 创建的子线程中的对象</p>
<ul>
<li>由于 GCD 采用线程池机制，线程可能会被复用</li>
<li>释放时机是在线程任务完成、即将被放回线程池时</li>
<li>通过下图可以看到具体流程：</li>
</ul>
<p><img src="gcd.png"></p>
<p>值得注意的是，_dispatch_worker_thread2 函数在处理线程任务时遵循这样的逻辑：从队列中获取并执行任务，当队列为空时让线程进入休眠状态。在进入休眠之前，会调用 _dispatch_last_resort_autorelease_pool_pop 来释放自动释放池中的对象。</p>
<p>场景三：通过 NSThread 等方式创建的非复用线程（无 RunLoop）</p>
<ul>
<li>对象会在线程销毁时被释放</li>
<li>释放过程如图所示：</li>
</ul>
<p><img src="pthread.png"></p>
<p>场景四：通过 NSThread 等方式创建的非复用线程（有 RunLoop）</p>
<ul>
<li>释放机制类似于主线程</li>
<li>在当前任务执行完成后释放</li>
<li>具体流程如下：</li>
</ul>
<p><img src="pthread_runloop.png"></p>
<p>场景四中使用的 NSThread 是我开发的一个开源库 <a target="_blank" rel="noopener" href="https://github.com/internetWei/WXLThread">WXLThread</a>。这个库实现了一个优雅的常驻线程机制，并提供了简洁而强大的任务调度接口，让线程管理变得更加便捷和高效。</p>
<p>需要特别说明的是，这些释放时机并非固定不变。因为 autoreleasing 对象的释放本质上是由 pop 函数的调用时机决定的。随着系统版本的更新和优化，这些调用时序可能会发生变化。比如在早期版本中，系统是通过在 RunLoop 中注册 Observer 来处理释放操作的，释放时机是在线程即将进入休眠状态之前。</p>
<p>另外，如果对象被 <code>@autoreleasepool &#123;&#125;</code> 语法块包裹，那么它的释放时机就很明确了 - 就是在退出这个语法块作用域的时候。这提供了一种更精确的内存管理方式。</p>
<h2 id="性能优化：TLS-机制解析"><a href="#性能优化：TLS-机制解析" class="headerlink" title="性能优化：TLS 机制解析"></a>性能优化：TLS 机制解析</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (Person *)createPerson &#123;</span><br><span class="line">    Person *per = [[Person alloc] init];</span><br><span class="line">    <span class="keyword">return</span> per;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    Person *per = [self createPerson];</span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;%@&quot;</span>, per);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，如果没有任何优化，系统会在 return 之前对 per 调用 release 方法，这会导致对象过早释放。为了避免这种情况，编译器会在方法返回前将对象加入到自动释放池中，确保调用方能够正常使用这个对象。但这种方案存在一个问题：即使对象马上就会被调用方使用，也要经过「加入自动释放池 -&gt; 从自动释放池取出」这个过程，这无疑会带来一些性能开销。</p>
<p>为了解决这个问题，系统引入了基于 TLS (Thread Local Storage) 的返回值优化机制。具体来说：</p>
<ol>
<li>在返回对象的方法中，编译器会插入 <code>objc_autoreleaseReturnValue</code> 调用；</li>
<li>在接收返回值的地方，编译器会插入 <code>objc_retainAutoreleasedReturnValue</code> 调用；</li>
<li>这两个函数会配合工作：如果检测到它们的调用配对，就会把对象暂存在线程的 TLS 中，直接传递给调用方，完全跳过自动释放池的过程。</li>
</ol>
<p>这种优化极大地提升了返回对象的性能，尤其是在频繁方法调用的场景下。</p>
<p>通过调试查看汇编代码，我们可以清晰地看到这些优化函数的调用过程，当编译器检测到返回值优化的场景时，会跳过传统的自动释放池流程，直接通过 TLS 机制传递对象提升了性能。让我们通过下面的图来直观地体会这个优化过程：</p>
<table>
<thead>
<tr>
<th align="center"><img src="%E8%B0%83%E7%94%A8%E6%96%B9.png"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">方法调用方</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center"><img src="%E8%BF%94%E5%9B%9E%E6%96%B9.png"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">方法返回方</td>
</tr>
</tbody></table>
<h2 id="常见误区与最佳实践"><a href="#常见误区与最佳实践" class="headerlink" title="常见误区与最佳实践"></a>常见误区与最佳实践</h2><p>在实际开发中，我们经常会遇到一些对 AutoreleasePool 使用的误区。其中最常见的就是在循环中过度使用 @autoreleasepool，例如：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Person *per = [[Person alloc] init];</span><br><span class="line">        <span class="comment">// 对 per 进行的操作……</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中的 per 对象是 __strong 类型，它会在每次循环结束时立即释放，无需等待自动释放池的清理。这种情况下添加 @autoreleasepool 并不会带来任何性能优势，反而会因为频繁创建和销毁自动释放池而增加开销。</p>
<p>因此，@autoreleasepool 的使用需要遵循以下原则：</p>
<ol>
<li><p>循环中创建了大量 autoreleasing 对象时才使用。这种情况下才能有效降低内存峰值，避免内存持续增长。</p>
</li>
<li><p>调用未知方法时需要谨慎评估。因为方法内部可能会创建 autoreleasing 对象，此时需要使用 @autoreleasepool 包裹，否则也会导致内存峰值过高。</p>
</li>
</ol>
<p>注意：错误的使用 @autoreleasepool 不仅不会带来性能优势，反而会因为频繁创建和销毁自动释放池而产生额外开销。所以在使用前，建议先分析代码中的对象创建情况，再决定是否需要手动管理自动释放池。</p>
<h2 id="技术总结"><a href="#技术总结" class="headerlink" title="技术总结"></a>技术总结</h2><p>通过对 AutoreleasePool 底层实现的深入分析，我们可以总结出以下几个关键点：</p>
<ol>
<li><p>底层数据结构</p>
<ul>
<li>AutoreleasePool 本质是由 AutoreleasePoolPage 对象组成的双向链表；</li>
<li>每个 Page 目前的大小为 4KB，按系统内存页对齐以优化性能；</li>
<li>每个线程的 TLS 中存储着链表的尾节点（hotPage）；</li>
<li>Page 中除了存储对象指针外，还包含 magic、next、thread 等重要信息。</li>
</ul>
</li>
<li><p>对象管理机制</p>
<ul>
<li><p>添加对象时，系统首先获取 hotPage，根据其状态执行不同逻辑：</p>
<ul>
<li>Page 存在且未满：直接添加对象</li>
<li>Page 存在但已满：创建新 Page 后添加</li>
<li>Page 不存在：创建首个 Page 后添加</li>
</ul>
</li>
<li><p>清理时，系统会从链表末尾往前遍历，逐个释放对象直到遇到指定的边界标记（POOL_BOUNDARY）。</p>
</li>
</ul>
</li>
<li><p>性能优化方案</p>
<ul>
<li>对象合并优化：相同对象重复入池时，通过 count 计数避免重复存储；</li>
<li>TLS 返回值优化：方法返回对象时，通过 TLS 机制避免自动释放池的中转；</li>
<li>内存对齐：Page 大小与系统页对齐，提高内存访问效率；</li>
<li>双向链表：支持快速的正向和反向遍历，适应不同的使用场景。</li>
</ul>
</li>
</ol>
<p>这些精妙的设计不仅保证了 AutoreleasePool 的正确性，还在性能和内存使用效率上都做到了极致的优化。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://suhou.github.io/2018/01/21/%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E7%9C%8B%E6%BA%90%E7%A0%81----%E5%AD%90%E7%BA%BF%E7%A8%8BAutoRelease%E5%AF%B9%E8%B1%A1%E4%BD%95%E6%97%B6%E9%87%8A%E6%94%BE/">子线程AutoRelease对象何时释放 | su</a></li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">布多</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://budo.top/2025/03/30/iOS/AutoreleasePool：iOS 内存管理乐章中的隐秘旋律/">https://budo.top/2025/03/30/iOS/AutoreleasePool：iOS 内存管理乐章中的隐秘旋律/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://budo.top">布多的博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2025/04/02/iOS/Tagged%20Pointer%EF%BC%9A%E8%8B%B9%E6%9E%9C%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E8%89%BA%E6%9C%AF/"><i class="fa fa-chevron-left">  </i><span>Tagged Pointer：苹果工程师的内存优化艺术</span></a></div><div class="next-post pull-right"><a href="/2024/12/11/iOS/2024%20%E5%86%8D%E6%8E%A2ObjC-Category%EF%BC%9A%E5%8A%A8%E6%80%81%E7%89%B9%E6%80%A7%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%9E%81%E8%87%B4%E4%B9%8B%E7%BE%8E/"><span>2024 再探ObjC-Category：动态特性与运行时实现的极致之美</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="lv-container" data-id="city" data-uid="MTAyMC81MzU5Ny8zMDA3MA=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div><footer class="footer-bg" style="background-image: url(/images/backgroundImage.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2025 By 布多</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>