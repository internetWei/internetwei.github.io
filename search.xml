<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>iOS 中的 +load 和 +initialize 在继承与分类中的不同表现​</title>
      <link href="/2025/05/14/iOS/iOS%20%E4%B8%AD%E7%9A%84%20+load%20%E5%92%8C%20+initialize%20%E5%9C%A8%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%88%86%E7%B1%BB%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%90%8C%E8%A1%A8%E7%8E%B0%E2%80%8B/"/>
      <url>/2025/05/14/iOS/iOS%20%E4%B8%AD%E7%9A%84%20+load%20%E5%92%8C%20+initialize%20%E5%9C%A8%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%88%86%E7%B1%BB%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%90%8C%E8%A1%A8%E7%8E%B0%E2%80%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由 布多(budo) 发布于 2025-05-14</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 iOS 开发中，+load 和 +initialize 是两个特殊的类方法，它们都是由系统自动调用，且正常情况下每个类只会执行一次。虽然这两个方法看起来相似，但它们在调用时机、调用顺序以及继承和分类中的表现都有显著差异。+load 方法在程序启动时、类被加载到内存时就会调用，而 +initialize 方法则是在类第一次接收到消息时才会调用。本文将深入 <a href="https://github.com/apple-oss-distributions/objc4/tree/objc4-906">Runtime</a> 源码，详细分析这两个方法的底层实现机制，并重点探讨它们在继承关系和分类实现中的不同表现，帮助开发者更好地理解和使用它们。</p><h2 id="load-方法的实现机制"><a href="#load-方法的实现机制" class="headerlink" title="+load 方法的实现机制"></a>+load 方法的实现机制</h2><p>在 <a href="https://github.com/apple-oss-distributions/objc4/tree/objc4-906">Runtime</a> 源码中我们可以找到 +load 方法的具体实现细节，整理后的代码如下所示：</p><blockquote><p>🔧 我在 <a href="https://github.com/internetWei/ObjCRuntimes">这里</a> 维护了一个可以直接运行调试的 Runtime 项目，欢迎大家下载调试源码。</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">load_images</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> _dyld_objc_notify_mapped_info* info)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">mutex_locker_t</span> <span class="title">lock2</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">        <span class="built_in">loadAllCategoriesIfNeeded</span>();</span><br><span class="line">        <span class="comment">// 将类和分类中的 load 方法添加到全局数组中，等待后续调用。</span></span><br><span class="line">        <span class="built_in">prepare_load_methods</span>((<span class="type">const</span> headerType *)info-&gt;mh, info-&gt;sectionLocationMetadata);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用所有的 load 方法。</span></span><br><span class="line">    <span class="built_in">call_load_methods</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的源码分析可以看出，+load 方法的实现过程主要分为两个步骤：</p><ol><li>调用 <code>prepare_load_methods</code> 函数，将类和分类所有的 +load 方法准备好（其实就是将类和分类中的 +load 方法添加到一个全局数组中）。</li><li>调用 <code>call_load_methods</code> 函数，遍历前面准备好的数组，并进行调用。</li></ol><p>接下来，让我们深入分析 <code>prepare_load_methods</code> 函数的具体实现，看看它是如何收集这些 +load 方法的：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">prepare_load_methods</span><span class="params">(<span class="type">const</span> headerType *mhdr, <span class="type">const</span> <span class="type">_dyld_section_location_info_t</span> info)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> count, i;</span><br><span class="line"></span><br><span class="line">    <span class="type">classref_t</span> <span class="type">const</span> *classlist = <span class="built_in">getSectionData</span>&lt;<span class="type">classref_t</span>&gt;(mhdr, </span><br><span class="line">    info, </span><br><span class="line">    _dyld_section_location_data_non_lazy_class_list, </span><br><span class="line">    &amp;count);</span><br><span class="line">    <span class="comment">// 按照编译顺序遍历所有类并添加 load 方法。</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="built_in">schedule_class_load</span>(<span class="built_in">remapClass</span>(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">category_t</span> * <span class="type">const</span> *categorylist = <span class="built_in">getSectionData</span>&lt;<span class="type">category_t</span> *&gt;(mhdr, </span><br><span class="line">    info,</span><br><span class="line">    _dyld_section_location_data_non_lazy_category_list, </span><br><span class="line">    &amp;count);</span><br><span class="line">    <span class="comment">// 按照编译顺序遍历所有分类并添加 load 方法。</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="type">category_t</span> *cat = categorylist[i];</span><br><span class="line">        Class cls = <span class="built_in">remapClass</span>(cat-&gt;cls);</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">realizeClassWithoutSwift</span>(cls, nil);</span><br><span class="line">        <span class="built_in">add_category_to_loadable_list</span>(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备类的 load 方法。</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">schedule_class_load</span><span class="params">(Class cls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 检查该类的 load 方法是否已经添加过，防止重复添加。</span></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;<span class="built_in">data</span>()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     递归调用，确保父类的 load 方法先添加，</span></span><br><span class="line"><span class="comment">     从而保证先调用父类的 load 方法再调用自身的 load 方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">schedule_class_load</span>(cls-&gt;<span class="built_in">getSuperclass</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前类的 load 方法添加到全局数组中。</span></span><br><span class="line">    <span class="built_in">add_class_to_loadable_list</span>(cls);</span><br><span class="line">    cls-&gt;<span class="built_in">setInfo</span>(RW_LOADED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">loadable_class</span> &#123;</span><br><span class="line">    Class cls;</span><br><span class="line">    IMP method;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局数组，用于存储所有需要调用的类的 load 方法。</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">loadable_class</span> *loadable_classes = nil;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将类的 load 方法添加到全局数组中。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_class_to_loadable_list</span><span class="params">(Class cls)</span> </span>&#123;</span><br><span class="line">    IMP method;</span><br><span class="line">    method = cls-&gt;<span class="built_in">getLoadMethod</span>();</span><br><span class="line">    <span class="keyword">if</span> (!method) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一次进来时先初始化全局数组，以确保它能容纳所有的 load 方法。</span></span><br><span class="line">    <span class="keyword">if</span> (loadable_classes_used == loadable_classes_allocated) &#123;</span><br><span class="line">        loadable_classes_allocated = loadable_classes_allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">        loadable_classes = (<span class="keyword">struct</span> loadable_class *)<span class="built_in">realloc</span>(loadable_classes,</span><br><span class="line">        loadable_classes_allocated * <span class="built_in">sizeof</span>(<span class="keyword">struct</span> loadable_class));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    loadable_classes[loadable_classes_used].cls = cls;</span><br><span class="line">    <span class="comment">// 将 load 方法添加到全局数组中。</span></span><br><span class="line">    loadable_classes[loadable_classes_used].method = method;</span><br><span class="line">    loadable_classes_used++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">loadable_category</span> &#123;</span><br><span class="line">    Category cat;</span><br><span class="line">    IMP method;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局数组，用于存储所有需要调用的分类的 load 方法。</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">loadable_category</span> *loadable_categories = nil;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将分类的 load 方法添加到全局数组中。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_category_to_loadable_list</span><span class="params">(Category cat)</span> </span>&#123;</span><br><span class="line">    IMP method;</span><br><span class="line">    method = _category_getLoadMethod(cat);</span><br><span class="line">    <span class="keyword">if</span> (!method) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一次进来时先初始化全局数组，以确保它能容纳所有的 load 方法。</span></span><br><span class="line">    <span class="keyword">if</span> (loadable_categories_used == loadable_categories_allocated) &#123;</span><br><span class="line">        loadable_categories_allocated = loadable_categories_allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">        loadable_categories = (<span class="keyword">struct</span> loadable_category *)<span class="built_in">realloc</span>(loadable_categories,</span><br><span class="line">        loadable_categories_allocated * <span class="built_in">sizeof</span>(<span class="keyword">struct</span> loadable_category));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loadable_categories[loadable_categories_used].cat = cat;</span><br><span class="line">    <span class="comment">// 将分类的 load 方法添加到全局数组中。</span></span><br><span class="line">    loadable_categories[loadable_categories_used].method = method;</span><br><span class="line">    loadable_categories_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过分析源码，我们可以总结出 +load 方法的加载顺序规则：</p><ol><li>系统会按照编译顺序遍历所有的类和分类；</li><li>对于类的 +load 方法，系统通过 <code>schedule_class_load</code> 函数递归处理，确保了父类的 +load 方法先于子类调用，这保证了继承链上的 +load 方法调用顺序是从父类到子类；</li><li>对于分类的 +load 方法，系统通过 <code>add_category_to_loadable_list</code> 函数按照编译顺序添加。</li></ol><p>接下来，让我们继续分析 <code>call_load_methods</code> 函数的具体实现，看看系统是如何调用这些 +load 方法的：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_load_methods</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> loading = NO;</span><br><span class="line">    <span class="type">bool</span> more_categories;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止重复调用。</span></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">    loading = YES;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *pool = <span class="built_in">objc_autoreleasePoolPush</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 先调用类的 +load 方法。</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">call_class_loads</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再调用分类的 +load 方法。</span></span><br><span class="line">        more_categories = <span class="built_in">call_category_loads</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果类和分类中还有没调用的 +load 方法，则继续调用。</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">objc_autoreleasePoolPop</span>(pool);</span><br><span class="line"></span><br><span class="line">    loading = NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用类所有的 +load 方法。</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">call_class_loads</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">loadable_class</span> *classes = loadable_classes;</span><br><span class="line">    <span class="type">int</span> used = loadable_classes_used;</span><br><span class="line">    loadable_classes = nil;</span><br><span class="line">    loadable_classes_allocated = <span class="number">0</span>;</span><br><span class="line">    loadable_classes_used = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历全局数组并调用所有需要调用的 +load 方法。</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        <span class="type">load_method_t</span> load_method = (<span class="type">load_method_t</span>)classes[i].method;</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>; </span><br><span class="line">        <span class="comment">// 拿到 load 方法的函数指针进行调用。</span></span><br><span class="line">        (*load_method)(cls, @<span class="built_in">selector</span>(load));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (classes) <span class="built_in">free</span>(classes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用分类所有的 +load 方法。</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">call_category_loads</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, shift;</span><br><span class="line">    <span class="type">bool</span> new_categories_added = NO;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">loadable_category</span> *cats = loadable_categories;</span><br><span class="line">    <span class="type">int</span> used = loadable_categories_used;</span><br><span class="line">    <span class="type">int</span> allocated = loadable_categories_allocated;</span><br><span class="line">    loadable_categories = nil;</span><br><span class="line">    loadable_categories_allocated = <span class="number">0</span>;</span><br><span class="line">    loadable_categories_used = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历全局数组并调用所有需要调用的 +load 方法。</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        Category cat = cats[i].cat;</span><br><span class="line">        <span class="type">load_method_t</span> load_method = (<span class="type">load_method_t</span>)cats[i].method;</span><br><span class="line">        Class cls;</span><br><span class="line">        <span class="keyword">if</span> (!cat) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        cls = _category_getClass(cat);</span><br><span class="line">        <span class="comment">// 确保类的 +load 方法已经调用了再调用分类的 +load 方法。</span></span><br><span class="line">        <span class="keyword">if</span> (cls  &amp;&amp;  cls-&gt;<span class="built_in">isLoadable</span>()) &#123;</span><br><span class="line">            (*load_method)(cls, @<span class="built_in">selector</span>(load));</span><br><span class="line">            cats[i].cat = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shift = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将分类中还未调用的 load 方法挪到数组前面。</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cats[i].cat) &#123;</span><br><span class="line">            cats[i-shift] = cats[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            shift++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    used -= shift;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否有通过运行时动态添加的分类。</span></span><br><span class="line">    new_categories_added = (loadable_categories_used &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loadable_categories_used; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (used == allocated) &#123;</span><br><span class="line">            allocated = allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">            cats = (<span class="keyword">struct</span> loadable_category *)<span class="built_in">realloc</span>(cats, </span><br><span class="line">            allocated * <span class="built_in">sizeof</span>(<span class="keyword">struct</span> loadable_category));</span><br><span class="line">        &#125;</span><br><span class="line">        cats[used++] = loadable_categories[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loadable_categories) <span class="built_in">free</span>(loadable_categories);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果有通过运行时新添加的分类，将它们赋值给全局数组，等待后续调用。</span></span><br><span class="line">    <span class="keyword">if</span> (used) &#123;</span><br><span class="line">        loadable_categories = cats;</span><br><span class="line">        loadable_categories_used = used;</span><br><span class="line">        loadable_categories_allocated = allocated;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cats) <span class="built_in">free</span>(cats);</span><br><span class="line">        loadable_categories = nil;</span><br><span class="line">        loadable_categories_used = <span class="number">0</span>;</span><br><span class="line">        loadable_categories_allocated = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果有动态添加的分类，返回 YES，否则返回 NO。</span></span><br><span class="line">    <span class="keyword">return</span> new_categories_added;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过分析源码，我们可以总结出 +load 方法的调用顺序规则：</p><ol><li>系统会先调用类中的 load 方法，然后再调用分类中的 load 方法；</li><li>系统在调用分类的 +load 方法时，会有诸多判断，比如是否已经调用过类的 +load 方法，是否有动态添加的分类等等。</li></ol><p>在调试的过程中，我发现了一个奇怪的现象，当一个类没有实现 +load 方法，但是它的分类（有且只有一个）实现了 +load 方法时，调用顺序会发生变化。例如以下代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@implementation Person: NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Student: Person</span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@<span class="function">implementation <span class="title">Person</span> <span class="params">(Category1)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">+ <span class="params">(<span class="type">void</span>)</span>load </span>&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@<span class="function">implementation <span class="title">Student</span> <span class="params">(Category1)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">+ <span class="params">(<span class="type">void</span>)</span>load </span>&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>在这个场景中，我观察到一个奇怪的调用顺序现象。根据 Runtime 源码的实现，理论上应该是先调用完所有类的 +load 方法，然后再调用分类的 +load 方法。但实际运行结果却显示：</p><ol><li>首先调用 Person 分类的 +load 方法</li><li>然后调用 Student 类的 +load 方法</li><li>最后调用 Student 分类的 +load 方法</li></ol><p>更奇怪的是，当 Person 类有多个分类都实现了 +load 方法时，调用顺序又会回归到预期：先调用 Student 类的 +load 方法，然后按照编译顺序依次调用所有分类的 +load 方法。</p><p>这种特殊现象可能与 Runtime 在处理单个分类时的优化策略有关。当类只有一个分类时，系统可能采用了不同的处理路径，导致调用顺序发生变化。不过，由于这种差异并不影响程序的正确性，且在多分类场景下表现正常，所以这很可能是 Runtime 的一个实现细节，而非 bug。以上观点仅是我的个人猜测，如果大家有更深入的理解，欢迎在评论区分享你的见解。</p><h2 id="initialize-方法的实现机制"><a href="#initialize-方法的实现机制" class="headerlink" title="+initialize 方法的实现机制"></a>+initialize 方法的实现机制</h2><p>与 +load 方法不同，+initialize 方法是在类第一次接收到消息时才会被调用。这种延迟调用的机制使得 +initialize 方法更适合用于类的初始化工作，因为它可以确保类在被实际使用前完成必要的设置。在 <a href="https://github.com/apple-oss-distributions/objc4/tree/objc4-906">Runtime</a> 源码中，我们可以找到 +initialize 方法的具体实现细节，整理后的代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> Class</span></span><br><span class="line"><span class="function"><span class="title">realizeAndInitializeIfNeeded_locked</span><span class="params">(id inst, Class cls, <span class="type">bool</span> initialize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(!cls-&gt;<span class="built_in">isRealized</span>())) &#123;</span><br><span class="line">        cls = <span class="built_in">realizeClassMaybeSwiftAndLeaveLocked</span>(cls, runtimeLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls || !cls-&gt;<span class="built_in">ISA</span>()) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否从未调用过 +initialize 方法。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(initialize &amp;&amp; !cls-&gt;<span class="built_in">isInitialized</span>())) &#123;</span><br><span class="line">        cls = <span class="built_in">initializeAndLeaveLocked</span>(cls, inst, runtimeLock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> Class</span></span><br><span class="line"><span class="function"><span class="title">initializeAndLeaveLocked</span><span class="params">(Class cls, id obj, <span class="type">mutex_t</span>&amp; lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">initializeAndMaybeRelock</span>(cls, obj, lock, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> Class</span></span><br><span class="line"><span class="function"><span class="title">initializeAndMaybeRelock</span><span class="params">(Class cls,</span></span></span><br><span class="line"><span class="params"><span class="function">                         id inst,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">mutex_t</span>&amp; lock, <span class="type">bool</span> leaveLocked)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;<span class="built_in">isInitialized</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!leaveLocked) lock.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> cls;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class nonmeta = <span class="built_in">getMaybeUnrealizedNonMetaClass</span>(cls, inst);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nonmeta-&gt;<span class="built_in">isRealized</span>()) &#123;</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nonmeta = <span class="built_in">realizeClassMaybeSwiftAndUnlock</span>(nonmeta, lock);</span><br><span class="line">        cls = <span class="built_in">object_getClass</span>(nonmeta);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用类的 +initialize 方法。</span></span><br><span class="line">    <span class="built_in">initializeNonMetaClass</span>(nonmeta);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (leaveLocked) runtimeLock.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">initializeNonMetaClass</span><span class="params">(Class cls)</span> </span>&#123;</span><br><span class="line">    Class supercls = cls-&gt;<span class="built_in">getSuperclass</span>();</span><br><span class="line">    <span class="comment">// 先调用父类的 +initialize 方法，然后再调用自身的 +initialize 方法。</span></span><br><span class="line">    <span class="keyword">if</span> (supercls  &amp;&amp;  !supercls-&gt;<span class="built_in">isInitialized</span>()) &#123;</span><br><span class="line">        <span class="built_in">initializeNonMetaClass</span>(supercls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lockClass</span>(cls);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;<span class="built_in">isInitialized</span>()) &#123;</span><br><span class="line">        <span class="built_in">unlockClass</span>(cls);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果类正在其他线程调用 +initialize 方法。</span></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;<span class="built_in">isInitializing</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!MultithreadedForkChild || _thisThreadIsInitializingClass(cls)) &#123;</span><br><span class="line">            <span class="built_in">unlockClass</span>(cls);<span class="comment">// 避免死锁和重复调用。</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">lockClass</span>(cls);</span><br><span class="line">            _setThisThreadIsInitializingClass(cls);</span><br><span class="line">            <span class="built_in">performForkChildInitialize</span>(cls, supercls);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SmallVector&lt;_objc_willInitializeClassCallback, <span class="number">1</span>&gt; localWillInitializeFuncs;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">mutex_locker_t</span> <span class="title">lock</span><span class="params">(classInitLock)</span></span>;</span><br><span class="line">        cls-&gt;<span class="built_in">setInitializing</span>();</span><br><span class="line">        localWillInitializeFuncs.<span class="built_in">initFrom</span>(willInitializeFuncs);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _setThisThreadIsInitializingClass(cls);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (MultithreadedForkChild) &#123;</span><br><span class="line">        <span class="built_in">performForkChildInitialize</span>(cls, supercls);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> callback : localWillInitializeFuncs) &#123;</span><br><span class="line">        callback.<span class="built_in">f</span>(callback.context, cls);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @<span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用类的 +initialize 方法。</span></span><br><span class="line">        <span class="built_in">callInitialize</span>(cls);</span><br><span class="line">    &#125; @<span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        @<span class="keyword">throw</span>;</span><br><span class="line">    &#125; @finally &#123;</span><br><span class="line">        <span class="built_in">lockAndFinishInitializing</span>(cls, supercls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callInitialize</span><span class="params">(Class cls)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过消息机制向 cls 发送 initialize 消息。</span></span><br><span class="line">    <span class="built_in">objc_msgSend</span>(cls, @<span class="built_in">selector</span>(initialize));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过分析 Runtime 源码，我们可以总结出 +initialize 方法的调用机制和特点：</p><ol><li><p>调用顺序：系统会先调用父类的 +initialize 方法，再调用子类的 +initialize 方法，这保证了继承链上的初始化顺序是从父类到子类；</p></li><li><p>调用机制：+initialize 方法是通过 objc_msgSend 消息机制调用的，这意味着：</p><ul><li>如果子类未实现 +initialize 方法，会调用父类的实现；</li><li>如果分类实现了 +initialize 方法，会覆盖类本身的实现；</li><li>由于是消息机制，所以支持运行时动态修改方法实现。</li></ul></li><li><p>调用时机：+initialize 方法是在类第一次接收到消息时才会调用，而不是在类被加载到内存时就调用，这与 +load 方法有明显区别。</p></li></ol><h2 id="load-和-initialize-的异同"><a href="#load-和-initialize-的异同" class="headerlink" title="+load 和 +initialize 的异同"></a>+load 和 +initialize 的异同</h2><p>+load 和 +initialize 的相同点：</p><ul><li>它们都是由系统自动调用，且正常情况下每个类只会执行一次；</li><li>它们在继承关系中的调用顺序是一致的，都是先调用父类方法，再调用子类方法；</li></ul><p>+load 和 +initialize 的不同点：</p><ul><li><p>调用时机不同：+load 在类被加载到内存时就会调用，而 +initialize 则是在类第一次接收到消息时才会调用。这个差异导致了两个重要影响：</p><ol><li>+load 方法一定会被调用，且是在 APP 启动过程中调用，因此会影响启动性能；而 +initialize 方法只有在类被使用时才会调用，如果类从未被使用则永远不会调用；</li><li>+load 方法适合做全局性的初始化工作，而 +initialize 方法适合做类级别的初始化工作。</li></ol></li><li><p>调用机制不同：+load 方法是通过函数指针直接调用，而 +initialize 方法是通过消息机制调用。这个差异导致了：</p><ol><li>+load 方法在分类中的实现会与类本身的实现可以共存，而 +initialize 方法在分类中的实现会覆盖类本身的实现；</li><li>子类未实现 +initialize 方法时会调用父类的实现，而 +load 方法则不会。</li></ol></li></ul><p>基于以上特点，我们可以得出它们各自的最佳实践场景：</p><p>+load 方法适用于：</p><ul><li>需要在 APP 启动时就必须完成的全局初始化工作；</li><li>框架的自动初始化，比如注册通知观察者、注册路由等；</li><li>方法交换等运行时操作。</li></ul><p>+initialize 方法适用于：</p><ul><li>类级别的初始化工作，比如初始化类的静态变量；</li><li>需要根据运行时条件动态初始化的场景；</li><li>希望延迟到类首次使用时才执行的初始化操作。</li></ul><p>下面是一个使用 +load 方法实现框架自动初始化的示例：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    [<span class="built_in">NSNotificationCenter</span>.defaultCenter addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(appDidFinishLaunching) name:<span class="built_in">UIApplicationDidFinishLaunchingNotification</span> object:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)appDidFinishLaunching &#123;</span><br><span class="line">    [<span class="built_in">NSNotificationCenter</span>.defaultCenter removeObserver:<span class="keyword">self</span> name:<span class="built_in">UIApplicationDidFinishLaunchingNotification</span> object:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在这里执行框架的初始化逻辑。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>⚠️⚠️⚠️注意：由于 +load 方法是在程序启动前调用，所以它会降低 APP 的启动速度，因此在使用时需要权衡利弊。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Runtime </tag>
            
            <tag> Category </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>窥探block：iOS闭包底层原理完全解析</title>
      <link href="/2025/05/10/iOS/%E7%AA%A5%E6%8E%A2block%EF%BC%9AiOS%E9%97%AD%E5%8C%85%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
      <url>/2025/05/10/iOS/%E7%AA%A5%E6%8E%A2block%EF%BC%9AiOS%E9%97%AD%E5%8C%85%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由 布多(budo) 发布于 2025-05-10</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>block 是 iOS 开发中一个非常常用的特性，它允许我们将执行逻辑和数据封装成一个代码块，并将其作为函数参数、返回值进行传递。这种设计使得 block 在实现回调、异步操作、链式调用等场景时变得异常优雅和高效。block 最引人注目的特性在于它能够捕获并持有外部变量，这使得它在处理异步任务、事件响应等场景中表现出色，同时也为开发者提供了极大的灵活性。</p><p>本文将和大家一起深入剖析 block 的底层实现原理，从内部数据结构、内存管理机制到使用注意事项等多个维度，帮助读者全面理解这一技术的精髓，从而在实际开发中更好地运用 block 特性。</p><p>关于 block 的数据结构是开源的，在 <a href="https://github.com/apple-oss-distributions/libclosure/tree/main">libclosure</a> 库中，感兴趣的可以去看一下。</p><h2 id="block-的本质"><a href="#block-的本质" class="headerlink" title="block 的本质"></a>block 的本质</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">void</span> (^block)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;----block-----\n&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">block</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码展示了 block 的基本用法。为了深入理解 block 的底层实现原理，我们可以使用 clang 编译器将其转换为 C++ 代码。通过分析转换后的代码，我们可以清晰地看到 block 在底层的具体结构，包括其内部的数据组织方式、函数指针的存储位置以及内存布局等关键细节。</p><blockquote><p>使用 <code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-18.0.0 main.m</code> 命令可以将 main.m 文件内的代码转换为 C++ 代码。 注意：转换后的 C++ 代码并不是真正执行的代码，仅供参考。</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// block 的结构体。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> impl;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span>* Desc;</span><br><span class="line">  </span><br><span class="line">  __main_block_impl_0(<span class="type">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="type">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackblock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// block 的执行体。</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;----block-----\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// block 的描述信息。</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> reserved;</span><br><span class="line">  <span class="type">size_t</span> block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__block_impl</span> &#123;</span><br><span class="line">  <span class="type">void</span> *isa;</span><br><span class="line">  <span class="type">int</span> Flags;</span><br><span class="line">  <span class="type">int</span> Reserved;</span><br><span class="line">  <span class="comment">// 指向 block 执行体的函数指针。</span></span><br><span class="line">  <span class="type">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">void</span> (*block)(<span class="type">void</span>) = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA);</span><br><span class="line">    block-&gt;<span class="built_in">FuncPtr</span>(block);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过分析转换后的代码，我们可以得出以下结论：</p><ol><li><p>block 本质上是一个 ObjC 对象。因为在 ObjC 中，任何以 <code>isa</code> 指针作为首成员的结构体都可以被视为一个对象。从代码中可以看到，<code>__block_impl</code> 结构体的第一个成员就是 <code>void *isa</code>。</p></li><li><p>block 的创建过程实际上是在初始化一个 <code>__main_block_impl_XXX</code> 结构体实例。这个结构体主要包含了：</p><ul><li><code>__block_impl</code> 结构体（主要包含 isa 指针和函数指针）；</li><li><code>__main_block_desc_0</code> 结构体指针（主要包含 block 相关的描述信息）。</li></ul></li><li><p>block 的执行过程：</p><ul><li>系统会将 block 的代码块编译成一个全局函数（如 <code>__main_block_func_0</code>）；</li><li>这个全局函数的地址会被保存在 <code>__block_impl</code> 的 <code>FuncPtr</code> 成员中；</li><li>当调用 block 时，实际上是通过 <code>FuncPtr</code> 找到这个全局函数调用，并把 block 本身作为参数传递给这个函数。</li></ul></li></ol><h2 id="变量捕获机制"><a href="#变量捕获机制" class="headerlink" title="变量捕获机制"></a>变量捕获机制</h2><p>当 block 捕获外部变量时，编译器会根据捕获变量的类型和修饰符，生成不同的 block 结构体。这种设计使得 block 能够正确地管理不同类型变量的内存和生命周期。主要分为以下几种捕获情况：</p><ol><li>捕获全局变量；</li><li>捕获局部变量(分为基本类型和对象类型)；</li><li>捕获静态变量。</li></ol><p>另外还有关于捕获 __block 修饰的变量，这个我们会在后面的 <a href="#block-%E4%BF%AE%E9%A5%B0%E7%AC%A6%E8%AF%A6%E8%A7%A3">__block 修饰符详解</a> 章节详细讨论。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> global_age = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> age = <span class="number">10</span>;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> static_age = <span class="number">20</span>;</span><br><span class="line">  Person *per = [[Person alloc] init];</span><br><span class="line">  <span class="function">__weak <span class="title">typeof</span><span class="params">(per)</span> weakPer </span>= per;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">void</span> (^block)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;block: %p, %p, %d, %d, %d\n&quot;</span>, per, weakPer, age, static_age, global_age);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">block</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码展示了 block 捕获外部变量的几种典型场景：全局变量（global_age）、局部基本类型变量（age）、局部对象类型变量（per 和 weakPer）以及静态变量（static_age）。通过分析这些不同场景下的 block 实现，我们可以更全面地理解 block 的变量捕获机制。下面让我们通过转换后的 C++ 代码来深入分析其底层实现。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// block 的结构体。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__block_impl</span> impl;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span>* Desc;</span><br><span class="line">  Person *__strong per;</span><br><span class="line">  Person *__weak weakPer;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">int</span> *static_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// block 的执行体。</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    Person *__strong per = __cself-&gt;per;</span><br><span class="line">    Person *__weak weakPer = __cself-&gt;weakPer;</span><br><span class="line">    <span class="type">int</span> age = __cself-&gt;age;</span><br><span class="line">    <span class="type">int</span> *static_age = __cself-&gt;static_age;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;block: %p, %p, %d, %d, %d\n&quot;</span>, per, weakPer, age, *static_age, global_age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 block 被拷贝到堆上时，会调用这个函数对捕获的对象变量进行内存管理。</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0*dst, <span class="keyword">struct</span> __main_block_impl_0*src) &#123;</span><br><span class="line">    _block_object_assign((<span class="type">void</span>*)&amp;dst-&gt;per, (<span class="type">void</span>*)src-&gt;per, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 block 释放时，会调用这个函数对捕获的对象变量进行释放。</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0*src) &#123;</span><br><span class="line">    _block_object_dispose((<span class="type">void</span>*)src-&gt;per, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// block 的描述信息。</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">__main_block_desc_0</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> reserved;</span><br><span class="line">  <span class="type">size_t</span> block_size;</span><br><span class="line">  <span class="built_in">void</span> (*copy)(<span class="keyword">struct</span> __main_block_impl_0*, <span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">  <span class="built_in">void</span> (*dispose)(<span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 此处省略了 age、per、weakPer、static_age 的初始化代码。</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">void</span> (*block)(<span class="type">void</span>) = &amp;__main_block_impl_0(__main_block_func_0, </span><br><span class="line">                                            &amp;__main_block_desc_0_DATA, </span><br><span class="line">                                            per, weakPer, age, </span><br><span class="line">                                            &amp;static_age, <span class="number">570425344</span>);</span><br><span class="line">  block-&gt;<span class="built_in">FuncPtr</span>(block);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过分析转换后的代码，我们可以清晰地看到 block 捕获变量的本质：block 会将捕获的变量作为成员变量存储在其结构体中。根据变量的作用域和类型，block 的捕获机制可以分为以下几种情况：</p><ol><li><p>局部变量：block 会将局部变量作为初始化参数传入，并作为成员变量存储在结构体中。这种捕获方式对基本类型和对象类型都适用，另外，如果捕获了对象类型，还会保留其内存修饰符（如 __strong、__weak）。</p></li><li><p>全局变量：由于全局变量在整个程序生命周期内都存在，block 不会对其进行捕获，而是在内部直接访问。</p></li><li><p>静态变量：block 会捕获局部 static 变量的指针而不是变量的值，并将其存储在结构体中。这样设计使得 block 可以访问和修改静态变量的值。</p></li></ol><p>关于 block 的内存管理机制，主要涉及以下三个方面：</p><ol><li><p>对象变量的捕获管理：在 ARC 环境下，当 block 捕获了对象类型的变量时，系统会调用 <code>__main_block_copy_XXX</code> 函数进行内存管理，确保对象在 block 执行期间不会被释放。</p></li><li><p>对象变量的释放管理：当 block 被释放时，系统会调用 <code>__main_block_dispose_XXX</code> 函数，对捕获的对象变量进行适当的释放操作，防止内存泄漏。</p></li><li><p>block 在捕获对象类型变量时，会同时捕获其内存修饰符（如 __strong、__weak）。从代码中可以看到，per 和 weakPer 在结构体中被分别声明为 __strong 和 __weak 类型。这种设计使得 block 能够正确处理对象的内存管理，这也是为什么在 block 内部使用 weak 引用可以有效避免循环引用的根本原因。</p></li></ol><h2 id="block-修饰符详解"><a href="#block-修饰符详解" class="headerlink" title="__block 修饰符详解"></a>__block 修饰符详解</h2><p>在 block 中，默认情况下捕获的变量是只读的，无法在 block 内部修改。这是因为 block 在捕获变量时，实际上是将变量的值复制到自己的结构体中。如果我们需要在 block 内部修改捕获的变量，并在 block 执行后保持这些修改，就需要使用 __block 修饰符。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">  __block <span class="type">int</span> age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">void</span> (^block)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">    age = <span class="number">20</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">block</span>();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;age: %d&quot;</span>, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 clang 编译器将上述代码转换为 C++ 代码后，我们可以看到 __block 修饰符的底层实现：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// __block 修饰符的结构体。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__block_byref_age_0</span> &#123;</span><br><span class="line">  <span class="type">void</span> *__isa;</span><br><span class="line">  __block_byref_age_0 *__forwarding;</span><br><span class="line">  <span class="type">int</span> __flags;</span><br><span class="line">  <span class="type">int</span> __size;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// block 的执行体。</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    __block_byref_age_0 *age = __cself-&gt;age;</span><br><span class="line">    age-&gt;__forwarding-&gt;age = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 等价于 __block int age = 10;</span></span><br><span class="line">  __block_byref_age_0 age = &#123;</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    &amp;age,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">sizeof</span>(__block_byref_age_0),</span><br><span class="line">    <span class="number">20</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">void</span> (*block)(<span class="type">void</span>) = &amp;__main_block_impl_0(__main_block_func_0,</span><br><span class="line">                                            &amp;__main_block_desc_0_DATA,</span><br><span class="line">                                            &amp;age,</span><br><span class="line">                                            <span class="number">570425344</span>);</span><br><span class="line"></span><br><span class="line">  block-&gt;<span class="built_in">FuncPtr</span>(block);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;age: %d&quot;</span>, age.__forwarding-&gt;age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过分析 clang 转换后的 C++ 代码，我们可以深入理解 __block 修饰符的底层实现机制：</p><ol><li><p>__block 修饰符的本质是将变量包装成一个结构体对象（__block_byref_xxx），这个结构体包含了变量的值、__forwarding 指针等元数据。</p></li><li><p>当 block 捕获 __block 变量时，实际上捕获的是这个结构体对象的指针。这样设计的好处是：</p><ul><li>通过指针访问，block 可以修改原始变量的值</li><li>__forwarding 指针的存在，使得变量在 block 被拷贝到堆上时仍能正确访问</li><li>实现了变量的可修改性和数据同步</li></ul></li><li><p>这种实现虽然巧妙，但也带来了一些性能开销：</p><ul><li>每次访问变量都需要通过指针间接访问</li><li>结构体对象本身会占用额外的内存空间</li><li>在频繁访问的场景下可能会影响性能</li></ul></li></ol><p>因此，在使用 __block 修饰符时，需要权衡其带来的便利性和性能开销。对于简单的场景，可以考虑使用指针或其他替代方案。</p><p>下面这段代码展示了如何使用指针来替代 __block 修饰符，实现 block 内部修改外部变量的功能：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> age = <span class="number">10</span>;</span><br><span class="line">  <span class="type">int</span> *pointer_age = &amp;age;</span><br><span class="line">  <span class="built_in">void</span> (^block)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">     *pointer_age = <span class="number">20</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">block</span>();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;age: %d\n&quot;</span>, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="block-的三种类型"><a href="#block-的三种类型" class="headerlink" title="block 的三种类型"></a>block 的三种类型</h2><p>从 <a href="https://github.com/apple-oss-distributions/libclosure/tree/main">libclosure</a> 库的源码中，我们可以看到 block 在底层实现中定义了 6 种类型：_NSConcreteStackblock、_NSConcreteMallocblock、_NSConcreteAutoblock、_NSConcreteFinalizingblock、_NSConcreteGlobalblock 和 _NSConcreteWeakblockVariable。</p><p>在实际开发中，我们最常遇到的是以下三种类型：</p><ul><li><p>_NSConcreteGlobalblock（全局 block）：这种类型的 block 存储在数据区（.data 段），特点是未捕获任何外部变量。由于不需要保存上下文，它的生命周期与程序相同，是最轻量级的 block 类型。</p></li><li><p>_NSConcreteStackblock（栈 block）：这种类型的 block 存储在栈区，在 ARC 环境下我们很少直接遇到这种类型。这是因为 ARC 会自动将被强引用的 block 从栈上拷贝到堆上。</p></li><li><p>_NSConcreteMallocblock（堆 block）：这种类型的 block 存储在堆区，是我们在 ARC 环境下最常见到的 block 类型。当 block 捕获了对象变量时，系统会自动将其拷贝到堆上，并调用 <code>__main_block_copy_XXX</code> 和 <code>__main_block_dispose_XXX</code> 函数来管理捕获的对象变量的内存生命周期。</p></li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>在使用 block 时，我们需要注意以下几个关键点：</p><ol><li><p><strong>内存管理</strong></p><p> 在 ARC 环境下，block 会自动管理内存，但对于捕获的对象类型，block 会强引用该对象，此时需要特别注意循环引用问题。可惜使用 weak 引用来避免循环引用。</p></li><li><p><strong>变量捕获机制</strong></p><p> block 默认采用值捕获方式，会复制外部变量的值到 block 内部。如果你需要修改外部的变量值，可以使用 __block 修饰符。但使用 __block 修饰符会带来额外的内存开销，在性能敏感场景下，可以考虑使用指针替代 __block 修饰符。</p></li><li><p><strong>线程安全</strong></p><p> block 本身是线程安全的，但需要注意在多个线程的 block 中同时访问共享资源时可能存在线程安全问题。建议使用适当的同步机制（如 dispatch_sync、锁等）。</p></li><li><p><strong>使用建议</strong></p><ul><li>优先使用普通变量而不是 __block，除非确实需要修改变量值</li><li>对于简单的回调场景，可以考虑使用 delegate 模式代替 block</li><li>在异步操作中，注意处理 block 的调用时机和内存管理</li></ul></li></ol><p>通过合理使用这些特性，我们可以充分发挥 block 的优势，同时避免常见的内存和性能问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过分析 clang 转换后的 C++ 代码和 <a href="https://github.com/apple-oss-distributions/libclosure/tree/main">libclosure</a> 源码，我们可以清晰地看到 block 的本质：它是一个封装了函数执行逻辑和上下文环境的 ObjC 对象。</p><p>在编译阶段，编译器会进行以下转换：</p><ol><li>将 block 的代码块编译成一个全局函数。</li><li>创建一个 block 对象，该对象主要包含：<ul><li>指向全局函数的函数指针</li><li>block 的描述信息（如类型、大小等）</li><li>捕获的外部变量</li></ul></li></ol><p>当 block 被调用时，系统会：</p><ol><li>通过 block 对象获取内部函数指针</li><li>将 block 对象本身作为参数传递给该函数</li><li>函数内部可以通过 block 对象访问和修改捕获的变量</li></ol><p>这种设计非常巧妙，使得 block 既能像普通对象一样进行内存管理，又能像函数一样被调用，同时还能捕获外部变量。这种多面性使得 block 成为了 iOS 开发中最强大的编程特性之一。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> block </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS分类中的关联对象：如何用运行时突破Category的存储限制</title>
      <link href="/2025/04/07/iOS/iOS%E5%88%86%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AA%81%E7%A0%B4Category%E7%9A%84%E5%AD%98%E5%82%A8%E9%99%90%E5%88%B6/"/>
      <url>/2025/04/07/iOS/iOS%E5%88%86%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%AA%81%E7%A0%B4Category%E7%9A%84%E5%AD%98%E5%82%A8%E9%99%90%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由 布多(budo) 发布于 2025-04-07</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 iOS 开发中，关联对象（Associated Objects）是一种强大的运行时特性，它允许我们在 Category 中为已有的类动态添加”属性”。众所周知，Category 的一个重要限制是无法直接添加实例变量，这是因为 Category 是在运行时动态加载的，而类的内存布局（包括实例变量的大小和偏移量）必须在编译时就确定下来。关联对象通过 Runtime 机制巧妙地绕过了这一限制，让我们能够在运行时为对象动态关联任意值，从而实现类似实例变量的效果。</p><p>虽然网上关于如何使用关联对象的教程很多，但大多数都停留在使用层面，对其内部实现原理鲜有深入探讨。本文将从 Runtime 源码的角度，和大家一起深入剖析关联对象的底层实现原理，包括其内部数据结构、内存管理机制、线程安全性以及性能考量等关键细节。通过本文，你将全面了解关联对象的工作原理，从而能够更好地在实际开发中运用这一技术。为了能够更好地理解本文内容，建议读者已经对关联对象的基本使用有所了解。</p><h2 id="关联对象的底层原理"><a href="#关联对象的底层原理" class="headerlink" title="关联对象的底层原理"></a>关联对象的底层原理</h2><p>要理解关联对象的底层原理，我们需要从 Runtime 提供的三个核心 API 开始：</p><ol><li>objc_setAssociatedObject - 用于设置关联对象</li><li>objc_getAssociatedObject - 用于获取关联对象</li><li>objc_removeAssociatedObjects - 用于移除对象的所有关联对象</li></ol><p>这三个 API 共同构成了关联对象技术的基础，它们分别负责关联对象的创建、访问和清理工作。让我们先从 objc_setAssociatedObject 的实现开始，深入了解关联对象是如何被存储和管理的。</p><blockquote><p>📝 本文使用的 Runtime 版本是 <a href="https://github.com/apple-oss-distributions/objc4/tree/objc4-906">objc4-906</a>。为了方便阅读，我对代码样式和排版略作了修改，并删减了一些不影响主逻辑的冗余代码。</p><p>🔧 我在 <a href="https://github.com/internetWei/ObjCRuntimes">这里</a> 维护了一个可以直接运行调试的 Runtime 项目，欢迎大家下载调试源码。</p></blockquote><h3 id="如何添加关联对象"><a href="#如何添加关联对象" class="headerlink" title="如何添加关联对象"></a>如何添加关联对象</h3><p>当我们调用 objc_setAssociatedObject 函数来设置关联对象时，Runtime 系统会执行一系列复杂的操作来确保关联对象被正确地存储和管理。这个过程涉及到内存管理、线程安全以及哈希表操作等多个关键环节。让我们通过分析源码，一步步揭开关联对象添加过程的神秘面纱。相关源码整理后如下所示（如果觉得代码太长可以先跳过，后面会有详细解释）：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">objc_setAssociatedObject</span><span class="params">(id object, <span class="type">void</span> *key, id value, objc_AssociationPolicy policy)</span> </span>&#123;</span><br><span class="line">    _object_set_associative_reference(object, key, value, policy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_object_set_associative_reference(id object, <span class="type">void</span> *key, id value, <span class="type">uintptr_t</span> policy) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     将 object 对象包装成 DisguisedPtr，</span></span><br><span class="line"><span class="comment">     这么做有如下目的：</span></span><br><span class="line"><span class="comment">     1. 避免被 ARC 错误处理；</span></span><br><span class="line"><span class="comment">     2. 原生指针值的哈希分布可能不均匀，导致哈希冲突率高；</span></span><br><span class="line"><span class="comment">     3. 防逆向分析。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; disguised&#123;(objc_object *)object&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 value 和 policy(内存管理策略) 包装成一个 ObjcAssociation 对象。</span></span><br><span class="line">    ObjcAssociation association&#123;policy, value&#125;;</span><br><span class="line"></span><br><span class="line">    association.<span class="built_in">acquireValue</span>() = &#123;</span><br><span class="line">      <span class="keyword">if</span> (_value) &#123;</span><br><span class="line">             <span class="comment">// 根据内存管理策略对 value 执行 retain 或 copy 操作。</span></span><br><span class="line">             <span class="keyword">switch</span> (_policy &amp; <span class="number">0xFF</span>) &#123;</span><br><span class="line">             <span class="keyword">case</span> OBJC_ASSOCIATION_SETTER_RETAIN:</span><br><span class="line">                 _value = <span class="built_in">objc_retain</span>(_value);</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> OBJC_ASSOCIATION_SETTER_COPY:</span><br><span class="line">                 _value = ((<span class="built_in">id</span>(*)(id, SEL))objc_msgSend)(_value, @<span class="built_in">selector</span>(copy));</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> isFirstAssociation = <span class="literal">false</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取全局锁（在构造函数中加锁，在析构函数中解锁，这项技术被称为 RAII）</span></span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        <span class="comment">// 获取全局关联对象的哈希表。</span></span><br><span class="line">        <span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">(manager.get())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value) &#123;<span class="comment">// 设置关联值</span></span><br><span class="line">            <span class="keyword">auto</span> refs_result = associations.<span class="built_in">try_emplace</span>(disguised, ObjectAssociationMap&#123;&#125;);</span><br><span class="line">            <span class="comment">// 标记是否为首次关联</span></span><br><span class="line">            <span class="keyword">if</span> (refs_result.second) &#123;</span><br><span class="line">                isFirstAssociation = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取 object 对应的关联表（内层哈希表）</span></span><br><span class="line">            <span class="keyword">auto</span> &amp;refs = refs_result.first-&gt;second;</span><br><span class="line">            <span class="comment">// 插入或替换 key 对应的关联值</span></span><br><span class="line">            <span class="keyword">auto</span> result = refs.<span class="built_in">try_emplace</span>(key, std::<span class="built_in">move</span>(association));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 若 key 已存在，交换旧值用于后续释放</span></span><br><span class="line">            <span class="keyword">if</span> (!result.second) &#123;</span><br><span class="line">                association.<span class="built_in">swap</span>(result.first-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 删除关联值</span></span><br><span class="line">            <span class="keyword">auto</span> refs_it = associations.<span class="built_in">find</span>(disguised);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 检查关联表是否为空</span></span><br><span class="line">            <span class="keyword">if</span> (refs_it != associations.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="comment">// 获取 object 对应的关联表（内层哈希表）</span></span><br><span class="line">                <span class="keyword">auto</span> &amp;refs = refs_it-&gt;second;</span><br><span class="line">                <span class="comment">// 获取 key 对应的数据。</span></span><br><span class="line">                <span class="keyword">auto</span> it = refs.<span class="built_in">find</span>(key);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (it != refs.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    <span class="comment">// 获取旧值用于释放。</span></span><br><span class="line">                    association.<span class="built_in">swap</span>(it-&gt;second);</span><br><span class="line">                    <span class="comment">// 从内部表上删除键值对</span></span><br><span class="line">                    refs.<span class="built_in">erase</span>(it);</span><br><span class="line">                    <span class="comment">// 若内层表为空，从全局关联表中移除这个内层表。</span></span><br><span class="line">                    <span class="keyword">if</span> (refs.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">                        associations.<span class="built_in">erase</span>(refs_it);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">// 这里会释放局部变量 manager，并执行它的析构函数然后释放掉全局锁。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果是首次设置关联对象，修改 isa 上的 has_assoc 字段为 true。</span></span><br><span class="line">    <span class="keyword">if</span> (isFirstAssociation) &#123;</span><br><span class="line">        object-&gt;<span class="built_in">setHasAssociatedObjects</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放旧值</span></span><br><span class="line">    association.<span class="built_in">releaseHeldValue</span>() = &#123;</span><br><span class="line">        <span class="keyword">if</span> (_value &amp;&amp; (_policy &amp; OBJC_ASSOCIATION_SETTER_RETAIN)) &#123;</span><br><span class="line">            <span class="built_in">objc_release</span>(_value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过分析上述源码实现，我们可以清晰地看到关联对象的核心存储结构，一个精心设计的双层哈希表系统：</p><ol><li>第一层哈希表(AssociationsHashMap)：以对象的内存地址(<code>即 self</code>)为键，映射到该对象的所有关联对象存储表；</li><li>第二层哈希表(ObjectAssociationMap)：以传入的key为键，存储具体的关联对象信息。</li></ol><p>值得注意的是，系统并不是直接存储传入的 value 对象，而是将其封装在一 个ObjcAssociation 类型中。这个结构体包含两个关键信息：</p><ul><li>value: 实际存储的关联对象；</li><li>policy: 内存管理策略(如retain、copy等)。</li></ul><p>这种设计既保证了关联对象的快速存取，又实现了灵活的内存管理。</p><p>我绘制了一张结构示意图如下所示：</p><p><img src="structure.png"></p><p>让我们以一个具体的例子来说明这个存储结构：</p><p>以 <code>objc_setAssociatedObject(self, @selector(name), @&quot;budo&quot;, OBJC_ASSOCIATION_COPY_NONATOMIC)</code> 这行代码为例。</p><ul><li>第一个参数 <code>self</code> 对应第一层哈希表(AssociationsHashMap)的键；</li><li>第二个参数 <code>@selector(name)</code> 对应第二层哈希表(ObjectAssociationMap)的键；</li><li>第三个参数 <code>@&quot;budo&quot;</code> 和第四个参数 <code>OBJC_ASSOCIATION_COPY_NONATOMIC</code> 则被包装成一个 ObjcAssociation 对象。</li></ul><p>另外，关于内存管理修饰符的一个重要发现：OBJC_ASSOCIATION_RETAIN_NONATOMIC 和 OBJC_ASSOCIATION_RETAIN 在实际运行时的行为是完全一致的，从上面的源码中也可以发现这一点，我写了一个测试，代码在 <a href="https://github.com/internetWei/OmniTest/blob/main/%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1NONATOMIC%E7%9A%84%E4%BD%9C%E7%94%A8/ViewController.m">这里</a>，结果显示 OBJC_ASSOCIATION_RETAIN_NONATOMIC 和 OBJC_ASSOCIATION_RETAIN 在实际运行时的行为是完全一致的。这是因为关联对象的所有操作都会获取全局锁来确保线程安全，所以无论是否指定 NONATOMIC，都会得到相同级别的同步保护。这一点与属性修饰符 atomic&#x2F;nonatomic 的行为有所不同。</p><h3 id="如何获取关联对象"><a href="#如何获取关联对象" class="headerlink" title="如何获取关联对象"></a>如何获取关联对象</h3><p>获取关联对象的值，是通过 <code>objc_getAssociatedObject</code> 函数实现的。这个函数内部会调用 <code>_object_get_associative_reference</code> 来完成实际的获取操作。整个过程也是围绕着双层哈希表进行，相关的源码整理后如下所示：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">id <span class="title">objc_getAssociatedObject</span><span class="params">(id object, <span class="type">const</span> <span class="type">void</span> *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _object_get_associative_reference(object, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id</span><br><span class="line">_object_get_associative_reference(id object, <span class="type">const</span> <span class="type">void</span> *key) &#123;</span><br><span class="line">    ObjcAssociation association&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取全局锁（在构造函数中加锁，在析构函数中解锁）</span></span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        <span class="comment">// 获取全局关联对象哈希表</span></span><br><span class="line">        <span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">(manager.get())</span></span>;</span><br><span class="line">        <span class="comment">// 获取 object 对应的关联表（内层哈希表）</span></span><br><span class="line">        AssociationsHashMap::iterator i = associations.<span class="built_in">find</span>((objc_object *)object);</span><br><span class="line">        <span class="comment">// 判断内层表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (i != associations.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            ObjectAssociationMap &amp;refs = i-&gt;second;</span><br><span class="line">            <span class="comment">// 通过 key 找到对应数据。</span></span><br><span class="line">            ObjectAssociationMap::iterator j = refs.<span class="built_in">find</span>(key);</span><br><span class="line">            <span class="keyword">if</span> (j != refs.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                association = j-&gt;second;</span><br><span class="line">                <span class="comment">// 获取对象并执行 retain 操作。</span></span><br><span class="line">                association.<span class="built_in">retainReturnedValue</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">// 这里会执行 manager 的析构函数并释放全局锁。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将对象加入自动释放池并返回。</span></span><br><span class="line">    <span class="keyword">return</span> association.<span class="built_in">autoreleaseReturnedValue</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上代码可以看出，获取关联对象的过程相对简单，主要包含以下几个步骤：</p><ol><li>首先获取全局锁以确保线程安全；</li><li>通过 object 作为键在第一层哈希表(AssociationsHashMap)中查找对应的内层哈希表；</li><li>如果找到内层表，则使用 key 作为键在第二层哈希表(ObjectAssociationMap)中查找 ObjcAssociation 对象；</li><li>如果找到 ObjcAssociation 对象，则根据其内存管理策略对 value 执行 retain 操作；</li><li>最后将 value 加入自动释放池并返回。</li></ol><p>整个过程中的关键是双层哈希表的设计，这种设计让我们能够高效地通过对象和键的组合来存取关联值。同时，通过 RAII 技术和自动释放池的使用，保证了内存管理的安全性。</p><h3 id="如何移除所有关联对象"><a href="#如何移除所有关联对象" class="headerlink" title="如何移除所有关联对象"></a>如何移除所有关联对象</h3><p>关联对象的移除有两种方式：移除单个关联值和移除所有关联值。</p><p>对于单个关联值的移除，我们可以通过调用 <code>objc_setAssociatedObject</code> 函数并将 value 参数设置为 nil 来实现。这种方式实际上是复用了关联对象的设置逻辑，当 value 为 nil 时，Runtime 系统会自动清理对应的关联值。具体的实现细节可以参考上面的章节：<a href="#%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1">如何添加关联对象</a>。</p><p>而本节我们将重点关注如何通过 <code>objc_removeAssociatedObjects</code> 函数一次性移除对象的所有关联值。这个函数通常在对象被释放时由 Runtime 系统自动调用，当然我们也可以根据需要手动调用它。让我们一起来分析这个函数的具体实现：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">objc_removeAssociatedObjects</span><span class="params">(id object)</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (object &amp;&amp; object-&gt;<span class="built_in">hasAssociatedObjects</span>()) &#123;</span><br><span class="line">        _object_remove_associations(object, <span class="comment">/*deallocating*/</span><span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_object_remove_associations(id object, <span class="type">bool</span> deallocating) &#123;</span><br><span class="line">    ObjectAssociationMap refs&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取全局锁（在构造函数中加锁，在析构函数中解锁）</span></span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        <span class="comment">// 获取全局关联对象哈希表</span></span><br><span class="line">        <span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">(manager.get())</span></span>;</span><br><span class="line">        <span class="comment">// 获取 object 对应的关联表（内层哈希表）</span></span><br><span class="line">        AssociationsHashMap::iterator i = associations.<span class="built_in">find</span>((objc_object *)object);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="comment">// 获取旧值用于释放</span></span><br><span class="line">            refs.<span class="built_in">swap</span>(i-&gt;second);</span><br><span class="line">            </span><br><span class="line">            <span class="type">bool</span> didReInsert = <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             如果是由 dealloc 触发的，会检查关联对象的内存管理策略是否为 OBJC_ASSOCIATION_SYSTEM_OBJECT。</span></span><br><span class="line"><span class="comment">             这是一个系统内部使用的特殊策略，它要求相关对象必须在其它所有普通关联对象都释放完成后才能被释放。</span></span><br><span class="line"><span class="comment">             猜测这种设计可能是为了确保某些系统级对象能在整个释放流程中保持可用状态。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (!deallocating) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ref: refs) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ref.second.<span class="built_in">policy</span>() &amp; OBJC_ASSOCIATION_SYSTEM_OBJECT) &#123;</span><br><span class="line">                        i-&gt;second.<span class="built_in">insert</span>(ref);</span><br><span class="line">                        didReInsert = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!didReInsert) &#123;</span><br><span class="line">                <span class="comment">// 从全局关联表中移除这个内部表</span></span><br><span class="line">                associations.<span class="built_in">erase</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">// 这里会执行 manager 的析构函数并释放全局锁。</span></span><br><span class="line">    </span><br><span class="line">    SmallVector&lt;ObjcAssociation *, <span class="number">4</span>&gt; laterRefs;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历并释放所有的关联对象。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i: refs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i.second.<span class="built_in">policy</span>() &amp; OBJC_ASSOCIATION_SYSTEM_OBJECT) &#123;</span><br><span class="line">            <span class="keyword">if</span> (deallocating)</span><br><span class="line">                laterRefs.<span class="built_in">append</span>(&amp;i.second);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 释放目标对象。</span></span><br><span class="line">            i.second.<span class="built_in">releaseHeldValue</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历并释放 OBJC_ASSOCIATION_SYSTEM_OBJECT 对象。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> *later: laterRefs) &#123;</span><br><span class="line">        later-&gt;<span class="built_in">releaseHeldValue</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放所有关联对象的逻辑比较简单，但需要注意一些细节，它的主要流程如下：</p><ol><li>获取全局关联表（AssociationsHashMap），然后根据参数 object(即 self) 获取对应的内层表（ObjectAssociationMap）；</li><li>把内层表中的关联对象存储到一个临时变量 refs 中，这样做是为了避免在遍历过程中修改哈希表。</li><li>检查是否存在 OBJC_ASSOCIATION_SYSTEM_OBJECT 类型的关联对象。如果存在且不是由 dealloc 触发的，则需要将这些对象重新插入到内层表中，以确保它们能在最后被释放。</li><li>如果内层表中没有重新插入的对象，则从全局关联表中移除 object 对应的内层表。</li><li>分两步释放关联对象：先释放普通关联对象，再释放 OBJC_ASSOCIATION_SYSTEM_OBJECT 类型的关联对象。这种设计可能是为了确保系统对象在整个释放流程中保持可用状态。</li></ol><p>整个过程都是在全局锁的保护下进行的，这保证了线程安全，但也意味着大量使用关联对象可能会影响性能。</p><h2 id="相关疑问与注意事项"><a href="#相关疑问与注意事项" class="headerlink" title="相关疑问与注意事项"></a>相关疑问与注意事项</h2><h3 id="如何在关联对象中使用-weak-属性"><a href="#如何在关联对象中使用-weak-属性" class="headerlink" title="如何在关联对象中使用 weak 属性"></a>如何在关联对象中使用 weak 属性</h3><p>关联对象默认是不支持 weak 属性的。这是因为 weak 特性的实现需要能够获取到属性指针的地址，以便在对象释放时将指针置为 nil。而关联对象是通过哈希表存储的，我们无法获取到存储值的内存地址，故而不能直接使用 weak 特性。</p><p>如果你确实需要在关联对象中实现类似 weak 的效果，有以下几种替代方案：</p><ol><li>使用中间对象：创建一个中间对象，将 weak 属性存储在这个对象中，然后通过这个中间对象来间接实现 weak 效果；</li><li>使用 NSHashTable 等弱引用容器；</li><li>手动实现引用计数管理。</li></ol><p>关于“中间对象”的具体实现方案和 weak 指针的更多详细内容，可以参考我的另一篇文章：<a href="https://budo.top/2023/10/21/iOS/%E6%8F%AD%E5%BC%80%20iOS%20%E4%B8%AD%20weak%20%E6%8C%87%E9%92%88%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1%EF%BC%9A%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5/#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%BB%99-Category-%E6%B7%BB%E5%8A%A0-weak-%E5%B1%9E%E6%80%A7%EF%BC%9F">揭开 iOS 中 weak 指针的神秘面纱：从原理到实践</a></p><h3 id="关联对象为什么不能直接添加成员变量"><a href="#关联对象为什么不能直接添加成员变量" class="headerlink" title="关联对象为什么不能直接添加成员变量"></a>关联对象为什么不能直接添加成员变量</h3><p>这个问题需要从两个角度来理解：技术实现层面和设计目的层面。</p><p>从技术实现层面来说，类的内存布局（包括实例变量的大小和偏移量）必须在编译时就确定下来。一旦类被编译完成，其内存布局就已经固定，无法再动态地添加实例变量。因为分类不仅适用于我们自己项目中的类，更重要的是还包括系统框架和第三方库中的类。</p><p>从设计目的层面来说，关联对象的设计初衷就是为了在不改变类内存布局的情况下，实现动态地为对象添加存储能力。这使得我们可以：</p><ol><li>在 Category 中添加”属性”，突破 Category 的存储限制；</li><li>为系统类添加自定义属性，而无需继承；</li><li>在运行时动态地为任意对象关联数据。</li></ol><p>如果关联对象的实现被限制为只能给当前项目中的类添加属性，那么理论上确实可以通过编译器在编译期间修改类的内存布局来实现。但这样就失去了关联对象最重要的特性 - 运行时动态性，也无法实现对系统和三方库中的类进行扩展。</p><p>如果你想了解更多 Category 方面的知识，可以参考我的另一篇文章：<a href="https://budo.top/2024/12/11/iOS/2024%20%E5%86%8D%E6%8E%A2ObjC-Category%EF%BC%9A%E5%8A%A8%E6%80%81%E7%89%B9%E6%80%A7%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%9E%81%E8%87%B4%E4%B9%8B%E7%BE%8E/#Category-%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82%EF%BC%9A%E6%8E%A2%E7%B4%A2%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">2024 再探ObjC-Category：动态特性与运行时实现的极致之美</a>。</p><h3 id="关联对象和真正的属性有什么区别"><a href="#关联对象和真正的属性有什么区别" class="headerlink" title="关联对象和真正的属性有什么区别"></a>关联对象和真正的属性有什么区别</h3><p>虽然关联对象在使用上与普通属性非常相似，但它们在实现机制和性能特征上存在显著差异：</p><ol><li><p>实现机制：</p><ul><li>属性是在编译时就确定的实例变量，直接存储在对象的内存布局中。</li><li>关联对象是运行时动态添加的，通过全局哈希表来存储和管理。</li></ul></li><li><p>性能开销：</p><ul><li>属性访问只需要一次简单的内存偏移计算。</li><li>关联对象需要哈希表查找、加解锁等多个操作步骤，性能开销较大，我在 iPhone 8 Plus(iOS15.8.3) 设备上做了一个测试，代码在 <a href="https://github.com/internetWei/OmniTest/blob/main/%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%B1%9E%E6%80%A7%E7%9A%84%E8%AF%BB%E5%86%99%E6%80%A7%E8%83%BD/ViewController.m">这里</a>，结果显示属性比关联对象快了 4 倍左右，这里只测试了单线程的情况，不能反映多线程下的实际性能，结果只当作一个参考。</li></ul><p> <img src="performance.png"></p></li><li><p>线程安全：</p><ul><li>iOS 中的属性一般是非原子的(nonatomic)，多线程访问需要手动加锁。</li><li>关联对象通过全局锁保证了操作的原子性。</li></ul></li><li><p>内存管理：</p><ul><li>属性的内存管理由编译器自动处理，通过 strong、weak 等属性修饰符指定。</li><li>关联对象需要手动指定内存管理策略，且不支持 weak 引用。</li></ul></li><li><p>使用场景：</p><ul><li>属性适用于类的核心功能实现。</li><li>关联对象主要用于运行时动态扩展功能，尤其是在分类中添加存储能力。</li></ul></li></ol><p>因此，虽然关联对象为我们提供了强大的动态扩展能力，但在性能要求较高的场景下，应优先考虑使用属性来实现。</p><h3 id="关联对象的释放时机"><a href="#关联对象的释放时机" class="headerlink" title="关联对象的释放时机"></a>关联对象的释放时机</h3><p>关联对象的释放时机与对象本身的释放时机完全一致。当一个对象被释放时，Runtime 系统会自动调用 <code>_object_remove_associations</code> 函数来移除该对象的所有关联对象(和手动调用 <code>objc_removeAssociatedObjects</code> 函数效果类似，除了第二个参数值不一样)。整个调用链路如下所示：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dealloc</span><br><span class="line">└── _objc_rootDealloc</span><br><span class="line">    └── rootDealloc</span><br><span class="line">        └── object_dispose</span><br><span class="line">            └── objc_destructInstance</span><br><span class="line">                └── _object_remove_associations</span><br></pre></td></tr></table></figure><h3 id="使用关联对象时的注意事项"><a href="#使用关联对象时的注意事项" class="headerlink" title="使用关联对象时的注意事项"></a>使用关联对象时的注意事项</h3><p>虽然关联对象为我们提供了强大的动态扩展能力，但由于其特殊的实现机制，在实际使用过程中我们仍需要注意以下几个关键点，以避免潜在的问题：</p><ol><li><p>内存管理策略的选择</p><ul><li>谨慎使用 OBJC_ASSOCIATION_ASSIGN：这种策略不会持有对象，容易造成野指针崩溃。仅在以下特殊场景考虑使用：<ul><li>关联对象是 Tagged Pointer（如小整数的 NSNumber）；</li><li>关联对象与被关联对象具有相同的生命周期；</li><li>需要打破循环引用的场景。</li></ul></li><li>即使是 Tagged Pointer 对象，也建议使用带有 RETAIN 或 COPY 的内存管理策略，因为 Runtime 系统内部会自动处理 Tagged Pointer 的内存管理。</li></ul></li><li><p>性能考量：关联对象的存取涉及全局哈希表操作和加锁，性能开销比直接访问实例变量大；所以不要在性能敏感的代码路径中频繁操作关联对象；可以考虑使用缓存机制减少访问频率。</p></li><li><p>线程安全：关联对象只保证了读写操作是原子的，但多线程访问时仍需注意数据一致性（例如多线程对可变对象的修改）；复杂操作时建议额外加锁保护。</p></li><li><p>内存管理</p><ul><li>在对象释放时，其关联对象会被自动移除；</li><li>使用 RETAIN&#x2F;COPY 策略时要注意避免循环引用；</li><li>如果确实需要 weak 引用效果，可以考虑使用 “中间对象” 或 NSHashTable 等方案。</li></ul></li><li><p>调试与维护</p><ul><li>关联对象不会出现在类的属性列表中，调试时需要特别注意；</li><li>建议统一管理关联对象的 key，避免冲突；</li><li>适当添加注释说明关联对象的用途和生命周期管理方式。</li></ul></li></ol><h2 id="技术总结"><a href="#技术总结" class="headerlink" title="技术总结"></a>技术总结</h2><p>通过对关联对象底层实现原理的深入分析，我们可以得出以下关键结论：</p><ol><li><p>存储结构</p><ul><li>关联对象的底层采用双层哈希表结构实现，保证了快速的存取效率；</li><li>第一层以对象地址为键，映射到该对象的所有关联对象；</li><li>第二层以关联键为索引，存储具体的关联值和内存管理策略。</li></ul></li><li><p>线程安全</p><ul><li>关联对象内部通过全局锁保证了存取操作的原子性；</li><li>采用 RAII 技术自动管理锁的获取和释放；</li><li>但是复杂操作时仍需考虑额外的同步机制。</li></ul></li><li><p>内存管理</p><ul><li>支持 retain&#x2F;copy&#x2F;assign 多种内存管理策略，但不支持 weak 引用；</li><li>自动处理关联对象的生命周期，与对象的生命周期一致；</li><li>通过 ObjcAssociation 封装实现统一的内存管理。</li></ul></li></ol><p>关联对象技术为 Category 突破了存储限制，但也带来了额外的复杂性和性能开销。在实际开发中，应当根据具体场景权衡使用，合理使用这把 “双刃剑”。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Runtime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tagged Pointer：苹果工程师的内存优化艺术</title>
      <link href="/2025/04/02/iOS/Tagged%20Pointer%EF%BC%9A%E8%8B%B9%E6%9E%9C%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E8%89%BA%E6%9C%AF/"/>
      <url>/2025/04/02/iOS/Tagged%20Pointer%EF%BC%9A%E8%8B%B9%E6%9E%9C%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E8%89%BA%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由 布多(budo) 发布于 2025-04-02</p></blockquote><h2 id="Tagged-Pointer-的前世今生"><a href="#Tagged-Pointer-的前世今生" class="headerlink" title="Tagged Pointer 的前世今生"></a>Tagged Pointer 的前世今生</h2><p>在 iOS 开发的早期阶段，所有对象都采用传统的堆内存存储方式。每个对象指针都指向堆内存中的一块区域，这块区域不仅存储着对象的实际数据，还包含了类型信息、引用计数等元数据。这种存储方式虽然通用且灵活，但对于一些简单的数据类型（如 NSNumber 存储的小整数 10、200 等），却显得有些”大材小用”。试想，仅仅为了存储一个小整数，就需要在堆上分配内存、维护引用计数、进行内存回收，这不仅造成了内存空间的浪费，还会因为频繁的内存操作而影响系统性能。</p><p>为了解决这个问题，苹果的工程师们提出了 Tagged Pointer 技术。这项技术的核心思想是：对于一些小型数据，将其直接编码到指针中，而不是在堆上分配内存。这种巧妙的设计不仅节省了宝贵的内存空间，还通过减少内存分配和释放操作显著提升了性能。</p><p>这种创新的效果是立竿见影的。根据 WWDC2013 苹果官方发布的数据显示，采用 Tagged Pointer 技术后，相关操作获得了显著的性能提升：内存占用直接减少了 50%，数据访问速度提升了 3 倍，而对象的创建和销毁速度更是实现了惊人的 100 倍提升。这些数据充分证明了 Tagged Pointer 技术在内存优化和性能提升方面的巨大价值。</p><h2 id="技术原理深度解析"><a href="#技术原理深度解析" class="headerlink" title="技术原理深度解析"></a>技术原理深度解析</h2><p>虽然 Tagged Pointer 技术在 iOS 中被广泛应用于 NSNumber、NSDate、NSString 等多个对象类型，但 NSNumber 是最具代表性的例子。因此，本文将以 NSNumber 为例深入讲解其实现原理。其它对象的实现机制与 NSNumber 类似，读者可以举一反三。</p><p>值得注意的是，在现代 Xcode 版本中（具体从哪个版本开始不太确定），苹果为了增强数据安全性，对 Tagged Pointer 进行了数据混淆处理。这种混淆机制使得开发者无法通过直接打印指针来判断一个对象是否为 Tagged Pointer，也无法解析其中存储的具体数据。</p><p>为了便于调试和观察 Tagged Pointer 的底层实现，我们需要关闭这个数据混淆功能。只需要将环境变量 <code>OBJC_DISABLE_TAG_OBFUSCATION</code> 设置为 <code>YES</code> 即可。</p><p><img src="operator.png"></p><p>由于 NSNumber 的源码未开源，所以我们通过分析结果来了解 Tagged Pointer 的实现原理。以下是我的调试结果：</p><p><img src="result1.png"></p><p>通过分析打印结果，我们可以看到 Tagged Pointer 的精妙设计：它将数据直接编码在指针中，而不是在堆内存中分配空间。具体来说：</p><ol><li><p>指针的第 6 位到第 60 位（从左往右数）用于存储实际数据。这意味着一个 NSNumber 对象最多可以存储 55 位的数据，即 0x7FFFFFFFFFFFFF，对应的十进制为 36028797018963967。</p></li><li><p>指针的其余位则用于存储元数据：</p><ul><li>第 1 位（最高位）作为 Tag 标记，用于标识这是一个 Tagged Pointer；</li><li>第 2-5 位用于存储对象类型（如 NSNumber 为 3，NSString 为 2）；</li><li>最后 4 位用于存储数据类型（如 int 为 2，long 为 3）。</li></ul></li></ol><p>Tagged Pointer 的内存分布图如下所示：</p><p><img src="TaggedPointer.png"></p><blockquote><p>需要注意的是，不同平台和系统版本下，Tagged Pointer 的实现细节可能有所不同。例如，在 iOS 模拟器和真机环境中，Tag 位和数据位的存储位置就存在差异：模拟器中 Tag 位在最低位，而真机中 Tag 位在最高位。这种差异主要是由于不同平台的内存对齐要求和处理器架构特性导致的。因此，在调试过程中如果发现结果与预期不符，可以看看是不是平台或系统版本的问题。</p></blockquote><p>这种设计巧妙地利用了 64 位系统的特性。在现代操作系统中，由于虚拟内存地址空间的限制，64 位指针实际上只使用了最低的 47 位来寻址，这意味着在正常情况下，合法的内存地址最高位一定是 0。Tagged Pointer 正是巧妙利用了这一特点，通过将最高位设为 1 来标识这是一个特殊的指针。Tagged Pointer 还将这些 “空闲” 的位进行了重新规划利用：一部分用于存储类型标记，另一部分用于直接存储数据。这样，对于小型数据（如小整数、短字符串等）就不再需要额外分配堆内存，而是直接将数据编码在指针中。这种设计不仅完美地保证了数据的完整性和访问效率，还通过消除堆内存分配、引用计数管理等开销，实现了内存使用的极致优化。</p><p>虽然 NSNumber 的源码未开源，但我通过深入分析 <code>objc_runtime</code> 源码，还是找到了一些关键的入口函数。这些函数揭示了 Tagged Pointer 的底层运作机制，包括数据混淆(其实就是启动的时候生成一个随机数，然后进行异或 ^ 运算)以及 Tag 和 Data 的存储位置等核心实现细节。以下是几个比较重要的函数，碍于篇幅这里就不展开了，感兴趣的同学可以下载 <a href="https://github.com/apple-oss-distributions/objc4/tree/objc4-906">runtime</a> 自行研究，它们共同构成了 Tagged Pointer 的基础框架：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">isTaggedPointer =&gt; 判断是否是 Tagged Pointer</span><br><span class="line">_objc_makeTaggedPointer =&gt; 生成 Tagged Pointer</span><br><span class="line">_objc_getTaggedPointerTag =&gt; 获取 Tag</span><br><span class="line">_objc_getTaggedPointerValue =&gt; 获取 Value</span><br><span class="line">initializeTaggedPointerObfuscator =&gt; runtime 启动时初始化 Tagged Pointer 混淆器</span><br></pre></td></tr></table></figure><h3 id="Tagged-Pointer-的类型编码"><a href="#Tagged-Pointer-的类型编码" class="headerlink" title="Tagged Pointer 的类型编码"></a>Tagged Pointer 的类型编码</h3><p>在 Tagged Pointer 中，系统使用特定的位来编码对象类型和数据类型。以下是详细的编码对照表：</p><h4 id="对象类型编码"><a href="#对象类型编码" class="headerlink" title="对象类型编码"></a>对象类型编码</h4><p>对象类型编码存储在指针的第 2-5 位。</p><table><thead><tr><th align="center">值</th><th align="center">对象类型</th></tr></thead><tbody><tr><td align="center">2</td><td align="center">NSString</td></tr><tr><td align="center">3</td><td align="center">NSNumber</td></tr><tr><td align="center">4</td><td align="center">NSIndexPath</td></tr><tr><td align="center">5</td><td align="center">NSManagedObjectID</td></tr><tr><td align="center">6</td><td align="center">NSDate</td></tr></tbody></table><h4 id="数据类型编码"><a href="#数据类型编码" class="headerlink" title="数据类型编码"></a>数据类型编码</h4><p>数据类型编码存储在指针的最后4位。</p><table><thead><tr><th align="center">值</th><th align="center">数据类型</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">char</td></tr><tr><td align="center">1</td><td align="center">short</td></tr><tr><td align="center">2</td><td align="center">int</td></tr><tr><td align="center">3</td><td align="center">long</td></tr><tr><td align="center">4</td><td align="center">float</td></tr><tr><td align="center">5</td><td align="center">double</td></tr><tr><td align="center">6</td><td align="center">long long</td></tr></tbody></table><h2 id="判断-Tagged-Pointer-的原理"><a href="#判断-Tagged-Pointer-的原理" class="headerlink" title="判断 Tagged Pointer 的原理"></a>判断 Tagged Pointer 的原理</h2><p>系统是如何判断一个指针是否是 Tagged Pointer 的呢？其实，在 <a href="https://github.com/apple-oss-distributions/objc4/tree/objc4-906">objc4-906</a> 源码中，我们可以找到 <code>isTaggedPointer</code> 的实现细节。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isTaggedPointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_isTaggedPointer(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _OBJC_TAG_MASK (1UL&lt;&lt;63)</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> _objc_isTaggedPointer(<span class="type">void</span> *ptr) &#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">uintptr_t</span>)ptr &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看到，系统通过位运算 <code>&amp;</code> 操作获取指针的最高位，并与 <code>_OBJC_TAG_MASK</code>（1UL&lt;&lt;63，即最高位为1的掩码）进行比较。如果结果等于 <code>_OBJC_TAG_MASK</code>，就表示这个指针是一个 Tagged Pointer(简单的说就是判断指针的第一位是否为1)。这种判断方式简单高效，只需要一次位运算就能完成判断。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>虽然我们一般不需要关心 Tagged Pointer 的具体实现细节，但在使用过程中还是有一些需要注意的地方：</p><ul><li><p>Tagged Pointer 不是传统意义上的 ObjC 对象，它没有常规对象所具有的 <code>isa</code> 指针。因此，不要尝试直接访问或操作其 isa 指针，应该始终通过系统提供的公开接口来操作这些对象。</p></li><li><p>出于安全考虑，在现代 Xcode 版本中，苹果对 Tagged Pointer 实现了数据混淆机制。这意味着即使你通过某种方式获取到了指针的原始值，也无法直接解析出其中存储的数据。正确的做法是使用框架提供的标准方法来访问数据。</p></li><li><p>Tagged Pointer 的具体实现细节可能会随着系统版本的更新而改变。因此，不要在代码中依赖其当前的实现方式（如位编码规则），这可能会导致你的应用在未来的系统版本中出现兼容性问题。</p></li><li><p>在进行内存调试或性能分析时，要注意 Tagged Pointer 对象的特殊性。它们不会出现在常规的内存分配统计中，因为它们实际上并不占用堆内存。</p></li></ul><p>关于 Tagged Pointer 有一个面试题，碍于篇幅，这里就不展开了，感兴趣的可以看一下 <a href="https://juejin.cn/post/6844904132940136462#heading-16">老生常谈内存管理</a> 中的 “相关题目” 章节。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://juejin.cn/post/6844904132940136462">老生常谈内存管理：Tagged Pointer</a></li><li><a href="https://blog.devtang.com/2014/05/30/understand-tagged-pointer/">深入理解Tagged Pointer · 唐巧的博客</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AutoreleasePool：iOS 内存管理乐章中的隐秘旋律</title>
      <link href="/2025/03/30/iOS/AutoreleasePool%EF%BC%9AiOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%90%E7%AB%A0%E4%B8%AD%E7%9A%84%E9%9A%90%E7%A7%98%E6%97%8B%E5%BE%8B/"/>
      <url>/2025/03/30/iOS/AutoreleasePool%EF%BC%9AiOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%90%E7%AB%A0%E4%B8%AD%E7%9A%84%E9%9A%90%E7%A7%98%E6%97%8B%E5%BE%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由 布多(budo) 发布于 2025-03-30</p></blockquote><h2 id="揭开-AutoreleasePool-的面纱"><a href="#揭开-AutoreleasePool-的面纱" class="headerlink" title="揭开 AutoreleasePool 的面纱"></a>揭开 AutoreleasePool 的面纱</h2><p>AutoreleasePool（中文也叫自动释放池）是 iOS 内存管理机制中的一个重要组成部分。它优雅地解决了对象生命周期管理的问题 - 通过延迟对象的释放时机，在合适的时间点统一回收内存资源。</p><p>这个精妙的设计背后有着怎样的实现原理呢？让我们一起深入 <a href="https://github.com/apple-oss-distributions/objc4/">objc4</a> 开源项目的源码，去探索 AutoreleasePool 的底层实现细节。</p><blockquote><p>📝 本文使用的 Runtime 版本是 <a href="https://github.com/apple-oss-distributions/objc4/tree/objc4-906">objc4-906</a>。为了方便阅读，我对代码样式和排版略作了修改，并删减了一些不影响主逻辑的冗余代码。</p><p>🔧 我在 <a href="https://github.com/internetWei/ObjCRuntimes">这里</a> 维护了一个可以直接运行调试的 Runtime 项目，欢迎大家下载调试源码。</p></blockquote><h2 id="深入底层：AutoreleasePool-的实现机制"><a href="#深入底层：AutoreleasePool-的实现机制" class="headerlink" title="深入底层：AutoreleasePool 的实现机制"></a>深入底层：AutoreleasePool 的实现机制</h2><p>在 ARC 环境下，我们作为开发者能够接触到 AutoreleasePool 的场景主要有两种：</p><ol><li><p>使用 <code>__autoreleasing</code> 修饰符</p><ul><li>将对象注册到自动释放池中</li><li>实现对象的延迟释放机制</li></ul></li><li><p>使用 <code>@autoreleasepool &#123;&#125;</code> 语法块</p><ul><li>精确控制内存的释放时机</li><li>有效控制内存峰值</li></ul></li></ol><p>让我们一起深入源码和汇编层面，揭开这两种使用场景背后的技术实现细节。</p><h3 id="autoreleasing-修饰符的内部实现"><a href="#autoreleasing-修饰符的内部实现" class="headerlink" title="__autoreleasing 修饰符的内部实现"></a>__autoreleasing 修饰符的内部实现</h3><p><img src="objc_autorelease%E5%85%A5%E5%8F%A3.png"></p><p>从断点的汇编代码中我们可以发现，当我们使用 __autoreleasing 修饰一个对象时，系统会自动将其转换为对 objc_autorelease 函数的调用。这个操作等同于在 MRC 环境下手动调用对象的 autorelease 方法，它们在底层实现上是完全一致的。</p><p>让我们深入 Runtime 源码，一探 objc_autorelease 的内部实现。以下是经过整理的核心代码（如果觉得代码太长可以先跳过，后面会有详细解释）：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">id <span class="title">objc_autorelease</span><span class="params">(id obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;<span class="built_in">autorelease</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">id <span class="title">objc_object::autorelease</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     检查该对象是否有自定义的引用计数(RR = Retain/Release)实现，</span></span><br><span class="line"><span class="comment">     ARC 肯定没有，MRC 一般也不会自定义这些方法实现。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(!<span class="built_in">ISA</span>()-&gt;<span class="built_in">hasCustomRR</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rootAutorelease</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">objc_msgSend</span>(<span class="keyword">this</span>, @<span class="built_in">selector</span>(autorelease));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">id <span class="title">objc_object::rootAutorelease</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果对象正在释放，不要加入到 AutoreleasePool 中。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isa</span>().<span class="built_in">isDeallocating</span>()) <span class="keyword">return</span> (id)<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      如果对象有使用返回值优化的话，不要加入到 AutoreleasePool 中。</span></span><br><span class="line"><span class="comment">      后面的章节《性能优化：TLS 机制解析》会对该机制进行说明。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">prepareOptimizedReturn</span>((id)<span class="keyword">this</span>, <span class="literal">true</span>, ReturnAtPlus1)) <span class="keyword">return</span> (id)<span class="keyword">this</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果是类对象，不要加入到 AutoreleasePool 中。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(<span class="built_in">isClass</span>())) <span class="keyword">return</span> (id)<span class="keyword">this</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">rootAutorelease2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">id <span class="title">objc_object::rootAutorelease2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::<span class="built_in">autorelease</span>((id)<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：从这里开始，后面都是 AutoreleasePoolPage 的内部函数。</span></span><br><span class="line"><span class="function"><span class="type">static</span> id <span class="title">autorelease</span><span class="params">(id obj)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">autoreleaseFast</span>(obj);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">id *<span class="title">autoreleaseFast</span><span class="params">(id obj)</span> </span>&#123;</span><br><span class="line">    AutoreleasePoolPage *page = <span class="built_in">hotPage</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (page &amp;&amp; !page-&gt;<span class="built_in">full</span>()) &#123;</span><br><span class="line">        <span class="comment">// 当前页未满，直接添加</span></span><br><span class="line">        <span class="keyword">return</span> page-&gt;<span class="built_in">add</span>(obj);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page) &#123;</span><br><span class="line">        <span class="comment">// 当前页已满，创建新页添加</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">autoreleaseFullPage</span>(obj, page);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前线程中还没有 Page，创建一个并添加对象。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">autoreleaseNoPage</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">id *<span class="title">add</span><span class="params">(id obj)</span> </span>&#123;</span><br><span class="line">    id *ret;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    下面的这段代码的逻辑大致是：如果启用了对象合并优化方案，</span></span><br><span class="line"><span class="comment">    则将重复调用 autorelease 的对象进行合并，</span></span><br><span class="line"><span class="comment">    这么做的目的是为了减少同一个对象被多次重复的添加到自动释放池。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    一般这种场景会出现在循环中，例如以下代码，</span></span><br><span class="line"><span class="comment">    如果未优化的话就会在 Page 中存放 10 个 Person 对象；</span></span><br><span class="line"><span class="comment">    优化后只会存放 1 个 Person 对象。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; 10; i++) &#123;</span></span><br><span class="line"><span class="comment">        __autoreleasing Person *per = [[Person alloc] init];</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (!DisableAutoreleaseCoalescing || </span><br><span class="line">        !DisableAutoreleaseCoalescingLRU) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!DisableAutoreleaseCoalescingLRU) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">empty</span>() &amp;&amp; (obj != POOL_BOUNDARY)) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                获取 Page 最后的存储对象，检查与当前对象是否相同，</span></span><br><span class="line"><span class="comment">                如果相同则进行合并。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                AutoreleasePoolEntry *topEntry = (AutoreleasePoolEntry *)next - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 向前最多查找 4 个对象</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">uintptr_t</span> offset = <span class="number">0</span>; offset &lt; <span class="number">4</span>; offset++) &#123;</span><br><span class="line">                    AutoreleasePoolEntry *offsetEntry = topEntry - offset;</span><br><span class="line">                    <span class="comment">// 检查是否越界或遇到池边界（POOL_BOUNDARY）</span></span><br><span class="line">                    <span class="keyword">if</span> (offsetEntry &lt;= (AutoreleasePoolEntry*)<span class="built_in">begin</span>() || </span><br><span class="line">                        *(id *)offsetEntry == POOL_BOUNDARY) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 找到相同的对象且计数未达上限</span></span><br><span class="line">                    <span class="keyword">if</span> (offsetEntry-&gt;<span class="built_in">getPointer</span>() == (<span class="type">uintptr_t</span>)obj &amp;&amp; </span><br><span class="line">                        offsetEntry-&gt;<span class="built_in">getCount</span>() &lt; AutoreleasePoolEntry::maxCount) &#123;</span><br><span class="line">                        <span class="comment">// 通过内存移动，将匹配的对象移动到池顶。</span></span><br><span class="line">                        <span class="keyword">if</span> (offset &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            AutoreleasePoolEntry found = *offsetEntry;</span><br><span class="line">                            <span class="built_in">memmove</span>(offsetEntry, offsetEntry + <span class="number">1</span>, offset * <span class="built_in">sizeof</span>(*offsetEntry));</span><br><span class="line">                            *topEntry = found;</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 增加这个对象的计数。</span></span><br><span class="line">                        topEntry-&gt;<span class="built_in">incrementCount</span>();</span><br><span class="line">                        ret = (id *)topEntry;</span><br><span class="line">                        <span class="keyword">goto</span> done;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">empty</span>() &amp;&amp; (obj != POOL_BOUNDARY)) &#123;</span><br><span class="line">                <span class="comment">// 仅检查池顶前一个对象和当前对象是否一致。</span></span><br><span class="line">                AutoreleasePoolEntry *prevEntry = (AutoreleasePoolEntry *)next - <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 直接合并到前一个对象。</span></span><br><span class="line">                <span class="keyword">if</span> (prevEntry-&gt;<span class="built_in">getPointer</span>() == (<span class="type">uintptr_t</span>)obj &amp;&amp; </span><br><span class="line">                    prevEntry-&gt;<span class="built_in">getCount</span>() &lt; AutoreleasePoolEntry::maxCount) &#123;</span><br><span class="line">                    prevEntry-&gt;<span class="built_in">incrementCount</span>();</span><br><span class="line">                    ret = (id *)prevEntry;</span><br><span class="line">                    <span class="keyword">goto</span> done;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = next;</span><br><span class="line">    *next++ = obj;</span><br><span class="line"></span><br><span class="line"> done:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">id *<span class="title">autoreleaseFullPage</span><span class="params">(id obj, AutoreleasePoolPage *page)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取下一个 Page 对象，</span></span><br><span class="line"><span class="comment">    如果它不存在或者存满了就创建一个新的。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (page-&gt;child) page = page-&gt;child;</span><br><span class="line">        <span class="keyword">else</span> page = <span class="keyword">new</span> <span class="built_in">AutoreleasePoolPage</span>(page);</span><br><span class="line">    &#125; <span class="keyword">while</span> (page-&gt;<span class="built_in">full</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将当前 Page 设置为 hot。</span></span><br><span class="line">    <span class="built_in">setHotPage</span>(page);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将对象添加到 Page 中。</span></span><br><span class="line">    <span class="keyword">return</span> page-&gt;<span class="built_in">add</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">id *<span class="title">autoreleaseNoPage</span><span class="params">(id obj)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> pushExtraBoundary = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     首次创建自动释放池时，会用一个占位符表示空池。</span></span><br><span class="line"><span class="comment">     此时若添加对象，需先补一个边界。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">haveEmptyPoolPlaceholder</span>()) &#123;</span><br><span class="line">        pushExtraBoundary = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接使用空占位符，避免创建真实的池结构。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (obj == POOL_BOUNDARY) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">setEmptyPoolPlaceholder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 Page，并设置为 hot。</span></span><br><span class="line">    AutoreleasePoolPage *page = <span class="keyword">new</span> <span class="built_in">AutoreleasePoolPage</span>(nil);</span><br><span class="line">    <span class="built_in">setHotPage</span>(page);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pushExtraBoundary) &#123;</span><br><span class="line">        page-&gt;<span class="built_in">add</span>(POOL_BOUNDARY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> page-&gt;<span class="built_in">add</span>(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数调用流程大致如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">objc_autorelease</span><br><span class="line">└── autorelease</span><br><span class="line">    └── rootAutorelease</span><br><span class="line">        └── rootAutorelease2</span><br><span class="line">            └── AutoreleasePoolPage::autorelease</span><br><span class="line">                └── AutoreleasePoolPage::autoreleaseFast</span><br></pre></td></tr></table></figure><p>从上面的代码分析中我们可以看到，当一个对象被标记为 autoreleasing 时，系统会通过一系列函数调用最终将其加入到 AutoreleasePoolPage 中。这个过程主要由 autoreleaseFast 函数完成，它负责管理对象的具体存储工作。在 autoreleaseFast 函数内部，系统会获取当前线程的 hotPage（所谓的 hotPage，其实就是双向链表的尾节点），然后根据 page 状态决定执行逻辑：</p><table><thead><tr><th>场景</th><th>状态</th><th>执行逻辑</th></tr></thead><tbody><tr><td>逻辑一</td><td>page 存在且未满</td><td>直接调用 add 函数将对象添加到 Page 中</td></tr><tr><td>逻辑二</td><td>page 存在但已满</td><td>调用 autoreleaseFullPage 创建新 Page，然后添加对象</td></tr><tr><td>逻辑三</td><td>page 不存在</td><td>直接创建新 Page，然后添加对象</td></tr></tbody></table><p>这里有一个有趣的优化细节：系统并不是直接存放对象的地址，而是将其包装成一个 AutoreleasePoolEntry 对象。这样设计的原因在于系统采用了 “对象合并优化” 方案 - 当多个相同对象被重复加入 Page 时，系统只会保留第一个对象，并通过 count 值记录该对象被重复加入的次数。这种优化可以有效减少内存占用（具体细节请阅读上面的 add 函数）。</p><p>至此，autoreleasing 对象就完成了它进入 AutoreleasePool 的全过程。</p><p>在上述实现中，有一个核心类型值得我们特别关注 - AutoreleasePoolPage。作为存储数据的底层结构，它在整个自动释放池机制中扮演着至关重要的角色。接下来，让我们深入分析这个关键组件。</p><h3 id="AutoreleasePoolPage：内存管理的基石"><a href="#AutoreleasePoolPage：内存管理的基石" class="headerlink" title="AutoreleasePoolPage：内存管理的基石"></a>AutoreleasePoolPage：内存管理的基石</h3><p>让我们一起来看看 AutoreleasePoolPage 这个核心类的内部结构。为了便于理解，我对源码进行了精简和注释，保留了最关键的部分：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AutoreleasePoolPage</span> &#123;</span><br><span class="line">    <span class="type">magic_t</span> magic;                <span class="comment">// 魔数，用于校验 Page 的有效性和完整性</span></span><br><span class="line">    __unsafe_unretained id *next; <span class="comment">// 指向当前 Page 中下一个可用的存储位置</span></span><br><span class="line">    <span class="type">objc_thread_t</span> thread;         <span class="comment">// 当前 Page 所属的线程，每个线程都有自己的 AutoreleasePool</span></span><br><span class="line">    AutoreleasePoolPage *parent;  <span class="comment">// 指向双向链表中的前一个 Page</span></span><br><span class="line">    AutoreleasePoolPage *child;   <span class="comment">// 指向双向链表中的后一个 Page</span></span><br><span class="line">    <span class="type">uint32_t</span> depth;               <span class="comment">// 当前 Page 在双向链表中的深度，从 0 开始</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     用于性能调试和监控。记录 AutoreleasePool 历史存储对象数量的最大值。</span></span><br><span class="line"><span class="comment">     目前的逻辑是当对象数量超过阈值(256)时，会触发日志记录，包含：</span></span><br><span class="line"><span class="comment">     - 当前线程信息</span></span><br><span class="line"><span class="comment">     - 对象存储数量</span></span><br><span class="line"><span class="comment">     - 完整调用栈</span></span><br><span class="line"><span class="comment">     这些信息有助于排查内存使用异常的情况。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint32_t</span> hiwat;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Page 大小固定为 4KB(4096字节)，与系统内存页大小对齐</span></span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> <span class="type">const</span> SIZE = <span class="number">1</span> &lt;&lt; <span class="number">12</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重写 new 操作符，确保分配的内存按 SIZE 对齐</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="type">void</span> *result = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">posix_memalign</span>(&amp;result, SIZE, SIZE);</span><br><span class="line">        <span class="built_in">ASSERT</span>(r == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更直观地理解 AutoreleasePoolPage 的内存结构，我绘制了一张简图：</p><p><img src="AutoreleasePoolPage%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><p>结合 AutoreleasePoolPage 的内部结构和前面分析的函数执行流程，我们可以更清晰地理解 AutoreleasePool 的底层实现。它本质上是一个普通的双向链表结构，其中每个节点都是一个 AutoreleasePoolPage 对象。这些对象通过 parent 和 child 指针相互连接，形成了一个完整的内存管理链条。每个 Page 不仅承担着节点的角色，还肩负着数据存储的重任，是整个自动释放池机制的核心载体。</p><p>在内存管理的层面上，AutoreleasePoolPage 的设计也体现了深思熟虑。通过查看其 new 方法的实现，我们可以看到每个 Page 的大小被设定为 4096 字节。这个看似随意的数字其实暗含玄机 - 它与现代操作系统的内存页大小完美对齐。这种设计带来了多重优势：</p><ul><li>减少内存碎片，提高内存利用效率；</li><li>实现更高效的内存分配；</li><li>确保内存访问的连续性，降低系统中断频率；</li><li>优化缓存命中率，提升整体性能。</li></ul><p>这些细节的优化，让 AutoreleasePool 在实现优雅的同时，也保持了极高的运行效率。</p><h3 id="autoreleasepool-的优雅之道"><a href="#autoreleasepool-的优雅之道" class="headerlink" title="@autoreleasepool 的优雅之道"></a>@autoreleasepool 的优雅之道</h3><p><code>@autoreleasepool &#123;&#125;</code> 是我们在项目中经常使用的另一个重要特性。这个看似简单的语法块背后，隐藏着编译器的巧妙转换和 Runtime 的精密配合。让我们揭开它的神秘面纱，一探其实现原理。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原代码：</span></span><br><span class="line">@autoreleasepool &#123;    </span><br><span class="line">__autoreleasing Person *per = [Person createPerson]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后：</span></span><br><span class="line">atautoreleasepoolobj = <span class="built_in">objc_autoreleasePoolPush</span>(); <span class="comment">// 对应 @autorelease &#123;</span></span><br><span class="line">__autoreleasing Person *per = [Person createPerson];</span><br><span class="line"><span class="built_in">objc_autoreleasePoolPop</span>(atautoreleasepoolobj); <span class="comment">// 对应 &#125;</span></span><br></pre></td></tr></table></figure><p>通过查看下面的汇编代码截图，我们可以清晰地看到编译器确实将 @autoreleasepool 语法块转换成了 objc_autoreleasePoolPush 和 objc_autoreleasePoolPop 的函数调用。这种转换不仅保证了代码的执行效率，还为开发者提供了一种优雅的内存管理方式：</p><p><img src="@autorelease%E5%8E%9F%E7%90%86.png"></p><p>让我们来看看 objc_autoreleasePoolPush 函数的内部实现。为了便于理解，我将相关代码进行了精简和整理：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * <span class="title">objc_autoreleasePoolPush</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::<span class="built_in">push</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">push</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ReturnAutoreleaseInfo info = <span class="built_in">getReturnAutoreleaseInfo</span>();</span><br><span class="line">    <span class="comment">// 将 TLS 中的对象转移至当前释放池。</span></span><br><span class="line">    <span class="built_in">moveTLSAutoreleaseToPool</span>(info);</span><br><span class="line">    <span class="comment">// 插入一个池边界。</span></span><br><span class="line">    id *dest = <span class="built_in">autoreleaseFast</span>(POOL_BOUNDARY);</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段逻辑非常简洁优雅：它通过调用 autoreleaseFast 函数，在当前的 AutoreleasePool 中插入一个边界标记（POOL_BOUNDARY）。这个边界标记就像是一个书签，标记着当前自动释放池的范围起点。</p><p>让我们继续探索 objc_autoreleasePoolPop 的实现细节。下面是经过精简的核心代码，我们将分步骤详细解析其工作原理（如果觉得代码太长可以先跳过，稍后我们会详细解释其工作原理）：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">objc_autoreleasePoolPop</span><span class="params">(<span class="type">void</span> *ctxt)</span> </span>&#123;</span><br><span class="line">    AutoreleasePoolPage::<span class="built_in">pop</span>(ctxt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">void</span> *token)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 清理 TLS 中的残留对象，确保其生命周期与当前池同步。</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">releaseReturnAutoreleaseTLS</span>());</span><br><span class="line">    </span><br><span class="line">    AutoreleasePoolPage *page;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// EMPTY_POOL_PLACEHOLDER 表示清空 Pool 中的所有对象。</span></span><br><span class="line">    <span class="keyword">if</span> (token == (<span class="type">void</span>*)EMPTY_POOL_PLACEHOLDER) &#123;</span><br><span class="line">        page = <span class="built_in">hotPage</span>();</span><br><span class="line">        <span class="keyword">if</span> (!page) &#123;</span><br><span class="line">            <span class="comment">// 从未使用的池直接清除占位符</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">setHotPage</span>(nil);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        获取 Pool 的起始页。内部逻辑如下：</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">        AutoreleasePoolPage *coldPage() &#123;</span></span><br><span class="line"><span class="comment">            // 先拿到尾节点。</span></span><br><span class="line"><span class="comment">            AutoreleasePoolPage *result = hotPage();</span></span><br><span class="line"><span class="comment">            if (result) &#123;</span></span><br><span class="line"><span class="comment">                // 不断获取链表中的前一个节点，直到第一个。</span></span><br><span class="line"><span class="comment">                while (result-&gt;parent) &#123;</span></span><br><span class="line"><span class="comment">                    result = result-&gt;parent;</span></span><br><span class="line"><span class="comment">                    result-&gt;fastcheck();</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            return result;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        page = <span class="built_in">coldPage</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 把 stop 设置为第一页的起点。</span></span><br><span class="line">        token = page-&gt;<span class="built_in">begin</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        page = <span class="built_in">pageForPointer</span>(token);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    id *stop = (id *)token;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     这段逻辑的意思是：</span></span><br><span class="line"><span class="comment">     如果 stop 不是池边界(POOL_BOUNDARY)就需要进行检查：</span></span><br><span class="line"><span class="comment">     如果 stop 是这一页的起点，并且这一页已经是第一页了。</span></span><br><span class="line"><span class="comment">     说明需要清理链表中的所有数据，这是正常情况。</span></span><br><span class="line"><span class="comment">     反之，这是不正常的，调用 badPop。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (*stop != POOL_BOUNDARY) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stop == page-&gt;<span class="built_in">begin</span>()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">badPop</span>(token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">popPage</span>(token, page, stop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">popPage</span><span class="params">(<span class="type">void</span> *token, AutoreleasePoolPage *page, id *stop)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     从尾部一直往前释放对象，直到遇到 stop。</span></span><br><span class="line"><span class="comment">     这一步执行完后，只是释放了 Page 内的数据，Page 对象并未销毁。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    page-&gt;<span class="built_in">releaseUntil</span>(stop);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     如果这一页的数据被删完了，就把这个 Page 对象释放掉，</span></span><br><span class="line"><span class="comment">     并把它的父 Page 设为 hotPage。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (page-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        AutoreleasePoolPage *parent = page-&gt;parent;</span><br><span class="line">        page-&gt;<span class="built_in">kill</span>();</span><br><span class="line">        <span class="built_in">setHotPage</span>(parent);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         如果当前 Page 上的数据小于 Page 总容量的一半，</span></span><br><span class="line"><span class="comment">         则把下一个 Page 释放掉（因为这个 Page 还能存很多数据，</span></span><br><span class="line"><span class="comment">         可能很久都用不到下一页）；</span></span><br><span class="line"><span class="comment">         反之，把下下一个 Page 释放掉（这一页快存满了，</span></span><br><span class="line"><span class="comment">         可能很快就要用到下一页了）。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (page-&gt;<span class="built_in">lessThanHalfFull</span>()) &#123;</span><br><span class="line">            page-&gt;child-&gt;<span class="built_in">kill</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child-&gt;child) &#123;</span><br><span class="line">            page-&gt;child-&gt;child-&gt;<span class="built_in">kill</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">releaseUntil</span><span class="params">(id *stop)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 从 next 开始，一直往前释放对象，直到遇到 stop。</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">this</span>-&gt;next != stop) &#123;</span><br><span class="line">            AutoreleasePoolPage *page = <span class="built_in">hotPage</span>();</span><br><span class="line">            <span class="comment">// 如果当前 Page 为空，则往前找父 Page。</span></span><br><span class="line">            <span class="keyword">while</span> (page-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                page = page-&gt;parent;</span><br><span class="line">                <span class="built_in">setHotPage</span>(page);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获取当前 Page 的最后一个对象。</span></span><br><span class="line">            AutoreleasePoolEntry* entry = (AutoreleasePoolEntry*) --page-&gt;next;</span><br><span class="line">            <span class="comment">// 获取对象。</span></span><br><span class="line">            id obj = (id)entry-&gt;<span class="built_in">getPointer</span>();</span><br><span class="line">            <span class="comment">// 获取对象的引用计数。</span></span><br><span class="line">            <span class="type">int</span> count = (<span class="type">int</span>)entry-&gt;<span class="built_in">getCount</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">            将原先存放数据的那块空间赋值为一个魔数 SCRIBBLE，</span></span><br><span class="line"><span class="comment">            这么做的目的是方便后期检查 Page 是否被破坏。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="built_in">memset</span>((<span class="type">void</span>*)page-&gt;next, SCRIBBLE, <span class="built_in">sizeof</span>(*page-&gt;next));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 obj 不是边界标记，则执行释放操作。</span></span><br><span class="line">            <span class="keyword">if</span> (obj != POOL_BOUNDARY) &#123;</span><br><span class="line">                <span class="comment">// 执行指定次数的释放操作。</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count + <span class="number">1</span>; i++) &#123;</span><br><span class="line">                    <span class="built_in">objc_release</span>(obj);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 清空 TLS 中的临时对象，确保它们和 Page 的生命周期是相同的。</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">releaseReturnAutoreleaseTLS</span>());</span><br><span class="line">    <span class="built_in">setHotPage</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放的逻辑稍微复杂一些，我们来梳理一下。当我们调用 pop 函数时，系统会按照以下流程进行对象的释放操作：</p><ol><li>首先，objc_autoreleasePoolPop 函数会被调用，它是整个释放流程的入口。</li><li>然后，pop 函数会被调用，它负责处理具体的释放逻辑。</li><li>接着，popPage 函数会被调用，它负责管理 Page 的释放。</li><li>最后，releaseUntil 函数会被调用，它负责执行实际的对象释放操作。</li></ol><p>完整的函数调用流程如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">objc_autoreleasePoolPop</span><br><span class="line">└── pop</span><br><span class="line">    └── popPage</span><br><span class="line">        └── releaseUntil</span><br></pre></td></tr></table></figure><p>在这些函数中，releaseUntil 和 popPage 扮演着尤为关键的角色：</p><p>releaseUntil 函数负责对象的具体释放工作。它会按照先进后出（LIFO）的顺序，将 Page 中的对象逐一释放。在这个过程中，它不仅要处理普通对象的释放，还要考虑对象合并优化带来的特殊情况，确保每个对象都能得到正确的释放次数。同时，它还会通过魔数（SCRIBBLE）标记已释放的内存空间，这么做的目的是方便后期进行内存完整性检查。</p><p>popPage 函数则专注于 Page 对象本身的管理和释放。它维护着 AutoreleasePool 的整体结构，确保当 Page 中所有的对象都被释放完后，Page 本身能够被正确地释放，从而保持整个池结构的高效运转。</p><p>通过上述分析，我们已经深入理解了 AutoreleasePool 的核心工作原理：系统通过精心设计的入池(Push)和出池(Pop)机制，在保证内存管理安全性的同时，也实现了极高的运行效率。这种双向链表结构不仅让对象的生命周期管理变得优雅，还通过诸如对象合并等优化手段提升了运行性能。</p><p>在掌握了这些底层实现细节后，我们将进一步探讨 AutoreleasePool 在多线程环境下的行为特征，以及在实际开发中的最佳实践方案。这些知识将帮助我们更好地驾驭这个强大的内存管理工具。</p><h2 id="线程与-AutoreleasePool：纠缠的双螺旋"><a href="#线程与-AutoreleasePool：纠缠的双螺旋" class="headerlink" title="线程与 AutoreleasePool：纠缠的双螺旋"></a>线程与 AutoreleasePool：纠缠的双螺旋</h2><p>AutoreleasePool 和线程是一一对应的关系，每个线程都拥有自己独立的 AutoreleasePool。从实现上看，它是一个由 AutoreleasePoolPage 对象组成的双向链表结构，线程通过 TLS (Thread Local Storage) 机制持有这个链表的尾节点（也就是 hotPage）。</p><p>关于 AutoreleasePool 的释放时机，这是一个经常被开发者讨论的话题。特别是被 __autoreleasing 修饰的对象，它们具体在什么时候被释放？</p><p>经过深入研究，我发现不同场景下对象的释放时机是不同的。让我们逐一分析：</p><p>场景一：主线程中的 autorelease 对象</p><ul><li>由 RunLoop 来管理释放时机</li><li>通常在当前任务执行完成后释放</li><li>具体时机可以通过下图来理解：</li></ul><p><img src="mainthread.png"></p><p>场景二：GCD 创建的子线程中的对象</p><ul><li>由于 GCD 采用线程池机制，线程可能会被复用</li><li>释放时机是在线程任务完成、即将被放回线程池时</li><li>通过下图可以看到具体流程：</li></ul><p><img src="gcd.png"></p><p>值得注意的是，_dispatch_worker_thread2 函数在处理线程任务时遵循这样的逻辑：从队列中获取并执行任务，当队列为空时让线程进入休眠状态。在进入休眠之前，会调用 _dispatch_last_resort_autorelease_pool_pop 来释放自动释放池中的对象。</p><p>场景三：通过 NSThread 等方式创建的非复用线程（无 RunLoop）</p><ul><li>对象会在线程销毁时被释放</li><li>释放过程如图所示：</li></ul><p><img src="pthread.png"></p><p>场景四：通过 NSThread 等方式创建的非复用线程（有 RunLoop）</p><ul><li>释放机制类似于主线程</li><li>在当前任务执行完成后释放</li><li>具体流程如下：</li></ul><p><img src="pthread_runloop.png"></p><p>场景四中使用的 NSThread 是我开发的一个开源库 <a href="https://github.com/internetWei/WXLThread">WXLThread</a>。这个库实现了一个优雅的常驻线程机制，并提供了简洁而强大的任务调度接口，让线程管理变得更加便捷和高效。</p><p>需要特别说明的是，这些释放时机并非固定不变。因为 autoreleasing 对象的释放本质上是由 pop 函数的调用时机决定的。随着系统版本的更新和优化，这些调用时序可能会发生变化。比如在早期版本中，系统是通过在 RunLoop 中注册 Observer 来处理释放操作的，释放时机是在线程即将进入休眠状态之前。</p><p>另外，如果对象被 <code>@autoreleasepool &#123;&#125;</code> 语法块包裹，那么它的释放时机就很明确了 - 就是在退出这个语法块作用域的时候。这提供了一种更精确的内存管理方式。</p><h2 id="性能优化：TLS-机制解析"><a href="#性能优化：TLS-机制解析" class="headerlink" title="性能优化：TLS 机制解析"></a>性能优化：TLS 机制解析</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">- (Person *)createPerson &#123;</span><br><span class="line">    Person *per = [[Person alloc] init];</span><br><span class="line">    <span class="keyword">return</span> per;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    Person *per = [self createPerson];</span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;%@&quot;</span>, per);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，如果没有任何优化，系统会在 return 之前对 per 调用 release 方法，这会导致对象过早释放。为了避免这种情况，编译器会在方法返回前将对象加入到自动释放池中，确保调用方能够正常使用这个对象。但这种方案存在一个问题：即使对象马上就会被调用方使用，也要经过「加入自动释放池 -&gt; 从自动释放池取出」这个过程，这无疑会带来一些性能开销。</p><p>为了解决这个问题，系统引入了基于 TLS (Thread Local Storage) 的返回值优化机制。具体来说：</p><ol><li>在返回对象的方法中，编译器会插入 <code>objc_autoreleaseReturnValue</code> 调用；</li><li>在接收返回值的地方，编译器会插入 <code>objc_retainAutoreleasedReturnValue</code> 调用；</li><li>这两个函数会配合工作：如果检测到它们的调用配对，就会把对象暂存在线程的 TLS 中，直接传递给调用方，完全跳过自动释放池的过程。</li></ol><p>这种优化极大地提升了返回对象的性能，尤其是在频繁方法调用的场景下。</p><p>通过调试查看汇编代码，我们可以清晰地看到这些优化函数的调用过程，当编译器检测到返回值优化的场景时，会跳过传统的自动释放池流程，直接通过 TLS 机制传递对象提升了性能。让我们通过下面的图来直观地体会这个优化过程：</p><table><thead><tr><th align="center"><img src="%E8%B0%83%E7%94%A8%E6%96%B9.png"></th></tr></thead><tbody><tr><td align="center">方法调用方</td></tr></tbody></table><table><thead><tr><th align="center"><img src="%E8%BF%94%E5%9B%9E%E6%96%B9.png"></th></tr></thead><tbody><tr><td align="center">方法返回方</td></tr></tbody></table><h2 id="常见误区与最佳实践"><a href="#常见误区与最佳实践" class="headerlink" title="常见误区与最佳实践"></a>常见误区与最佳实践</h2><p>在实际开发中，我们经常会遇到一些对 AutoreleasePool 使用的误区。其中最常见的就是在循环中过度使用 @autoreleasepool，例如：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Person *per = [[Person alloc] init];</span><br><span class="line">        <span class="comment">// 对 per 进行的操作……</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中的 per 对象是 __strong 类型，它会在每次循环结束时立即释放，无需等待自动释放池的清理。这种情况下添加 @autoreleasepool 并不会带来任何性能优势，反而会因为频繁创建和销毁自动释放池而增加开销。</p><p>因此，@autoreleasepool 的使用需要遵循以下原则：</p><ol><li><p>循环中创建了大量 autoreleasing 对象时才使用。这种情况下才能有效降低内存峰值，避免内存持续增长。</p></li><li><p>调用未知方法时需要谨慎评估。因为方法内部可能会创建 autoreleasing 对象，此时需要使用 @autoreleasepool 包裹，否则也会导致内存峰值过高。</p></li></ol><p>注意：错误的使用 @autoreleasepool 不仅不会带来性能优势，反而会因为频繁创建和销毁自动释放池而产生额外开销。所以在使用前，建议先分析代码中的对象创建情况，再决定是否需要手动管理自动释放池。</p><h2 id="技术总结"><a href="#技术总结" class="headerlink" title="技术总结"></a>技术总结</h2><p>通过对 AutoreleasePool 底层实现的深入分析，我们可以总结出以下几个关键点：</p><ol><li><p>底层数据结构</p><ul><li>AutoreleasePool 本质是由 AutoreleasePoolPage 对象组成的双向链表；</li><li>每个 Page 目前的大小为 4KB，按系统内存页对齐以优化性能；</li><li>每个线程的 TLS 中存储着链表的尾节点（hotPage）；</li><li>Page 中除了存储对象指针外，还包含 magic、next、thread 等重要信息。</li></ul></li><li><p>对象管理机制</p><ul><li><p>添加对象时，系统首先获取 hotPage，根据其状态执行不同逻辑：</p><ul><li>Page 存在且未满：直接添加对象</li><li>Page 存在但已满：创建新 Page 后添加</li><li>Page 不存在：创建首个 Page 后添加</li></ul></li><li><p>清理时，系统会从链表末尾往前遍历，逐个释放对象直到遇到指定的边界标记（POOL_BOUNDARY）。</p></li></ul></li><li><p>性能优化方案</p><ul><li>对象合并优化：相同对象重复入池时，通过 count 计数避免重复存储；</li><li>TLS 返回值优化：方法返回对象时，通过 TLS 机制避免自动释放池的中转；</li><li>内存对齐：Page 大小与系统页对齐，提高内存访问效率；</li><li>双向链表：支持快速的正向和反向遍历，适应不同的使用场景。</li></ul></li></ol><p>这些精妙的设计不仅保证了 AutoreleasePool 的正确性，还在性能和内存使用效率上都做到了极致的优化。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://suhou.github.io/2018/01/21/%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E7%9C%8B%E6%BA%90%E7%A0%81----%E5%AD%90%E7%BA%BF%E7%A8%8BAutoRelease%E5%AF%B9%E8%B1%A1%E4%BD%95%E6%97%B6%E9%87%8A%E6%94%BE/">子线程AutoRelease对象何时释放 | su</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024 再探ObjC-Category：动态特性与运行时实现的极致之美</title>
      <link href="/2024/12/11/iOS/2024%20%E5%86%8D%E6%8E%A2ObjC-Category%EF%BC%9A%E5%8A%A8%E6%80%81%E7%89%B9%E6%80%A7%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%9E%81%E8%87%B4%E4%B9%8B%E7%BE%8E/"/>
      <url>/2024/12/11/iOS/2024%20%E5%86%8D%E6%8E%A2ObjC-Category%EF%BC%9A%E5%8A%A8%E6%80%81%E7%89%B9%E6%80%A7%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%9E%81%E8%87%B4%E4%B9%8B%E7%BE%8E/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由 布多(budo) 发布于 2024-12-11 • 最后更新于2025-02-26</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Category 是 ObjC 中一个基础且重要的概念。本文将从 Runtime 源码入手，向你介绍 Category 的概念以及底层的实现原理。</p><h2 id="Category-概念"><a href="#Category-概念" class="headerlink" title="Category 概念"></a>Category 概念</h2><p>Category 主要是用来给已存在的类动态添加方法实现，也可扩展协议和属性。基于此特性，我们可以用 Category 实现如下功能：</p><ul><li><p>将一个庞大的类分解成多个 Category，每个 Category 只完成少量的任务，从而提高模块化和代码解耦程度。</p></li><li><p>在不继承的情况下给已有类动态的添加新方法。</p></li><li><p>模拟多继承，比如让已有类支持新协议。</p></li></ul><h2 id="Category-之编译期实现细节"><a href="#Category-之编译期实现细节" class="headerlink" title="Category 之编译期实现细节"></a>Category 之编译期实现细节</h2><p>创建一个 ObjC 源代码文件并将其命名为 <code>test_category.m</code>，然后在文件内输入如下代码：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">WXLCategory</span>)&lt;<span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> () <span class="built_in">NSInteger</span> wxl_ist_prot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>) <span class="built_in">NSInteger</span> wxl_cls_prot;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)wxl_ist_func;</span><br><span class="line">+ (<span class="type">void</span>)wxl_cls_func;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">WXLExtension</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)wxl_ist_func &#123;&#125;</span><br><span class="line">+ (<span class="type">void</span>)wxl_cls_func &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><blockquote><p>这里我特意只写了方法的实现，而没有写属性和协议的实现，后面会解释为什么。</p></blockquote><p>使用 <code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc test_category.m</code> 命令可以将上述代码编译为 C++ 文件，代码精简后如下所示：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">category_t</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">class_t</span> *cls;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">method_list_t</span> *instance_methods;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">method_list_t</span> *class_methods;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">protocol_list_t</span> *protocols;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">prop_list_t</span> *instanceProperties;</span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">prop_list_t</span> *_classProperties;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">category_t</span> _OBJC_$_CATEGORY_NSObject_$_WXLCategory </span><br><span class="line">__attribute__ ((used, <span class="built_in">section</span> (<span class="string">&quot;__DATA, __objc_const&quot;</span>))) = </span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;NSObject&quot;</span>,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">(<span class="type">const</span> <span class="keyword">struct</span> <span class="type">method_list_t</span> *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_NSObject_$_WXLCategory,</span><br><span class="line">(<span class="type">const</span> <span class="keyword">struct</span> <span class="type">method_list_t</span> *)&amp;_OBJC_$_CATEGORY_CLASS_METHODS_NSObject_$_WXLCategory,</span><br><span class="line">(<span class="type">const</span> <span class="keyword">struct</span> <span class="type">protocol_list_t</span> *)&amp;_OBJC_CATEGORY_PROTOCOLS_$_NSObject_$_WXLCategory,</span><br><span class="line">(<span class="type">const</span> <span class="keyword">struct</span> <span class="type">prop_list_t</span> *)&amp;_OBJC_$_INSTANCE_PROP_LIST_NSObject_$_WXLCategory,</span><br><span class="line">(<span class="type">const</span> <span class="keyword">struct</span> <span class="type">prop_list_t</span> *)&amp;_OBJC_$_CLASS_PROP_LIST_NSObject_$_WXLCategory,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><code>_classProperties</code> 变量是我参考 Runtime 源码后手动加上的，你编译的代码可能会没有。</p></blockquote><p>从编译后的代码中不难看出，一个 Category 对象，其底层其实就是1个 <code>category_t</code> 的结构体对象，这个结构体中包含了实例属性、类属性、实例方法、类方法以及协议等变量用来保存分类中的相关数据。</p><p>最后，编译器会把 <code>category_t</code> 相关数据保存在 Mach-O 文件的 objc_const 数据段下，等待运行时解析。</p><h2 id="Category-之运行时实现细节：探索内部实现原理"><a href="#Category-之运行时实现细节：探索内部实现原理" class="headerlink" title="Category 之运行时实现细节：探索内部实现原理"></a>Category 之运行时实现细节：探索内部实现原理</h2><p>相关代码整理后如下所示（代码有点长，不想看可以跳过，后面有解释）：</p><blockquote><p>本文使用的 Runtime 版本是 <a href="https://github.com/apple-oss-distributions/objc4/tree/objc4-928.2">objc4-928.2</a>，为了方便阅读，我对代码样式和排版略作了修改以及删减了一些不影响主逻辑的冗余代码。</p><p>我在 <a href="https://github.com/internetWei/ObjCRuntimes">这里</a> 维护了一个可以直接运行调试的 Runtime 项目，方便大家直接调试源码。</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">load_images</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> _dyld_objc_notify_mapped_info* info)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查该模块是否有 +load 方法的实现。</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">hasLoadMethods</span>((<span class="type">const</span> headerType *)info-&gt;mh,</span><br><span class="line">                        info-&gt;sectionLocationMetadata)) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加载所有分类。</span></span><br><span class="line">    <span class="built_in">loadAllCategoriesIfNeeded</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> didInitialAttachCategories = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loadAllCategoriesIfNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 控制不要重复加载分类数据，每加载一个模块时都可能会来到这里。</span></span><br><span class="line">    <span class="keyword">if</span> (!didInitialAttachCategories) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         遍历所有模块并加载它们的分类数据。</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">         注意：在加载第1个模块时就会执行该函数，</span></span><br><span class="line"><span class="comment">         这意味着在加载第1个模块时就会把所有模块中的分类数据都加载，</span></span><br><span class="line"><span class="comment">         而不是只加载当前模块中的分类数据。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> *hi = FirstHeader; hi != <span class="literal">NULL</span>; hi = hi-&gt;<span class="built_in">getNext</span>()) &#123;</span><br><span class="line">            <span class="built_in">load_categories_nolock</span>(hi);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        didInitialAttachCategories = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">load_categories_nolock</span><span class="params">(header_info *hi)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前模块是否有分类类属性。</span></span><br><span class="line">    <span class="type">bool</span> hasClassProperties = hi-&gt;<span class="built_in">info</span>()-&gt;<span class="built_in">hasCategoryClassProperties</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="type">size_t</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历当前模块中的所有分类数据并进行处理。</span></span><br><span class="line">    <span class="keyword">auto</span> processCatlist = [&amp;](<span class="type">category_t</span> * <span class="type">const</span> *catlist) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="type">category_t</span> *cat = catlist[i];</span><br><span class="line">            Class cls = <span class="built_in">remapClass</span>(cat-&gt;cls);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 把 cat、cls、hi 包装一下，方便后面调用函数时传参。</span></span><br><span class="line">            <span class="type">locstamped_category_t</span> lc&#123;cat, cls, hi&#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 检查这个分类中是否有实例方法、协议、实例属性。</span></span><br><span class="line">            <span class="keyword">if</span> (cat-&gt;instanceMethods ||</span><br><span class="line">                cat-&gt;protocols ||</span><br><span class="line">                cat-&gt;instanceProperties) &#123;</span><br><span class="line">                <span class="comment">// 检查 cls 是否已实现，</span></span><br><span class="line">                <span class="keyword">if</span> (cls-&gt;<span class="built_in">isRealized</span>()) &#123;</span><br><span class="line">                    <span class="comment">// 将分类中的实例方法、协议、实例属性添加到 cls 上。</span></span><br><span class="line">                    <span class="built_in">attachCategories</span>(cls, &amp;lc, <span class="number">1</span>, cls, ATTACH_EXISTING);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 将分类数据和类对象保存起来，等类对象实现后再进行加载。</span></span><br><span class="line">                    objc::unattachedCategories.<span class="built_in">addForClass</span>(lc, cls);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             检查这个分类中是否有类方法、协议、类属性。</span></span><br><span class="line"><span class="comment">             </span></span><br><span class="line"><span class="comment">             注意 `(hasClassProperties &amp;&amp; cat-&gt;_classProperties)` 这段代码，</span></span><br><span class="line"><span class="comment">             可能是因为使用类属性的项目非常少，所以加入了这一个判断。</span></span><br><span class="line"><span class="comment">             </span></span><br><span class="line"><span class="comment">             这里是在给元类对象添加方法和属性，但是，元类对象是没有协议的。不清楚这</span></span><br><span class="line"><span class="comment">             里为什么要判断 `cat-&gt;protocols`。</span></span><br><span class="line"><span class="comment">             </span></span><br><span class="line"><span class="comment">             另外，在后面获取分类的协议列表时也有判断，如果是给元类添加的话就直接返回 </span></span><br><span class="line"><span class="comment">             NULL。感觉这段代码其实可以删掉，不知道是否有其它隐情？</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (cat-&gt;classMethods ||</span><br><span class="line">                cat-&gt;protocols ||</span><br><span class="line">                (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cls-&gt;<span class="built_in">ISA</span>()-&gt;<span class="built_in">isRealized</span>()) &#123;</span><br><span class="line">                    <span class="comment">// 将分类中的类方法、类属性加载到元类上。</span></span><br><span class="line">                    <span class="built_in">attachCategories</span>(cls-&gt;<span class="built_in">ISA</span>(), &amp;lc, <span class="number">1</span>, cls, </span><br><span class="line">                    ATTACH_EXISTING | ATTACH_METACLASS);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 将分类数据和元类对象保存起来，等元类对象实现后再进行加载。</span></span><br><span class="line">                    objc::unattachedCategories.<span class="built_in">addForClass</span>(</span><br><span class="line">                    lc.<span class="built_in">reSignedForMetaclass</span>(cls), </span><br><span class="line">                    cls-&gt;<span class="built_in">ISA</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">processCatlist</span>(hi-&gt;<span class="built_in">catlist</span>(&amp;count));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> cls: 需要把分类数据添加到哪个类上。</span></span><br><span class="line"><span class="comment"> 如果添加的是实例方法、实例属性、协议，这个参数就是类对象；</span></span><br><span class="line"><span class="comment"> 如果添加的是类方法、类属性，这个参数就是元类对象。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> cats_list: 需要被添加的分类数据，注意这是一个数组。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> catsListKey: 分类所属的类对象。</span></span><br><span class="line"><span class="comment"> 不管添加的是实例方法还是类方法，始终指向该分类所属的类对象，不会是元类对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">attachCategories</span><span class="params">(Class cls,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">const</span> <span class="type">locstamped_category_t</span> *cats_list,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">uint32_t</span> cats_count,</span></span></span><br><span class="line"><span class="params"><span class="function">                 Class catsListKey,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">uint32_t</span> ATTACH_BUFSIZ = <span class="number">64</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     一个临时的缓存结构。分类中的方法、属性、协议会被临时添加到这个缓存对象中去，</span></span><br><span class="line"><span class="comment">     当缓存容量满了，或者分类中的数据加载完了，再一次性添加到类中去。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Lists</span> &#123;</span><br><span class="line">        ReversedFixedSizeArray&lt;<span class="type">method_list_t</span> *, ATTACH_BUFSIZ&gt; methods;</span><br><span class="line">        ReversedFixedSizeArray&lt;<span class="type">property_list_t</span> *, ATTACH_BUFSIZ&gt; properties;</span><br><span class="line">        ReversedFixedSizeArray&lt;<span class="type">protocol_list_t</span> *, ATTACH_BUFSIZ&gt; protocols;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    Lists normalLists;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> isMeta = (flags &amp; ATTACH_METACLASS);</span><br><span class="line">    <span class="keyword">auto</span> rwe = cls-&gt;<span class="built_in">data</span>()-&gt;<span class="built_in">extAllocIfNeeded</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; cats_count; i++) &#123;</span><br><span class="line">        <span class="comment">// entry 的原型：locstamped_category_t &#123;cat, cls, hi&#125;</span></span><br><span class="line">        <span class="keyword">auto</span>&amp; entry = cats_list[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取分类中的方法列表。</span></span><br><span class="line">        <span class="type">method_list_t</span> *mlist = entry.<span class="built_in">getCategory</span>(catsListKey)-&gt;<span class="built_in">methodsForMeta</span>(isMeta);</span><br><span class="line">        Lists *lists = &amp;normalLists;</span><br><span class="line">        <span class="type">bool</span> isPreattached = </span><br><span class="line">        entry.hi-&gt;<span class="built_in">info</span>()-&gt;<span class="built_in">dyldCategoriesOptimized</span>() &amp;&amp; !DisablePreattachedCategories;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lists-&gt;methods.<span class="built_in">isFull</span>()) &#123;</span><br><span class="line">                <span class="comment">// 将缓存中的方法全部添加到类/元类中。</span></span><br><span class="line">                rwe-&gt;methods.<span class="built_in">attachLists</span>(lists-&gt;methods.array, </span><br><span class="line">                lists-&gt;methods.count, </span><br><span class="line">                isPreattached, </span><br><span class="line">                PrintPreopt ? <span class="string">&quot;methods&quot;</span> : <span class="literal">nullptr</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 清空缓存。</span></span><br><span class="line">                lists-&gt;methods.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将分类中的方法添加到缓存。</span></span><br><span class="line">            lists-&gt;methods.<span class="built_in">add</span>(mlist);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取分类中的属性列表。</span></span><br><span class="line">        <span class="type">property_list_t</span> *proplist =</span><br><span class="line">        entry.<span class="built_in">getCategory</span>(catsListKey)-&gt;<span class="built_in">propertiesForMeta</span>(isMeta, entry.hi);</span><br><span class="line">        <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lists-&gt;properties.<span class="built_in">isFull</span>()) &#123;</span><br><span class="line">                <span class="comment">// 将缓存中的属性全部添加到类/元类中。</span></span><br><span class="line">                rwe-&gt;properties.<span class="built_in">attachLists</span>(lists-&gt;properties.array, </span><br><span class="line">                lists-&gt;properties.count, </span><br><span class="line">                isPreattached, </span><br><span class="line">                PrintPreopt ? <span class="string">&quot;properties&quot;</span> : <span class="literal">nullptr</span>);</span><br><span class="line">                </span><br><span class="line">                lists-&gt;properties.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将分类中的属性添加到缓存。</span></span><br><span class="line">            lists-&gt;properties.<span class="built_in">add</span>(proplist);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取分类中的协议列表，内部会通过 isMeta 判断如果是元类就返回 NULL。</span></span><br><span class="line">        <span class="type">protocol_list_t</span> *protolist = </span><br><span class="line">        entry.<span class="built_in">getCategory</span>(catsListKey)-&gt;<span class="built_in">protocolsForMeta</span>(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lists-&gt;protocols.<span class="built_in">isFull</span>()) &#123;</span><br><span class="line">                <span class="comment">// 将缓存中的协议全部添加到类/元类中。</span></span><br><span class="line">                rwe-&gt;protocols.<span class="built_in">attachLists</span>(lists-&gt;protocols.array, </span><br><span class="line">                lists-&gt;protocols.count, </span><br><span class="line">                isPreattached, </span><br><span class="line">                PrintPreopt ? <span class="string">&quot;protocols&quot;</span> : <span class="literal">nullptr</span>);</span><br><span class="line">                </span><br><span class="line">                lists-&gt;protocols.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将分类中的协议添加到缓存。</span></span><br><span class="line">            lists-&gt;protocols.<span class="built_in">add</span>(protolist);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将缓存里的方法、属性、协议全部添加到类/元类中。</span></span><br><span class="line">    <span class="keyword">auto</span> attach = [&amp;](Lists *lists, <span class="type">bool</span> isPreattached) &#123;</span><br><span class="line">        <span class="comment">// 将缓存里的方法添加到类/元类中。</span></span><br><span class="line">        rwe-&gt;methods.<span class="built_in">attachLists</span>(lists-&gt;methods.<span class="built_in">begin</span>(), </span><br><span class="line">        lists-&gt;methods.count, </span><br><span class="line">        isPreattached, </span><br><span class="line">        PrintPreopt ? <span class="string">&quot;methods&quot;</span> : <span class="literal">nullptr</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将缓存里的属性添加到类/元类中。</span></span><br><span class="line">        rwe-&gt;properties.<span class="built_in">attachLists</span>(lists-&gt;properties.<span class="built_in">begin</span>(), </span><br><span class="line">        lists-&gt;properties.count, </span><br><span class="line">        isPreattached, </span><br><span class="line">        PrintPreopt ? <span class="string">&quot;properties&quot;</span> : <span class="literal">nullptr</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将缓存里的协议添加到类中。</span></span><br><span class="line">        rwe-&gt;protocols.<span class="built_in">attachLists</span>(lists-&gt;protocols.<span class="built_in">begin</span>(), </span><br><span class="line">        lists-&gt;protocols.count, </span><br><span class="line">        isPreattached, </span><br><span class="line">        PrintPreopt ? <span class="string">&quot;protocols&quot;</span> : <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">attach</span>(&amp;normalLists, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 这个函数的作用是把方法、属性、协议添加到类/元类中，</span></span><br><span class="line"><span class="comment"> 不一定是添加分类中的数据，也有可能是添加类自身的数据。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">attachLists</span><span class="params">(List* <span class="type">const</span> * addedLists,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">uint32_t</span> addedCount,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">bool</span> preoptimized,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">const</span> <span class="type">char</span> *logKind)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个分支通常是用来添加类自身的方法、属性、协议。</span></span><br><span class="line">    <span class="keyword">if</span> (storage.<span class="built_in">isNull</span>() &amp;&amp; addedCount == <span class="number">1</span>) &#123;</span><br><span class="line">        storage.<span class="built_in">set</span>(*addedLists);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这个分支通常是用来处理第1个分类的数据。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (storage.<span class="built_in">isNull</span>() || storage.<span class="keyword">template</span> <span class="built_in">is</span>&lt;List *&gt;()) &#123;</span><br><span class="line">        <span class="comment">// 0 or 1 list -&gt; many lists</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取旧数据。</span></span><br><span class="line">        List *oldList = storage.<span class="keyword">template</span> <span class="built_in">dyn_cast</span>&lt;List *&gt;();</span><br><span class="line">        <span class="type">uint32_t</span> oldCount = oldList ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="type">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 开辟一个新数组，足以容纳旧数据加上分类中的新数据。</span></span><br><span class="line">        <span class="type">array_t</span> *array = (<span class="type">array_t</span> *)<span class="built_in">malloc</span>(<span class="type">array_t</span>::<span class="built_in">byteSize</span>(newCount));</span><br><span class="line">        storage.<span class="built_in">set</span>(array);</span><br><span class="line">        array-&gt;count = newCount;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         将类中原来的数据（方法、属性、协议）放到数组最后面。</span></span><br><span class="line"><span class="comment">         这一步保证了类自身的数据永远处于列表的最后面。         </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (oldList) array-&gt;lists[addedCount] = oldList;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将分类中的数据插入到数组的前面。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; addedCount; i++)</span><br><span class="line">            array-&gt;lists[i] = addedLists[i];</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 这个分支通常是用来加载第2个及之后的分类数据。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="type">array_t</span> *array = storage.<span class="keyword">template</span> <span class="built_in">dyn_cast</span>&lt;<span class="type">array_t</span> *&gt;()) &#123;</span><br><span class="line">        <span class="comment">// many lists -&gt; many lists</span></span><br><span class="line">        <span class="type">uint32_t</span> oldCount = array-&gt;count;</span><br><span class="line">        <span class="type">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">        <span class="type">array_t</span> *newArray = (<span class="type">array_t</span> *)<span class="built_in">malloc</span>(<span class="type">array_t</span>::<span class="built_in">byteSize</span>(newCount));</span><br><span class="line">        newArray-&gt;count = newCount;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 把旧数据按照之前的顺序放到新数组的最后面。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = oldCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            newArray-&gt;lists[i + addedCount] = array-&gt;lists[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         将分类数据依次添加到数组的前面，</span></span><br><span class="line"><span class="comment">         这一步操作会导致最后编译的分类数据将会被添加在数组的最前面。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; addedCount; i++)</span><br><span class="line">            newArray-&gt;lists[i] = addedLists[i];</span><br><span class="line">            </span><br><span class="line">        <span class="built_in">free</span>(array);</span><br><span class="line">        storage.<span class="built_in">set</span>(newArray);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         一般情况下不会来到这个分支，</span></span><br><span class="line"><span class="comment">         在之前的函数 load_categories_nolock 中有这样一行代码：</span></span><br><span class="line"><span class="comment">         `objc::unattachedCategories.addForClass(lc, cls);`</span></span><br><span class="line"><span class="comment">         这个分支就是用来处理这种情况。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">auto</span> *listList = storage.<span class="keyword">template</span> dyn_cast&lt;<span class="type">relative_list_list_t</span>&lt;List&gt; *&gt;()) &#123;</span><br><span class="line">        <span class="comment">// list-of-lists -&gt; many lists</span></span><br><span class="line">        <span class="keyword">auto</span> listListBegin = listList-&gt;<span class="built_in">beginLists</span>();</span><br><span class="line">        <span class="type">uint32_t</span> oldCount = listList-&gt;<span class="built_in">countLists</span>();</span><br><span class="line">        <span class="type">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">        <span class="type">array_t</span> *newArray = (<span class="type">array_t</span> *)<span class="built_in">malloc</span>(<span class="type">array_t</span>::<span class="built_in">byteSize</span>(newCount));</span><br><span class="line">        newArray-&gt;count = newCount;</span><br><span class="line">        </span><br><span class="line">        <span class="type">uint32_t</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; addedCount; i++) &#123;</span><br><span class="line">            newArray-&gt;lists[i] = addedLists[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (; i &lt; newCount; i++) &#123;</span><br><span class="line">            newArray-&gt;lists[i] = *listListBegin;</span><br><span class="line">            ++listListBegin;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        storage.<span class="built_in">set</span>(newArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中不难发现，Category 中的数据（方法、属性、协议）都是在运行时通过 Runtime 动态添加到类中一个叫做 rwe 的对象中。</p><p>在 rwe 这个对象中拥有三个变量，分别是：方法列表、属性列表、协议列表，这个变量其实就是一个二维数组。以方法列表为例，类自身的所有方法是一个数组，每个 Category 中的所有方法是一个数组，它们都被放在这个二维数组中，注意，类自身的方法列表放在这个二维数组的最后面，最后编译的那个 Category 中的方法列表放在这个二维数组的最前面。</p><p>正是因为这个特点才导致了 Category 中的方法实现会覆盖与类本身同名的方法实现。所以，在开发过程中我们经常会看到很多框架都会给 Category 的方法和属性添加前缀，其目的就是为了降低重名的可能性。</p><p>有些人说 Category 不支持添加实例变量是因为 <code>category_t</code> 结构体中没有 <code>ivars</code> 字段。其实并不是添加一个字段的事，根本原因是因为开发者可能会用 Category 给已经编译好的类（例如系统类）添加数据，而这些类的内存布局与地址已经固定死了，如果要给它添加实例变量势必要修改其内存布局与地址。</p><p>另外，也不能给 Category 添加 weak 属性，如果一定要添加 weak 属性的话，可以采用中间者模式，即给 Category 添加一个中间者对象，然后给这个中间类声明一个 weak 属性。关于 weak 指针的更多细节请看我的另一篇文章 <a href="/2023/10/21/iOS/%E6%8F%AD%E5%BC%80%20iOS%20%E4%B8%AD%20weak%20%E6%8C%87%E9%92%88%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1%EF%BC%9A%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5/" title="揭开 iOS 中 weak 指针的神秘面纱：从原理到实践">揭开 iOS 中 weak 指针的神秘面纱：从原理到实践</a></p><p>我在网上看到有些人说为什么要把 Category 设计成使用 Runtime 运行时加载，直接设计成编译时加载不是更好吗？他们的想法是：“在给项目中某个类（这个类是在项目中创建的），例如 CustomClass 创建分类时，编译器其实能拿到 CustomClass 的实现文件，那么只要把分类中的方法和这个类自身的方法合并不就行了，这样还能实现在 Category 中给这个类添加实例变量。” 乍一看没啥问题。但是，Category 还支持给已经编译好的类（例如系统类）添加方法实现，而这些类的布局和地址已经固定死了，因而不能这么干。</p><p>在阅读源码的过程中，我还发现了一些其它问题：</p><ol><li><p>在前面的 <code>test_category.m</code> 文件中，我特意没有在实现中写上属性和协议的实现。因为经过我的调试发现，Runtime 在解析 Category 中的属性和协议时，只看声明并不看实现，只要有属性、协议声明，不管有没有实现都会被添加到类的属性列表和协议列表中。但是在解析方法的时候是反过来的，只会把有方法实现的那些方法添加到方法列表中。</p></li><li><p>在第1个函数 load_images 中有这么一个判断：如果该模块中没有 <code>+load</code> 方法实现就不添加 Category 数据。我查阅了许多资料，但是都没有找到可信的证据解释为什么要这样做？如果你知道为什么的话还请留言告知。</p></li><li><p>Runtime 会在 <code>loadAllCategoriesIfNeeded</code> 函数内一次性加载所有模块中的分类数据，而不是遍历一个模块加载一个模块中的分类数据。我想了一下，这么做有以下好处：降低程序的复杂度和提高性能。如果是遍历一个模块加载一个模块的数据，那就不能只使用一个全局变量 <code>didInitialAttachCategories</code> 来标记分类数据是否已加载？可能要维护一个字典，例如 key 是模块名称，value 表示该模块是否已加载分类。这么做显然比维护一个全局变量成本更高。</p></li></ol><h2 id="Category-与-Extension-的区别"><a href="#Category-与-Extension-的区别" class="headerlink" title="Category 与 Extension 的区别"></a>Category 与 Extension 的区别</h2><p>经常有人把 Category 和 Extension 拿到一起来说，可能是因为它们的声明方式有点像吧，以下是 Category 和 Extension 的声明代码：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Category 声明</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> (<span class="title">CategoryName</span>) @<span class="title">end</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Extension 声明</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> () @<span class="title">end</span></span></span><br></pre></td></tr></table></figure><p>从代码来看，Category 似乎只多了一个 name 而已。所以导致很多人以为它们的底层实现可能差不多，但其实它们的实现压根不一样。</p><h3 id="Extension-的特点"><a href="#Extension-的特点" class="headerlink" title="Extension 的特点"></a>Extension 的特点</h3><p>从功能和底层实现上来看，其实 Extension 和 Interface(类声明) 更像一些，Interface 能干的事，它基本上都能干，除了不能指定父类。</p><p>Interface 一般是用来对外提供接口数据，但有时候我们会想把一些属性、方法、实例变量隐藏起来。Extension 就是专门用来干这个的，因为 Interface 只能有一个，但 Extension 可以有多个。Extension 和类声明都是编译特性，你可以在 Extension 中声明实例变量、属性、方法、协议，这和在 Interface 中写本质上是一样的。</p><blockquote><p>需要注意一点，虽然在 Extension 中可以声明实例变量，但仅在拥有 implementation 实现的这个文件中这么做才可以，例如以下代码就可以，因为这个文件中拥有 Book 的实现：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Book</span> () </span>&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *_name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Book</span></span></span><br><span class="line">- (<span class="type">void</span>)testFun &#123;</span><br><span class="line">    _name = <span class="string">@&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, _name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>例如下面的代码就不行，因为这个文件中没有 Book 类的实现，此时你会得到一个编译错误：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Book</span> () </span>&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *_name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Book</span> (<span class="title">CategoryName</span>)</span></span><br><span class="line">- (<span class="type">void</span>)testFun &#123;</span><br><span class="line">    _name = <span class="string">@&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, _name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></blockquote><p>另外，虽然在任何地方都能使用 Extension，但是和上面的实例变量一样，如果需要编译器自动生成实现代码（例如属性），那就不能在 implementation 之外的文件使用，切记！！！</p><p>Extension 还有一个好用的功能就是声明私有方法，这样就能在后面的代码中直接调用这个方法了，而不是写成这样：<code>[self performSelector:@selector(testFun)]</code>，网上有很多人是使用 Category 干这个事，其实 Extension 也可以，个人感觉这样更优雅。</p><h3 id="Category-的特点"><a href="#Category-的特点" class="headerlink" title="Category 的特点"></a>Category 的特点</h3><p>与 Extension 相比，Category 是编译器加上 Runtime 共同完成的。编译器负责将 Category 编译成 <code>category_t</code> 对象，然后添加到 Mach-O 文件中。Runtime 负责在运行时将 <code>category_t</code> 中的数据解析并添加到对应的类中。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从苹果提供的源码中我们不难发现，其实 Category 的底层实现并不复杂，其本质就是将 Category 转化成一个结构体用来保存相关数据（属性、方法、协议），然后通过 Runtime 在运行时将这个结构体中的数据解析出来并且添加到类中。而这个类对象内部有一个二维数组来存储每个分类中的数据。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ObjC </tag>
            
            <tag> Runtime </tag>
            
            <tag> Category </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入解析 iOS-RunLoop：事件驱动的核心机制</title>
      <link href="/2024/04/28/iOS/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%20iOS-RunLoop%EF%BC%9A%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/"/>
      <url>/2024/04/28/iOS/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%20iOS-RunLoop%EF%BC%9A%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由 布多(budo) 发布于 2024-04-28 • 最后更新于 2025-03-21</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>RunLoop 是 iOS 开发中的一个基础概念，苹果有许多功能都依赖于 RunLoop，例如线程中的自动释放池、NSTimer、系统事件响应、屏幕刷新等。本文将深入剖析 iOS 中 RunLoop 的内部实现细节，帮助你更好地理解这一机制。</p><h2 id="什么是-Even-Loop"><a href="#什么是-Even-Loop" class="headerlink" title="什么是 Even Loop"></a>什么是 Even Loop</h2><p>在讨论 RunLoop 之前，先了解一下线程的基本概念。通常，线程执行完一个任务后就会退出，要重新执行任务只能再创建一个新线程。但如果我们希望线程在处理完任务后不退出，而是等待并处理新的任务，就需要一种机制来保持线程的活动状态，这就是 <a href="https://en.wikipedia.org/wiki/Event_loop">Even Loop</a>（事件循环）。</p><p>在 iOS 中，这个机制由 RunLoop 实现。它是一个持续运行的循环，负责管理线程中的事件和消息，确保线程在没有任务时进入休眠状态，在有任务时被唤醒并处理。</p><h2 id="RunLoop-的工作原理"><a href="#RunLoop-的工作原理" class="headerlink" title="RunLoop 的工作原理"></a>RunLoop 的工作原理</h2><p>RunLoop 本质上是一个对象，它管理需要处理的事件。线程启动 RunLoop 后，会一直处理「接受消息 -&gt; 处理消息 -&gt; 等待消息」的循环中，实现逻辑大致如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">startRunLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var message = <span class="built_in">get_next_message</span>();</span><br><span class="line">        <span class="built_in">process_message</span>(message);</span><br><span class="line">    &#125; <span class="keyword">while</span> (message != quit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RunLoop-的实现细节"><a href="#RunLoop-的实现细节" class="headerlink" title="RunLoop 的实现细节"></a>RunLoop 的实现细节</h2><p>在 iOS 中，RunLoop 通过两个对象提供：NSRunLoop 和 CFRunLoopRef。其中，NSRunLoop 是 CFRunLoopRef 的封装，提供了面向对象的 API。</p><p>RunLoop 被包含在开源项目 <a href="https://github.com/apple-oss-distributions/CF">Core Foundation</a> 中，你可以下载查看。</p><blockquote><p>本文使用的 Core Foundation 版本是 <a href="https://github.com/apple-oss-distributions/CF/releases/tag/CF-1153.18">CF-1153.18</a>，为了方便阅读，我对代码样式和排版略作了修改以及删减了一些不影响主逻辑的冗余代码。</p></blockquote><h3 id="RunLoop-入口"><a href="#RunLoop-入口" class="headerlink" title="RunLoop 入口"></a>RunLoop 入口</h3><p>首先看看 CFRunLoopRun 和 CFRunLoopRunInMode 的实现，这两个函数负责启动 RunLoop：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用默认 Mode 启动。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CFRunLoopRun</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int32_t</span> result;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        result = <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- modeName: 指定要使用的 Mode。</span></span><br><span class="line"><span class="comment">- seconds: 设置 RunLoop 的超时时间。</span></span><br><span class="line"><span class="comment">- returnAfterSourceHandled: 如果是YES，则运行完后立即返回。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">SInt32 <span class="title">CFRunLoopRunInMode</span><span class="params">(CFStringRef modeName,</span></span></span><br><span class="line"><span class="params"><span class="function">                          CFTimeInterval seconds,</span></span></span><br><span class="line"><span class="params"><span class="function">                          Boolean returnAfterSourceHandled)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(),</span><br><span class="line">                                modeName,</span><br><span class="line">                                seconds,</span><br><span class="line">                                returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用 <code>CFRunLoopRunSpecific</code>，RunLoop 会进入具体的模式进行运行，直到满足退出的条件。</p><p>接下来的关键函数是 CFRunLoopRunSpecific，它会获取指定的 Mode，然后进入 RunLoop，相关代码整理后如下所示：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">SInt32 <span class="title">CFRunLoopRunSpecific</span><span class="params">(CFRunLoopRef rl,</span></span></span><br><span class="line"><span class="params"><span class="function">                            CFStringRef modeName,</span></span></span><br><span class="line"><span class="params"><span class="function">                            CFTimeInterval seconds,</span></span></span><br><span class="line"><span class="params"><span class="function">                            Boolean returnAfterSourceHandled)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取对应 Mode。</span></span><br><span class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果当前 Mode 下没有任何事件，立即返回。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == currentMode ||</span><br><span class="line">        __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) &#123;</span><br><span class="line">        <span class="keyword">return</span> kCFRunLoopRunFinished;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把 Loop 当前的数据临时保存起来。</span></span><br><span class="line">    <span class="keyword">volatile</span> _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl);</span><br><span class="line">    CFRunLoopModeRef previousMode = rl-&gt;_currentMode;</span><br><span class="line">    rl-&gt;_currentMode = currentMode;</span><br><span class="line">    <span class="type">int32_t</span> result = kCFRunLoopRunFinished;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通知 Observer，即将进入 Loop。</span></span><br><span class="line">    <span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry) &#123;</span><br><span class="line">        __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进入 RunLoop。</span></span><br><span class="line">result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通知 Observer，即将退出 Loop。</span></span><br><span class="line">    <span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopExit) &#123;</span><br><span class="line">        __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复之前保存的临时数据。</span></span><br><span class="line">    __CFRunLoopPopPerRunData(rl, previousPerRun);</span><br><span class="line">    <span class="comment">// 把 Mode 恢复成之前的 Mode。</span></span><br><span class="line">    rl-&gt;_currentMode = previousMode;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RunLoop-核心"><a href="#RunLoop-核心" class="headerlink" title="RunLoop 核心"></a>RunLoop 核心</h3><p>在 <code>__CFRunLoopRun</code> 中，RunLoop 会进入 do while 循环，不断检查并处理事件，直到满足退出条件（超时、手动停止等）。核心的实现依赖于 <code>mach_msg</code> 函数，系统会调用这个函数将线程置于休眠状态，等待消息的到来，每当有事件（例如来自 <code>mach_port</code> 的消息或定时器触发）时，RunLoop 会被唤醒处理相关事件。相关代码整理后如下所示（函数有点长，不想看可以跳过，后面有解释）：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int32_t</span> __CFRunLoopRun(CFRunLoopRef rl,</span><br><span class="line">                              CFRunLoopModeRef rlm,</span><br><span class="line">                              CFTimeInterval seconds,</span><br><span class="line">                              Boolean stopAfterHandle,</span><br><span class="line">                              CFRunLoopModeRef previousMode) &#123;</span><br><span class="line">    <span class="type">uint64_t</span> startTSR = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line">    <span class="type">mach_port_name_t</span> dispatchPort = MACH_PORT_NULL;</span><br><span class="line">    </span><br><span class="line">    <span class="type">dispatch_source_t</span> timeout_timer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">__timeout_context</span> *timeout_context = (<span class="keyword">struct</span> __timeout_context *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(*timeout_context));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (seconds &lt;= <span class="number">0.0</span>) &#123;</span><br><span class="line">        timeout_context-&gt;termTSR = <span class="number">0ULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123;</span><br><span class="line">        <span class="comment">// ... 对 timeout_timer 和 timeout_context 的初始化及其它操作。</span></span><br><span class="line">        <span class="comment">// 感兴趣的同学可以自行阅读源码。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置 RunLoop 的目标超时时间，比如当前是第 10 秒，</span></span><br><span class="line">        <span class="comment">// 超时时间是 100 秒，那目标超时时间就是第 110 秒。</span></span><br><span class="line">        timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注册 RunLoop 超时回调。</span></span><br><span class="line">        <span class="built_in">dispatch_source_set_event_handler_f</span>(timeout_timer, __CFRunLoopTimeout);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        timeout_context-&gt;termTSR = UINT64_MAX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Boolean didDispatchPortLastTime = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int32_t</span> retVal = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进入 RunLoop</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">voucher_mach_msg_state_t</span> voucherState = VOUCHER_MACH_MSG_STATE_UNCHANGED;</span><br><span class="line">        <span class="type">voucher_t</span> voucherCopy = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">uint8_t</span> msg_buffer[<span class="number">3</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="type">mach_msg_header_t</span> *msg = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">mach_port_t</span> livePort = MACH_PORT_NULL;</span><br><span class="line">        __CFPortSet waitSet = rlm-&gt;_portSet;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知 Observer，即将处理 Timer。</span></span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) &#123;</span><br><span class="line">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知 Observer，即将处理 Source。</span></span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) &#123;</span><br><span class="line">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用户可能会在 observer 中添加 Block，</span></span><br><span class="line">        <span class="comment">// 这里需要处理它们。</span></span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行 Source0 事件。</span></span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 同理，用户可能在 Source 中添加 Block。</span></span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果有 Source1 事件，则处理它然后跳到 handle_msg 去处理消息。</span></span><br><span class="line">        <span class="keyword">if</span> (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;</span><br><span class="line">            msg = (<span class="type">mach_msg_header_t</span> *)msg_buffer;</span><br><span class="line">            <span class="keyword">if</span> (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, <span class="built_in">sizeof</span>(msg_buffer), &amp;livePort, <span class="number">0</span>, &amp;voucherState, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">                <span class="keyword">goto</span> handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        didDispatchPortLastTime = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知 Observer，即将进入休眠。</span></span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting) &#123;</span><br><span class="line">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        msg = (<span class="type">mach_msg_header_t</span> *)msg_buffer;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         线程进入休眠，并监听 mach port 消息。</span></span><br><span class="line"><span class="comment">         直到被下面的某个事件唤醒：</span></span><br><span class="line"><span class="comment">         1. 基于 port 的 Source 事件。</span></span><br><span class="line"><span class="comment">         2. Timer 事件。</span></span><br><span class="line"><span class="comment">         3. RunLoop 的超时时间到了。</span></span><br><span class="line"><span class="comment">         4. 被其它调用者手动唤醒。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="built_in">sizeof</span>(msg_buffer), &amp;livePort, TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知 Observer，从休眠中唤醒。</span></span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting) &#123;</span><br><span class="line">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理消息：</span></span><br><span class="line">        handle_msg:;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理通过 Timer 唤醒的事件。</span></span><br><span class="line">        <span class="keyword">if</span> (livePort == rlm-&gt;_timerPort) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!__CFRunLoopDoTimers(rl, rlm, <span class="built_in">mach_absolute_time</span>())) &#123;</span><br><span class="line">                <span class="comment">// Re-arm the next timer</span></span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理通过 GCD 唤醒的事件，例如 dispatch 到 main_queue 的 block。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (livePort == dispatchPort) &#123;</span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            sourceHandledThisLoop = <span class="literal">true</span>;</span><br><span class="line">            didDispatchPortLastTime = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理通过 Source1 唤醒的事件。</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</span><br><span class="line">            <span class="keyword">if</span> (rls) &#123;</span><br><span class="line">                <span class="type">mach_msg_header_t</span> *reply = <span class="literal">NULL</span>;</span><br><span class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">NULL</span> != reply) &#123;</span><br><span class="line">                    (<span class="type">void</span>)<span class="built_in">mach_msg</span>(reply, MACH_SEND_MSG, reply-&gt;msgh_size, <span class="number">0</span>, MACH_PORT_NULL, <span class="number">0</span>, MACH_PORT_NULL);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行添加到 Loop 中的 Block。</span></span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         进入 Loop 时设置了 stopAfterHandle 为 YES，</span></span><br><span class="line"><span class="comment">         意思是处理完事件就返回。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// RunLoop 运行超时了。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timeout_context-&gt;termTSR &lt; <span class="built_in">mach_absolute_time</span>()) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// RunLoop 被外部强行停止了。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunStopped;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前运行的 Mode 被停止了。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</span><br><span class="line">            rlm-&gt;_stopped = <span class="literal">false</span>;</span><br><span class="line">            retVal = kCFRunLoopRunStopped;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Mode 里没有要处理的事件了。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunFinished;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果参数没说运行完就结束、没超时、Loop 没被停止、Mode 没被停止、Mode 不为空；则继续。</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span> == retVal);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中不难发现，RunLoop 内部其实就是一个 <code>do while</code> 循环，当线程启动 RunLoop 后，就会一直处于这个循环里，有任务时就处理任务，每次处理完 Source1 任务后都会判断一下是否满足退出条件（超时、强行停止、任务列表为空等），如果不满足就进入下一轮。</p><p>RunLoop 的核心实现依赖于 <code>mach_msg()</code>，这个函数在 <code>__CFRunLoopServiceMachPort</code> 内部调用。RunLoop 调用 <code>mach_msg()</code> 之后，内核就会将线程置于休眠状态，直到有 port 发送消息或定时器触发。</p><p>你可以使用 Xcode 运行一个 iOS 项目，然后在 APP 静止时点击暂停，此时你会看到主线程调用栈停留在一个叫做 <code>mach_msg2_trap()</code> 的函数中。</p><p>我画了一个 RunLoop 运行流程图，请参考下图：</p><p><img src="runloop0.png" alt="RunLoop 运行流程图"></p><h2 id="RunLoop-与-RunLoopMode"><a href="#RunLoop-与-RunLoopMode" class="headerlink" title="RunLoop 与 RunLoopMode"></a>RunLoop 与 RunLoopMode</h2><p>一个 RunLoop 可能会包含多个 Mode，每个 Mode 又可能包含若干个 Source、Timer、Observer。相关代码整理后如下所示：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">__CFRunLoop</span> *CFRunLoopRef;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RunLoop 的底层结构。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__CFRunLoop</span> &#123;</span><br><span class="line">    CFMutableSetRef _commonModes;</span><br><span class="line">    CFMutableSetRef _commonModeItems;</span><br><span class="line">    CFRunLoopModeRef _currentMode;</span><br><span class="line">    CFMutableSetRef _modes;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">__CFRunLoopMode</span> *CFRunLoopModeRef;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RunLoopMode 的底层结构。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__CFRunLoopMode</span> &#123;</span><br><span class="line">    CFStringRef _name;<span class="comment">// Mode 的名称。</span></span><br><span class="line">    CFMutableSetRef _sources0;<span class="comment">// 包含所有 Source0，一个 Set。</span></span><br><span class="line">    CFMutableSetRef _sources1;<span class="comment">// 包含所有 Source1，一个 Set。</span></span><br><span class="line">    CFMutableArrayRef _observers;<span class="comment">// 包含所有 Observer，一个 Array。</span></span><br><span class="line">    CFMutableArrayRef _timers;<span class="comment">// 包含所有 Timer，一个 Array。</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>RunLoop 与 Mode 的关系如下图所示：</p><p><img src="runLoop1.png" alt="RunLoop 与 Mode 的关系"></p><p>RunLoop 每次只能指定一个 Mode 运行，这个 Mode 被称为 currentMode。如果需要切换 Mode，只能退出 Loop，然后重新指定 Mode 运行。这样做的目的是为了将不同的 Source、Timer、Observer 分隔开，避免它们相互干扰。</p><p>Mode 内部有以下三种类型的事件：</p><p><strong>CFRunLoopSourceRef</strong> 表示所有 source0 和 source1 事件。</p><ul><li>source0 只包含一个函数指针回调，它不能主动触发事件，只能先调用 <code>CFRunLoopSourceSignal(source)</code> 将这个 Source 标记为待处理，然后调用 <code>CFRunLoopWakeUp(runloop)</code> 唤醒 RunLoop 去处理被标记的事件。</li><li>source1 是 mach port 发出的事件，被用于通过内核和其它进程相互发送消息，这种事件可以主动唤醒 RunLoop。</li></ul><p><strong>CFRunLoopTimerRef</strong> 是一个定时器事件，它和 NSTimer 是免费桥接的，当它被加入到 RunLoop 后，RunLoop 会在对应的时间点注册事件，当时间点到达时 Loop 会被唤醒并处理这个事件。</p><p><strong>CFRunLoopObserverRef</strong> 是一个观察者事件，当 RunLoop 的状态发生变化时，开发者可以通过注册 Observer 来响应这些变化，可以观察的状态有以下 6 个：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1UL</span> &lt;&lt; <span class="number">0</span>), <span class="comment">// 即将进入 Loop。</span></span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1UL</span> &lt;&lt; <span class="number">1</span>), <span class="comment">// 即将处理 Timer。</span></span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1UL</span> &lt;&lt; <span class="number">2</span>), <span class="comment">// 即将处理 Source。</span></span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">5</span>), <span class="comment">// 即将进入休眠。</span></span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">6</span>), <span class="comment">// 从休眠中唤醒。</span></span><br><span class="line">    kCFRunLoopExit = (<span class="number">1UL</span> &lt;&lt; <span class="number">7</span>), <span class="comment">// 即将退出 Loop。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上的 Source、Timer、Observer 统称为 mode item，一个 item 不能重复加入同一个 Mode，但是可以同时加入多个 mode 中，另外，如果 mode 里没有 item，则 RunLoop 会直接退出，不会进入到循环中。</p><h2 id="关于-CommonModes"><a href="#关于-CommonModes" class="headerlink" title="关于 CommonModes"></a>关于 CommonModes</h2><p>CommonModes 是一个特殊的概念，其允许一个事件同时在多个 Mode 中触发。通过 <code>CFRunLoopAddCommonMode</code> 函数，可以将某个 Mode 标记为 “Common” 模式，这样该模式下的事件就会自动同步到其它 Mode 中去。例如，我们可以在 <code>CFRunLoopAddCommonMode</code> 中添加一个定时器，这样它就能同时在多个模式下运行。</p><p>相关实现代码精简后如下所示（不想看可以跳过，后面有解释）：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CFRunLoopAddObserver</span><span class="params">(CFRunLoopRef rl, CFRunLoopObserverRef rlo, CFStringRef modeName)</span> </span>&#123;</span><br><span class="line">    CFRunLoopModeRef rlm;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (modeName == kCFRunLoopCommonModes) &#123;</span><br><span class="line">        CFSetRef set = rl-&gt;_commonModes ? <span class="built_in">CFSetCreateCopy</span>(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == rl-&gt;_commonModeItems) &#123;</span><br><span class="line">            rl-&gt;_commonModeItems = <span class="built_in">CFSetCreateMutable</span>(kCFAllocatorSystemDefault, <span class="number">0</span>, &amp;kCFTypeSetCallBacks);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">CFSetAddValue</span>(rl-&gt;_commonModeItems, rlo);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != set) &#123;</span><br><span class="line">            CFTypeRef context[<span class="number">2</span>] = &#123;rl, rlo&#125;;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             这里会遍历 rl-&gt;_commonModes 中的所有 Mode，</span></span><br><span class="line"><span class="comment">             然后执行 __CFRunLoopAddItemToCommonModes，</span></span><br><span class="line"><span class="comment">             把事件添加到每个具体的 Mode 中去。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">CFSetApplyFunction</span>(set, (__CFRunLoopAddItemToCommonModes), (<span class="type">void</span> *)context);</span><br><span class="line">            <span class="built_in">CFRelease</span>(set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 非 NSRunLoopCommonModes 的处理逻辑。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CFRunLoopAddCommonMode</span><span class="params">(CFRunLoopRef rl, CFStringRef modeName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">CFSetContainsValue</span>(rl-&gt;_commonModes, modeName)) &#123;</span><br><span class="line">        CFSetRef set = rl-&gt;_commonModeItems ? <span class="built_in">CFSetCreateCopy</span>(kCFAllocatorSystemDefault, rl-&gt;_commonModeItems) : <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">CFSetAddValue</span>(rl-&gt;_commonModes, modeName);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != set) &#123;</span><br><span class="line">            CFTypeRef context[<span class="number">2</span>] = &#123;rl, modeName&#125;;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             把 modeName 对应 Mode 中的所有事件，</span></span><br><span class="line"><span class="comment">             同步到 rl-&gt;_commonModeItems 的所有 Mode 中去。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">CFSetApplyFunction</span>(set, (__CFRunLoopAddItemsToCommonMode), (<span class="type">void</span> *)context);</span><br><span class="line">            <span class="built_in">CFRelease</span>(set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面提到的 CFRunLoopAddObserver 函数，还有两个函数和它类似：CFRunLoopAddTimer 和 CFRunLoopAddSource，它们的内部实现原理基本一致，所以我只介绍了 CFRunLoopAddObserver。</p><p>当你往 NSRunLoopCommonModes 中添加一个事件时，系统会拿到 _commonModes 并遍历其每个 Mode，然后为其添加这个事件。</p><p>当你调用 CFRunLoopAddCommonMode 将某个 Mode 标记为 “Common” 模式时，系统会取出这个 Mode 中的所有事件，然后遍历 _commonModes 并给每个 Mode 添加这些事件。</p><h2 id="RunLoop-与线程的关系"><a href="#RunLoop-与线程的关系" class="headerlink" title="RunLoop 与线程的关系"></a>RunLoop 与线程的关系</h2><p>每个线程都有自己独立的 RunLoop，iOS 不允许我们创建 RunLoop，但提供了两个函数来获取当前线程和主线程的 RunLoop：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取主线程中的 RunLoop。</span></span><br><span class="line"><span class="function">CFRunLoopRef <span class="title">CFRunLoopGetMain</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> CFRunLoopRef __main = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!__main) __main = _CFRunLoopGet0(<span class="built_in">pthread_main_thread_np</span>());</span><br><span class="line">    <span class="keyword">return</span> __main;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前线程的 RunLoop。</span></span><br><span class="line"><span class="function">CFRunLoopRef <span class="title">CFRunLoopGetCurrent</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从当前线程的局部存储中获取 RunLoop 对象。</span></span><br><span class="line">    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);</span><br><span class="line">    <span class="keyword">if</span> (rl) <span class="keyword">return</span> rl;</span><br><span class="line">    <span class="keyword">return</span> _CFRunLoopGet0(<span class="built_in">pthread_self</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局 Dict，key 是线程，value 是 RunLoop。</span></span><br><span class="line"><span class="type">static</span> CFMutableDictionaryRef __CFRunLoops = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(<span class="type">pthread_t</span> t) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     第 1 次获取 RunLoop 对象时，</span></span><br><span class="line"><span class="comment">     自动创建全局 Dict 和主线程的 RunLoop。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!__CFRunLoops) &#123;</span><br><span class="line">        CFMutableDictionaryRef dict = <span class="built_in">CFDictionaryCreateMutable</span>(kCFAllocatorSystemDefault, <span class="number">0</span>,</span><br><span class="line">                                      <span class="literal">NULL</span>, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">        CFRunLoopRef mainLoop = __CFRunLoopCreate(<span class="built_in">pthread_main_thread_np</span>());</span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(dict, <span class="built_in">pthreadPointer</span>(<span class="built_in">pthread_main_thread_np</span>()), mainLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    CFRunLoopRef loop = (CFRunLoopRef)<span class="built_in">CFDictionaryGetValue</span>(__CFRunLoops, <span class="built_in">pthreadPointer</span>(t));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">        <span class="comment">// 如果当前线程还没有 RunLoop，创建一个新的。</span></span><br><span class="line">        CFRunLoopRef newLoop = __CFRunLoopCreate(t);</span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(__CFRunLoops, <span class="built_in">pthreadPointer</span>(t), newLoop);</span><br><span class="line">        loop = newLoop;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_equal</span>(t, <span class="built_in">pthread_self</span>())) &#123;</span><br><span class="line">        _CFSetTSD(__CFTSDKeyRunLoop, (<span class="type">void</span> *)loop, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</span><br><span class="line">            <span class="comment">// 注册一个回调，当线程销毁时，顺便销毁其对应的 RunLoop。</span></span><br><span class="line">            _CFSetTSD(__CFTSDKeyRunLoopCntr, </span><br><span class="line">            (<span class="type">void</span> *)(PTHREAD_DESTRUCTOR_ITERATIONS<span class="number">-1</span>), </span><br><span class="line">            (<span class="built_in">void</span> (*)(<span class="type">void</span> *))__CFFinalizeRunLoop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中不难发现，线程和 RunLoop 的关系是一一对应的，其关系保存在一个全局字典中。另外，iOS 会为每个线程懒加载 RunLoop 对象，并在线程销毁时自动释放它。</p><p>我们只能获取当前线程的 RunLoop 对象（主线程的 RunLoop 除外）。</p><h2 id="苹果利用-RunLoop-实现的功能"><a href="#苹果利用-RunLoop-实现的功能" class="headerlink" title="苹果利用 RunLoop 实现的功能"></a>苹果利用 RunLoop 实现的功能</h2><h3 id="AutoreleasePool-与-RunLoop"><a href="#AutoreleasePool-与-RunLoop" class="headerlink" title="AutoreleasePool 与 RunLoop"></a>AutoreleasePool 与 RunLoop</h3><p>网络上有一些这方面相关的旧文章，他们会告诉你：iOS 在 APP 启动后会往主线程的 RunLoop 里注册多个 Observer，用来监听以下三种状态：</p><p>即将进入 RunLoop：创建 AutoreleasePool。</p><p>RunLoop 准备休眠：释放之前创建的 AutoreleasePool，然后创建一个新的 AutoreleasePool。</p><p>RunLoop 即将退出：释放之前创建的 AutoreleasePool。</p><p>但是，根据我的调试发现，新的 RunLoop 已经不是上述逻辑了。系统会在每个任务的执行前后自动插入相关代码来实现 AutoreleasePool 的创建和释放操作，而不是等到线程休眠前才释放。</p><p>关于 AutoreleasePool 的更多细节，请阅读我写的另一篇文章：<a href="/2025/03/30/iOS/AutoreleasePool%EF%BC%9AiOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%90%E7%AB%A0%E4%B8%AD%E7%9A%84%E9%9A%90%E7%A7%98%E6%97%8B%E5%BE%8B/" title="AutoreleasePool：iOS 内存管理乐章中的隐秘旋律">AutoreleasePool：iOS 内存管理乐章中的隐秘旋律</a></p><h3 id="NSTimer-与-RunLoop"><a href="#NSTimer-与-RunLoop" class="headerlink" title="NSTimer 与 RunLoop"></a>NSTimer 与 RunLoop</h3><p>iOS 中的 NSTimer 和 RunLoop 中的 CFRunLoopTimerRef 是免费桥接的。当你添加一个 Timer 到 RunLoop 时，系统会自动在下一个时间点注册事件，同时，为了节省资源，RunLoop 并不会在非常准确的时间点回调 Timer，Timer 有个属性叫 tolerance，表示当时间点到达后，容许有多少误差。</p><p>如果某个时间点错过了，比如我创建了一个 1 秒执行一次的 Timer，但 RunLoop 执行了一段逻辑消耗了 5 秒，此时，RunLoop 会在第 6 秒的时候回调 Timer，执行这一次事件以及上一次的事件。测试结果如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">16</span>:<span class="number">46</span>:<span class="number">19</span>: 定时器<span class="number">1</span></span><br><span class="line"><span class="number">16</span>:<span class="number">46</span>:<span class="number">20</span>: 定时器<span class="number">2</span></span><br><span class="line"><span class="comment">// 执行了耗时逻辑，消耗了 5 秒。</span></span><br><span class="line"><span class="number">16</span>:<span class="number">46</span>:<span class="number">26</span>: 定时器<span class="number">3</span></span><br><span class="line"><span class="number">16</span>:<span class="number">46</span>:<span class="number">26</span>: 定时器<span class="number">4</span></span><br><span class="line"><span class="number">16</span>:<span class="number">46</span>:<span class="number">27</span>: 定时器<span class="number">5</span></span><br><span class="line"><span class="number">16</span>:<span class="number">46</span>:<span class="number">28</span>: 定时器<span class="number">6</span></span><br></pre></td></tr></table></figure><p>注意 “定时器3” 和 “定时器4” 这两个事件，它们的执行时间都是第 26 秒，其中 “定时器3” 本来是第 21 秒应该执行的事件，但是那个时间点 RunLoop 没空，所以它被推迟到了第 26 秒和 “定时器4” 这个事件一起执行并输出。从这个方面也能看出来，当 RunLoop 繁忙的时候，NSTimer 可能会出现调用不及时的现象。</p><h3 id="PerformSelector-与-RunLoop"><a href="#PerformSelector-与-RunLoop" class="headerlink" title="PerformSelector 与 RunLoop"></a>PerformSelector 与 RunLoop</h3><p>当你调用 NSObject 的 <code>performSelecter:afterDelay:</code> 后，系统会自动创建一个 NSTimer 并添加到当前线程的 RunLoop 中。如果当前线程没有 RunLoop 的话，则这个方法就会失效（子线程默认没有 RunLoop）。</p><p>注意，调用 <code>performSelector:onThread:</code> 时，系统也会自动创建一个 NSTimer，所以，如果对应线程没有 RunLoop 的话该方法也会失效。</p><h3 id="GCD-与-RunLoop"><a href="#GCD-与-RunLoop" class="headerlink" title="GCD 与 RunLoop"></a>GCD 与 RunLoop</h3><p>GCD 和 RunLoop 一般情况下都没有交集，但是当你在子线程调用了 <code>dispatch_async(dispatch_get_main_queue(), block)</code> 时，GCD 会向主线程的 RunLoop 发送消息，此时主线程的 RunLoop 会被唤醒调用 <code>__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()</code> 来处理这个事件。需要注意的是，只有从子线程回到主线程才会使用 RunLoop 处理，从子线程A到子线程B是不会使用目标线程的 RunLoop 来处理的。</p><h2 id="我们能利用-RunLoop-干什么"><a href="#我们能利用-RunLoop-干什么" class="headerlink" title="我们能利用 RunLoop 干什么"></a>我们能利用 RunLoop 干什么</h2><h3 id="APP-卡顿监控"><a href="#APP-卡顿监控" class="headerlink" title="APP 卡顿监控"></a>APP 卡顿监控</h3><p>其实现原理是往主线程的 RunLoop 中注册一个 Observer 监听所有状态，然后在回调中开启一个子线程用来判断主线程是否发生了卡顿，判断的逻辑大致是，如果 RunLoop 在某些状态下持续时间过长（一般是 60 ms），则判定为卡顿。如果你想了解更多细节，请查看我写的这个项目：<a href="https://github.com/internetWei/WXLLagMonitoring">WXLLagMonitoring</a>。</p><h3 id="线程保活"><a href="#线程保活" class="headerlink" title="线程保活"></a>线程保活</h3><p>有时候我们可能需要频繁的在子线程中执行一些代码逻辑，如果每次执行都开启一个新线程，可能会带来一些不必要的性能损耗。如果我们能让这个子线程像主线程一样，有任务的时候处理任务，没任务的时候就休眠就好了。如果你想了解更多实现细节，请查看我写的这个项目：<a href="https://github.com/internetWei/WXLThread">WXLThread</a>。</p><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>比如，你可以将多次操作合并成一次操作。其逻辑大致是监听 RunLoop 即将进入休眠的状态，在休眠之前将所有操作合并成一次操作，系统的界面刷新就是这个原理，你在更新 UI 视图后，系统并不会立马更新，而是在 RunLoop 休眠之前将这些更新操作合并成一次更新。</p><p>有个框架 FDTemplateLayoutCell 就用到了 RunLoop，它会在 NSDefaultRunLoopMode 模式下注册一个 Observer 并观察即将休眠的状态，在回调中会执行预加载逻辑。</p><h2 id="RunLoop-相关疑惑"><a href="#RunLoop-相关疑惑" class="headerlink" title="RunLoop 相关疑惑"></a>RunLoop 相关疑惑</h2><h3 id="CommonModes-中的任务是如何同步的？"><a href="#CommonModes-中的任务是如何同步的？" class="headerlink" title="CommonModes 中的任务是如何同步的？"></a>CommonModes 中的任务是如何同步的？</h3><p>当你执行这样一行代码：<code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]</code> 时，系统是如何让 timer 同时在 NSDefaultRunLoopMode 和 UITrackingRunLoopMode 中运行的？</p><p>网络上有些这方面相关的旧文章，他们可能会告诉你：timer 会被添加到 RunLoop 的 _commonModeItems 中，然后在每次进入 Loop 的时候，系统会检查当前 Mode 是否属于 “Common” 模式，如果属于的话，就遍历 _commonModeItems 中的任务并添加到当前 Mode 中去。</p><p>这种说法在当时是否准确我不太清楚，但在如今的 RunLoop 里是错误的，其原因我已经在 <a href="#%E5%85%B3%E4%BA%8E-CommonModes">关于 CommonModes</a> 中详细解释了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>iOS 中的 RunLoop 本质上就是一个对象，这个对象内部有一个属性 Mode，Mode 里保存了要执行的所有事件。当线程启动 RunLoop 后，其内部就会开启一个 <code>do while</code> 循环。如果有任务就会从 Mode 中取出并处理，任务执行完后就会进入休眠状态，进入休眠的原理是调用了 <code>mach_msg</code> 函数。除非满足退出条件（超时、强行停止、无事件了等），否则就会进入下一轮循环。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop | Garan no dou</a></li><li><a href="https://juejin.cn/post/7005112607707398157">iOS 的响应链小结 | 掘金</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RunLoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>揭开 iOS 中 weak 指针的神秘面纱：从原理到实践</title>
      <link href="/2023/10/21/iOS/%E6%8F%AD%E5%BC%80%20iOS%20%E4%B8%AD%20weak%20%E6%8C%87%E9%92%88%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1%EF%BC%9A%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5/"/>
      <url>/2023/10/21/iOS/%E6%8F%AD%E5%BC%80%20iOS%20%E4%B8%AD%20weak%20%E6%8C%87%E9%92%88%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1%EF%BC%9A%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由 布多(budo) 发布于 2023-10-21 • 最后更新于 2025-02-26</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>weak 指针是 iOS 开发中一个非常基础的概念，在开发过程中我们经常使用它，它到底是怎么实现的？这篇文章将从 Runtime 源码入手，为你介绍 weak 指针的实现原理；让你知其然，更知其所以然。</p><h2 id="weak-指针之编译期实现"><a href="#weak-指针之编译期实现" class="headerlink" title="weak 指针之编译期实现"></a>weak 指针之编译期实现</h2><p>当我们初始化一个 weak 指针时： <code>__weak typeof(obj) weakObj = obj;</code>，编译器其实会把它们转换成类似这样的代码：<code>objc_initWeak((void *)&amp;weakObj, obj);</code></p><p><img src="entrance.png" alt="weak 指针的初始化入口"></p><p>从上图的断点中我们也可以发现，weak 指针调用了 <code>objc_initWeak</code> 函数来完成初始化。在 Runtime 源码中我们可以找到 <code>objc_initWeak</code> 相关的实现细节。</p><blockquote><p>本文使用的 Runtime 版本是 <a href="https://github.com/apple-oss-distributions/objc4/tree/objc4-906">objc4-906</a>，为了方便阅读，我对代码样式和排版略作了修改以及删减了一些不影响主逻辑的冗余代码。</p><p>我在 <a href="https://github.com/internetWei/ObjCRuntimes">这里</a> 维护了一个可以直接运行调试的 Runtime 项目，方便大家直接调试源码。</p></blockquote><h2 id="weak-指针之运行时实现"><a href="#weak-指针之运行时实现" class="headerlink" title="weak 指针之运行时实现"></a>weak 指针之运行时实现</h2><p>与 weak 指针初始化相关的函数有以下 4 个：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化一个全新的 weak 指针。</span></span><br><span class="line"><span class="function">id <span class="title">objc_initWeak</span><span class="params">(id *location, id newObj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!newObj) &#123;</span><br><span class="line">        *location = nil;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">storeWeak</span>&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;(location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和前面的 objc_initWeak 一样，</span></span><br><span class="line"><span class="comment">// 但是，如果指向的对象（即 newObj）正在释放的话不要报错而是返回 nil。</span></span><br><span class="line"><span class="function">id <span class="title">objc_initWeakOrNil</span><span class="params">(id *location, id newObj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!newObj) &#123;</span><br><span class="line">        *location = nil;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">storeWeak</span>&lt;DontHaveOld, DoHaveNew, DontCrashIfDeallocating&gt;(location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放 weak 指针当前指向的对象，并将它指向新对象（即 newObj）。</span></span><br><span class="line"><span class="function">id <span class="title">objc_storeWeak</span><span class="params">(id *location, id newObj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">storeWeak</span>&lt;DoHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;(location, (objc_object *)newObj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和 objc_storeWeak 一样。</span></span><br><span class="line"><span class="comment">// 但是，如果指向的对象（即 newObj）正在释放的话不要报错而是返回 nil。</span></span><br><span class="line"><span class="function">id <span class="title">objc_initWeakOrNil</span><span class="params">(id *location, id newObj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!newObj) &#123;</span><br><span class="line">        *location = nil;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">storeWeak</span>&lt;DontHaveOld, DoHaveNew, DontCrashIfDeallocating&gt;(location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于函数 objc_initWeak 和 objc_storeWeak 的区别：</p><ul><li><p><code>objc_initWeak</code>：用来初始化一个全新的 weak 指针。例如以下场景：</p>  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *obj = ...;</span><br><span class="line">__<span class="keyword">weak</span> <span class="type">id</span> weakPtr = obj;<span class="comment">// 在初始化的时候就指向了对象。</span></span><br></pre></td></tr></table></figure></li><li><p><code>objc_storeWeak</code>：当 weak 指针被赋值的时候调用。例如以下场景：</p>  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *obj = ...;</span><br><span class="line">__<span class="keyword">weak</span> <span class="type">id</span> weakPtr;</span><br><span class="line">weakPtr = obj;<span class="comment">// 先初始化，后赋值。</span></span><br></pre></td></tr></table></figure></li></ul><p>从以上 4 个初始化函数不难发现，它们最终都调用了同一个函数 <code>storeWeak</code>，区别就是传递给函数的模板参数略有不同。</p><h3 id="weak-指针的初始化细节：storeWeak"><a href="#weak-指针的初始化细节：storeWeak" class="headerlink" title="weak 指针的初始化细节：storeWeak"></a>weak 指针的初始化细节：storeWeak</h3><p><code>storeWeak</code> 函数的相关代码整理后如下所示：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">HaveOld</span> &#123; DontHaveOld = <span class="literal">false</span>, DoHaveOld = <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">HaveNew</span> &#123; DontHaveNew = <span class="literal">false</span>, DoHaveNew = <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CrashIfDeallocating</span> &#123;</span><br><span class="line">    DontCrashIfDeallocating = <span class="literal">false</span>, DoCrashIfDeallocating = <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">location: weak 指针的内存地址，即 `__weak id weakPtr;` 中的 &amp;weakPtr。</span></span><br><span class="line"><span class="comment">newObj: weak 指针要指向的对象，即 `__weak id weakPtr = obj;` 中的 obj。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;HaveOld haveOld, HaveNew haveNew, </span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CrashIfDeallocating</span> crashIfDeallocating&gt;</span><br><span class="line"><span class="function"><span class="type">static</span> id <span class="title">storeWeak</span><span class="params">(id *location, objc_object *newObj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当 newObj 的类型还未初始化的时候会用到。</span></span><br><span class="line">    Class previouslyInitializedClass = nil;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存 weak 指针当前指向的对象。</span></span><br><span class="line">    id oldObj;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// SideTable 是用来存储弱引用关联的 1 个数据结构，后面会单独讲。</span></span><br><span class="line">    SideTable *oldTable;</span><br><span class="line">    SideTable *newTable;</span><br><span class="line"></span><br><span class="line"> retry:</span><br><span class="line">    <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">        oldObj = *location;</span><br><span class="line">        <span class="comment">// 调用全局函数 SideTables 获取 oldObj 对应的 SideTable 对象。</span></span><br><span class="line">        oldTable = &amp;<span class="built_in">SideTables</span>()[oldObj];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        oldTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        newTable = &amp;<span class="built_in">SideTables</span>()[newObj];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该函数不是线程安全的，所以执行到这里的时候，</span></span><br><span class="line">    <span class="comment">// weak 指针的值有可能被其它线程修改了，</span></span><br><span class="line">    <span class="comment">// 如果是的话就跳转到 retry 重新获取数据。</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld &amp;&amp; *location != oldObj) &#123;</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (haveNew &amp;&amp; newObj) &#123;</span><br><span class="line">        Class cls = newObj-&gt;<span class="built_in">getIsa</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        检查 newObj 的类型是否已经完成初始化。</span></span><br><span class="line"><span class="comment">        一般都不会发生这种情况，除非你在 +initialize 中对该对象进行弱引用，</span></span><br><span class="line"><span class="comment">        例如以下场景：</span></span><br><span class="line"><span class="comment">        @implementation Person</span></span><br><span class="line"><span class="comment">        + (void)initialize &#123;</span></span><br><span class="line"><span class="comment">           Person *obj = [[self alloc] init];</span></span><br><span class="line"><span class="comment">           // 此时 Person 类还未完成初始化操作。</span></span><br><span class="line"><span class="comment">           __weak typeof(obj) weakObj = obj;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        @end</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (cls != previouslyInitializedClass &amp;&amp;  </span><br><span class="line">            !cls-&gt;<span class="built_in">isInitialized</span>()) &#123;  </span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 对 newObj 类型进行初始化操作，然后跳转 retry 重新获取数据。</span></span><br><span class="line">            <span class="built_in">class_initialize</span>(cls, newObj);</span><br><span class="line">            previouslyInitializedClass = cls;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">        <span class="comment">// 如果 weak 指针当前持有了一个对象，先解除与这个对象的弱引用关联。</span></span><br><span class="line">        <span class="built_in">weak_unregister_no_lock</span>(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        <span class="comment">// 将 weak 指针与新对象建立弱引用关联。</span></span><br><span class="line">        newObj = <span class="built_in">weak_register_no_lock</span>(&amp;newTable-&gt;weak_table,</span><br><span class="line">        (id)newObj,</span><br><span class="line">        location,</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        之前在初始化函数那里提到过带 OrNil 后缀和不带后缀的区别，</span></span><br><span class="line"><span class="comment">        重点就在这里，带后缀的函数这里会传递 ReturnNilIfDeallocating，</span></span><br><span class="line"><span class="comment">        不带后缀的会传递 CrashIfDeallocating。</span></span><br><span class="line"><span class="comment">        函数内部会检查 newObj 是否正在释放过程中，</span></span><br><span class="line"><span class="comment">        如果是的话就会使用这个参数来决定怎么处理。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        crashIfDeallocating ? CrashIfDeallocating : ReturnNilIfDeallocating);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修改 newObj 对象的 isa 中关于是否有弱引用的标记。</span></span><br><span class="line">        <span class="keyword">if</span> (!_objc_isTaggedPointerOrNil(newObj)) &#123;</span><br><span class="line">            newObj-&gt;<span class="built_in">setWeaklyReferenced_nolock</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 weak 指针指向 newObj。</span></span><br><span class="line">        *location = (id)newObj;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    这个函数我翻了往年的 runtime 源码，发现是从 objc4-818.2 开始引入的。</span></span><br><span class="line"><span class="comment">    它的内部逻辑大致如下：</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    1. 检查对象是否实现了手动引用计数。</span></span><br><span class="line"><span class="comment">    2. 如果支持的话，再判断对象是否有实例方法 _setWeaklyReferenced 的实现，如果有的话就调用。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">callSetWeaklyReferenced</span>((id)newObj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (id)newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数就是 weak 指针初始化的最终函数。从函数中不难发现，它主要就干了 2 件事：</p><ol><li>调用 <code>weak_unregister_no_lock</code>：将 weak 指针与当前对象解除弱引用关联。</li><li>调用 <code>weak_register_no_lock</code>：将 weak 指针与新对象建立弱引用关联。</li></ol><h3 id="weak-指针解除关联的细节：weak-unregister-no-lock"><a href="#weak-指针解除关联的细节：weak-unregister-no-lock" class="headerlink" title="weak 指针解除关联的细节：weak_unregister_no_lock"></a>weak 指针解除关联的细节：weak_unregister_no_lock</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">weak_unregister_no_lock</span><span class="params">(<span class="type">weak_table_t</span> *weak_table,</span></span></span><br><span class="line"><span class="params"><span class="function">                        id referent_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                        id *referrer_id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// weak 指针当前指向的对象，即 `__weak id weakPtr = obj;` 中的 obj。</span></span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    <span class="comment">// weak 指针的内存地址，即 `__weak id weakPtr;` 中的 &amp;weakPtr。</span></span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// referent 对象的弱引用表。</span></span><br><span class="line">    <span class="type">weak_entry_t</span> *entry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!referent) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 weak_table 中取出 referent 对应的弱引用表。</span></span><br><span class="line">    <span class="keyword">if</span> ((entry = <span class="built_in">weak_entry_for_referent</span>(weak_table, referent))) &#123;</span><br><span class="line">        <span class="comment">// 从弱引用表中移除 weak 指针的地址，即移除 referrer。</span></span><br><span class="line">        <span class="built_in">remove_referrer</span>(entry, referrer);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 移除后检查一下表是否为空，</span></span><br><span class="line">        <span class="comment">// 如果是的话就删除这个表。</span></span><br><span class="line">        <span class="type">bool</span> empty = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;<span class="built_in">out_of_line</span>() &amp;&amp;</span><br><span class="line">            entry-&gt;num_refs != <span class="number">0</span>) &#123;</span><br><span class="line">            empty = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry-&gt;inline_referrers[i]) &#123;</span><br><span class="line">                    empty = <span class="literal">false</span>; </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">            <span class="built_in">weak_entry_remove</span>(weak_table, entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从弱引用表中获取某个对象对应的那张表数据。</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">weak_entry_t</span> *</span></span><br><span class="line"><span class="function"><span class="title">weak_entry_for_referent</span><span class="params">(<span class="type">weak_table_t</span> *weak_table, objc_object *referent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下面的逻辑是一段典型的哈希表实现细节，关于哈希表的实现原理请自行了解。</span></span><br><span class="line">    <span class="type">weak_entry_t</span> *weak_entries = weak_table-&gt;weak_entries;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!weak_entries) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> begin = <span class="built_in">hash_pointer</span>(referent) &amp; weak_table-&gt;mask;</span><br><span class="line">    <span class="type">size_t</span> index = begin;</span><br><span class="line">    <span class="type">size_t</span> hash_displacement = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (weak_table-&gt;weak_entries[index].referent != referent) &#123;</span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; weak_table-&gt;mask;</span><br><span class="line">        <span class="keyword">if</span> (index == begin) <span class="built_in">bad_weak_table</span>(weak_table-&gt;weak_entries);</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        <span class="keyword">if</span> (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123;</span><br><span class="line">            <span class="keyword">return</span> nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &amp;weak_table-&gt;weak_entries[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从弱引用表中移除指定的 weak 指针。</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">remove_referrer</span><span class="params">(<span class="type">weak_entry_t</span> *entry, objc_object **old_referrer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 系统在存储弱指针数据的时候会采用 2 套方案。</span></span><br><span class="line">    <span class="comment">// 如果数据量比较小就会使用静态数组存放。</span></span><br><span class="line">    <span class="comment">// 这里的逻辑就是判断，如果是静态数组方案就执行这段逻辑。</span></span><br><span class="line">    <span class="keyword">if</span> (!entry-&gt;<span class="built_in">out_of_line</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;inline_referrers[i] == old_referrer) &#123;</span><br><span class="line">                entry-&gt;inline_referrers[i] = nil;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是动态数组存储的话，就执行这段逻辑。</span></span><br><span class="line">    <span class="type">size_t</span> begin = <span class="built_in">w_hash_pointer</span>(old_referrer) &amp; (entry-&gt;mask);</span><br><span class="line">    <span class="type">size_t</span> index = begin;</span><br><span class="line">    <span class="type">size_t</span> hash_displacement = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (entry-&gt;referrers[index] != old_referrer) &#123;</span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; entry-&gt;mask;</span><br><span class="line">        <span class="keyword">if</span> (index == begin) <span class="built_in">bad_weak_table</span>(entry);</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        <span class="keyword">if</span> (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123;</span><br><span class="line">            <span class="comment">// 弱引用表中没有这个弱指针数据，不需要移除。</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    entry-&gt;referrers[index] = nil;</span><br><span class="line">    entry-&gt;num_refs--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从弱引用表中移除某张表。</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">weak_entry_remove</span><span class="params">(<span class="type">weak_table_t</span> *weak_table, <span class="type">weak_entry_t</span> *entry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果是动态数组方案的话，释放创建的动态数组。</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;<span class="built_in">out_of_line</span>()) <span class="built_in">free</span>(entry-&gt;referrers);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(entry, <span class="number">0</span>, <span class="built_in">sizeof</span>(*entry));</span><br><span class="line"></span><br><span class="line">    weak_table-&gt;num_entries--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要的话，对弱引用表进行缩容。</span></span><br><span class="line">    <span class="built_in">weak_compact_maybe</span>(weak_table);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码稍微有点多，但整体的逻辑比较清晰。<code>weak_unregister_no_lock</code> 函数中主要做了 3 件事：</p><ol><li>调用 <code>weak_entry_for_referent</code> 从弱引用表中获取指定的那张表数据。</li><li>调用 <code>remove_referrer</code> 从表中移除弱指针（即 referrer）。</li><li>检查表是否为空，是的话就调用 <code>weak_entry_remove</code> 从 weak_table 中移除这张表。</li></ol><p>移除弱引用关联，本质上就是从 weak_table 中找到对象对应的弱引用数组，然后从数组中找到需要移除的 weak 指针并将其置空。weak_table 其实就是一个哈希表，关于哈希表的实现原理请自行了解。</p><h3 id="weak-指针建立关联的细节：weak-register-no-lock"><a href="#weak-指针建立关联的细节：weak-register-no-lock" class="headerlink" title="weak 指针建立关联的细节：weak_register_no_lock"></a>weak 指针建立关联的细节：weak_register_no_lock</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">id </span></span><br><span class="line"><span class="function"><span class="title">weak_register_no_lock</span><span class="params">(<span class="type">weak_table_t</span> *weak_table,</span></span></span><br><span class="line"><span class="params"><span class="function">                      id referent_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                      id *referrer_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                      WeakRegisterDeallocatingOptions deallocatingOptions)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// weak 指针当前指向的对象，即 `__weak id weakPtr = obj;` 中的 obj。</span></span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    <span class="comment">// weak 指针的内存地址，即 `__weak id weakPtr;` 中的 &amp;weakPtr。</span></span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里是确保 weak 指针要指向的那个对象是有效的（即没有正在释放）。</span></span><br><span class="line">    <span class="keyword">if</span> (deallocatingOptions == ReturnNilIfDeallocating ||</span><br><span class="line">        deallocatingOptions == CrashIfDeallocating) &#123;</span><br><span class="line">        <span class="type">bool</span> deallocating;</span><br><span class="line">        <span class="keyword">if</span> (!referent-&gt;<span class="built_in">ISA</span>()-&gt;<span class="built_in">hasCustomRR</span>()) &#123;</span><br><span class="line">            deallocating = referent-&gt;<span class="built_in">rootIsDeallocating</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> allowsWeakReference = (<span class="built_in">BOOL</span>(*)(objc_object *, SEL))</span><br><span class="line">            <span class="built_in">lookUpImpOrForwardTryCache</span>((id)referent, @<span class="built_in">selector</span>(allowsWeakReference),</span><br><span class="line">                                       referent-&gt;<span class="built_in">getIsa</span>());</span><br><span class="line">            <span class="keyword">if</span> ((IMP)allowsWeakReference == _objc_msgForward) &#123;</span><br><span class="line">                <span class="keyword">return</span> nil;</span><br><span class="line">            &#125;</span><br><span class="line">            deallocating =</span><br><span class="line">            ! (*allowsWeakReference)(referent, @<span class="built_in">selector</span>(allowsWeakReference));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果正在释放的话，根据参数 deallocatingOptions 来决定执行什么操作。</span></span><br><span class="line">        <span class="keyword">if</span> (deallocating) &#123;</span><br><span class="line">            <span class="keyword">if</span> (deallocatingOptions == CrashIfDeallocating) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">&quot;Cannot form weak reference to instance (%p) of &quot;</span></span><br><span class="line">                            <span class="string">&quot;class %s. It is possible that this object was &quot;</span></span><br><span class="line">                            <span class="string">&quot;over-released, or is in the process of deallocation.&quot;</span>,</span><br><span class="line">                            (<span class="type">void</span>*)referent, <span class="built_in">object_getClassName</span>((id)referent));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nil;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">weak_entry_t</span> *entry;</span><br><span class="line">    <span class="comment">// weak_entry_for_referent 函数在前面的 weak_unregister_no_lock 中已解释过。</span></span><br><span class="line">    <span class="keyword">if</span> ((entry = <span class="built_in">weak_entry_for_referent</span>(weak_table, referent))) &#123;</span><br><span class="line">        <span class="built_in">append_referrer</span>(entry, referrer);</span><br><span class="line">    &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 找不到对应的表，创建一个新表。</span></span><br><span class="line">        <span class="type">weak_entry_t</span> <span class="built_in">new_entry</span>(referent, referrer);</span><br><span class="line">        <span class="comment">// 如果需要的话，对 weak_table 进行扩容。</span></span><br><span class="line">        <span class="built_in">weak_grow_maybe</span>(weak_table);</span><br><span class="line">        <span class="comment">// 将新表插入到 weak_table 中。</span></span><br><span class="line">        <span class="built_in">weak_entry_insert</span>(weak_table, &amp;new_entry);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> referent_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向弱引用表中添加一个 weak 指针。</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">append_referrer</span><span class="params">(<span class="type">weak_entry_t</span> *entry, objc_object **new_referrer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前采用的是静态数组方案就执行这段逻辑。</span></span><br><span class="line">    <span class="keyword">if</span> (!entry-&gt;<span class="built_in">out_of_line</span>()) &#123;</span><br><span class="line">        <span class="comment">// 尝试在静态数组中插入数据。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;inline_referrers[i] == nil) &#123;</span><br><span class="line">                entry-&gt;inline_referrers[i] = new_referrer;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 来到这里说明静态数组已经存满了，后面的逻辑是把静态数组转为动态数组存储。</span></span><br><span class="line">        <span class="type">weak_referrer_t</span> *new_referrers = (<span class="type">weak_referrer_t</span> *)</span><br><span class="line">            <span class="built_in">calloc</span>(<span class="number">4</span>, <span class="built_in">sizeof</span>(<span class="type">weak_referrer_t</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            new_referrers[i] = entry-&gt;inline_referrers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        entry-&gt;referrers = new_referrers;</span><br><span class="line">        entry-&gt;num_refs = <span class="number">4</span>;</span><br><span class="line">        entry-&gt;out_of_line_ness = <span class="number">2</span>;</span><br><span class="line">        entry-&gt;mask = <span class="number">4</span> - <span class="number">1</span>;</span><br><span class="line">        entry-&gt;max_hash_displacement = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果数组的元素数量大于等于总容量的 3/4，则对数组进行扩容并插入新数据。</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;num_refs &gt;= (entry-&gt;mask + <span class="number">1</span>) * <span class="number">3</span>/<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">grow_refs_and_insert</span>(entry, new_referrer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">size_t</span> begin = <span class="built_in">w_hash_pointer</span>(new_referrer) &amp; (entry-&gt;mask);</span><br><span class="line">    <span class="type">size_t</span> index = begin;</span><br><span class="line">    <span class="type">size_t</span> hash_displacement = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (entry-&gt;referrers[index] != nil) &#123;</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; entry-&gt;mask;</span><br><span class="line">        <span class="keyword">if</span> (index == begin) <span class="built_in">bad_weak_table</span>(entry);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// hash_displacement 保存的是此次遇到的哈希冲突次数，</span></span><br><span class="line">    <span class="comment">// 之所以要保存这个值，是因为取值的时候也会遇到哈希冲突，</span></span><br><span class="line">    <span class="comment">// 此时需要和这个值进行比较，如果大于这个值的话就说明哈希表中没有要找的数据。</span></span><br><span class="line">    <span class="keyword">if</span> (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123;</span><br><span class="line">        entry-&gt;max_hash_displacement = hash_displacement;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">weak_referrer_t</span> &amp;ref = entry-&gt;referrers[index];</span><br><span class="line">    ref = new_referrer;</span><br><span class="line">    entry-&gt;num_refs++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立关联和解除关联的逻辑相似，本质都是通过 <code>weak_entry_for_referent</code> 获取对应的表。然后在通过 weak 指针进行一系列哈希运算，从而拿到要添加&#x2F;要删除的数组索引，最终对数组元素进行添加&#x2F;删除操作。</p><p>截止到这里，关于 weak 指针的整个初始化过程已经全部讲完了。如果你还想了解更多细节的话可以继续阅读后面的内容。</p><h2 id="深入剖析-SideTable-类型"><a href="#深入剖析-SideTable-类型" class="headerlink" title="深入剖析 SideTable 类型"></a>深入剖析 SideTable 类型</h2><p>SideTable 是用来存储弱引用数据和引用计数的一个数据结构，由于这篇文章只涉及弱引用相关问题，所以在后面的源码中我会特意去掉与文章不相关的内容，如果你想了解全部细节的话请阅读源码。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SideTable</span> &#123;</span><br><span class="line"> <span class="comment">// 你可以把它理解成一个哈希表，</span></span><br><span class="line">    <span class="comment">// key 是对象；value 是对象对应的弱引用表数据。</span></span><br><span class="line">    <span class="type">weak_table_t</span> weak_table;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">weak_table_t</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这是一个数组，数组中的每个元素是一个 weak_entry_t 对象。</span></span><br><span class="line"><span class="comment">    weak_entry_t 里存储了弱引用的相关数据。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">weak_entry_t</span> *weak_entries;</span><br><span class="line">    <span class="comment">// 数组 weak_entries 的元素数量。</span></span><br><span class="line">    <span class="type">size_t</span>    num_entries;</span><br><span class="line">    <span class="comment">// 数组 weak_entries 的长度减一，求数组索引时需要用到。</span></span><br><span class="line">    <span class="type">uintptr_t</span> mask;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    记录在存储元素时遇到的最大的哈希冲突次数。</span></span><br><span class="line"><span class="comment">    在查找元素的时候会被用到，</span></span><br><span class="line"><span class="comment">    如果查找过程中哈希冲突次数大于这个值就说明哈希表中没有要找的数据。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uintptr_t</span> max_hash_displacement;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正用来存储弱引用数据的结构。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">weak_entry_t</span> &#123;</span><br><span class="line">    <span class="comment">// weak 指针所指向的那个对象（类似哈希表中的 key）。</span></span><br><span class="line">    id referent;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    从以下代码可以发现：系统内部在存储弱引用数据的时候有 2 套方案，</span></span><br><span class="line"><span class="comment">    如果数据比较少就使用静态数组 inline_referrers 存储；</span></span><br><span class="line"><span class="comment">    如果数据比较多就使用动态数组 referrers 存储。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="comment">// 用来存储弱引用的动态数组。</span></span><br><span class="line">            id *referrers;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            一个标记位，如果这个值是 2 的话就表示使用的是动态数组。</span></span><br><span class="line"><span class="comment">            因为 objc 对象的内存地址的最后一位只会是 0x8 或 0x0，</span></span><br><span class="line"><span class="comment">            即：如果采用的是静态数组方案的话，这个位置的数据绝对是 0。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="type">uintptr_t</span>        out_of_line_ness : <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 数组 referrers 的元素数量。</span></span><br><span class="line">            <span class="type">uintptr_t</span>        num_refs : <span class="number">62</span>;</span><br><span class="line">            <span class="comment">// 数组 referrers 的长度减一，和 weak_table_t 中的 mask 功能一样。</span></span><br><span class="line">            <span class="type">uintptr_t</span>        mask;</span><br><span class="line">            <span class="comment">// 和 weak_table_t 中的 max_hash_displacement 功能一样。</span></span><br><span class="line">            <span class="type">uintptr_t</span>        max_hash_displacement;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="comment">// 用来存储弱引用的静态数组。</span></span><br><span class="line">            id inline_referrers[<span class="number">4</span>];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>你可以把 SideTable 理解成一个获取弱引用表的入口，weak_table 类似一个大哈希表，这个哈希表的 key 是 objc 对象，value 是对应的弱引用数组。关于 weak 指针的操作，例如解除关联和建立关联，其实就是从 weak_table 中获取其对应的弱引用数组，然后从这个数组中移除或添加对应的弱指针地址。</p><h2 id="weak-指针自动赋值-nil-的实现细节：weak-clear-no-lock"><a href="#weak-指针自动赋值-nil-的实现细节：weak-clear-no-lock" class="headerlink" title="weak 指针自动赋值 nil 的实现细节：weak_clear_no_lock"></a>weak 指针自动赋值 nil 的实现细节：weak_clear_no_lock</h2><p>众所周知，weak 指针在对象被释放之后会自动指向 nil，那么它到底是如何实现的呢？</p><p>关于释放流程的函数调用顺序这里就不具体展开了，在 <a href="https://github.com/apple-oss-distributions/objc4/tree/objc4-906">objc4-906</a> 版本中，其函数调用顺序如下：dealloc &#x3D;&gt; _objc_rootDealloc &#x3D;&gt; rootDealloc &#x3D;&gt; object_dispose &#x3D;&gt; objc_destructInstance &#x3D;&gt; clearDeallocating &#x3D;&gt; clearDeallocating_slow &#x3D;&gt; weak_clear_no_lock，我们重点看一下最后一个函数 <code>weak_clear_no_lock</code> 的实现细节。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">weak_clear_no_lock</span><span class="params">(<span class="type">weak_table_t</span> *weak_table, id referent_id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 正在释放的对象。</span></span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前对象对应的弱引用表。</span></span><br><span class="line">    <span class="type">weak_entry_t</span> *entry = <span class="built_in">weak_entry_for_referent</span>(weak_table, referent);</span><br><span class="line">    <span class="keyword">if</span> (entry == nil) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">weak_referrer_t</span> *referrers;</span><br><span class="line">    <span class="type">size_t</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取弱指针数组和数组容量。</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;<span class="built_in">out_of_line</span>()) &#123;</span><br><span class="line">        referrers = entry-&gt;referrers;</span><br><span class="line">        count = (entry-&gt;mask ? entry-&gt;mask + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        referrers = entry-&gt;inline_referrers;</span><br><span class="line">        count = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重点：系统会遍历弱指针数组中的每个地址，并将它们赋值为 nil。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        objc_object **referrer = referrers[i];</span><br><span class="line">        <span class="keyword">if</span> (referrer) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*referrer == referent) &#123;<span class="comment">// 等价于 weakSelf == self(self 表示当前正在释放的对象)</span></span><br><span class="line">                *referrer = nil;<span class="comment">// 等价于 weakSelf = nil;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*referrer) &#123;</span><br><span class="line">                <span class="built_in">REPORT_WEAK_ERROR</span>(<span class="string">&quot;__weak variable at %p holds %p instead of %p. &quot;</span></span><br><span class="line">                                  <span class="string">&quot;This is probably incorrect use of &quot;</span></span><br><span class="line">                                  <span class="string">&quot;objc_storeWeak() and objc_loadWeak().&quot;</span>,</span><br><span class="line">                                  referrer, (<span class="type">void</span>*)*referrer, (<span class="type">void</span>*)referent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从弱引用表中移除这张表。</span></span><br><span class="line">    <span class="built_in">weak_entry_remove</span>(weak_table, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中不难发现，系统会在对象释放的时候，获取其对应的弱引用表，然后遍历这个表中的 weak 指针并将其赋值为 nil。</p><p>到此为止，关于 weak 指针的所有内容就讲完了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 runtime 初始化的时候，会调用一个全局函数 <code>side_tables_init</code> 初始化一个全局数组，数组的元素是 SideTable 对象，可以通过全局函数 <code>SideTables</code> 拿到这个数组以及对象对应的 SideTable 对象。</p><p>SideTable 中有一个变量 weak_table，你可以将它理解成一个哈希表，哈希表的 key 是对象，value 是一个数组，数组中的元素就是指向这个 key 的 weak 指针地址。</p><p>weak 指针的初始化操作就是拿到这个对象对应的弱指针数组，然后往数组里面把 weak 指针的内存地址添加进去。</p><p>如果 weak 指针需要指向别的对象，需要拿到旧对象对应的弱指针数组并将数组中存放 weak 指针的那个位置置空，然后拿到新对象对应的弱指针数组并将 weak 指针添加进去。</p><p>如果对象释放了，就拿到这个对象对应的弱指针数组并挨个将里面的 weak 指针赋值为 nil。</p><p>为了加深自己的理解，我模仿系统的实现写了一个示例项目 <a href="https://github.com/internetWei/WeakPointer">WeakPointer</a>，我在这个项目里还给分类属性也支持了 weak 特性，感兴趣的同学可以参考一下。</p><h2 id="关于-weak-指针的一些疑问与解答"><a href="#关于-weak-指针的一些疑问与解答" class="headerlink" title="关于 weak 指针的一些疑问与解答"></a>关于 weak 指针的一些疑问与解答</h2><h3 id="为什么不能给-Category-添加-weak-属性？"><a href="#为什么不能给-Category-添加-weak-属性？" class="headerlink" title="为什么不能给 Category 添加 weak 属性？"></a>为什么不能给 Category 添加 weak 属性？</h3><p>我们一般是这样初始化一个 weak 指针：<code>__weak id weakPtr = obj;</code>，从源码中我们知道编译器会把代码转换成这样：<code>objc_storeWeak((void *)&amp;weakPtr, obj);</code>。</p><p>从这里可以发现，要实现 weak 特性，你必须能拿到 obj 对象和 weak 指针的内存地址，而 Category 中的属性是依靠 runtime 中的 <code>objc_setAssociatedObject</code> 和 <code>objc_getAssociatedObject</code> 这 2 个函数来实现的，我们拿不到 weak 指针的内存地址，故而无法给 Category 的属性支持 weak 特性。</p><p>类的属性之所以支持 weak 特性，是因为编译器能拿到这个属性的成员变量的地址（即 weak 指针的内存地址）。</p><p>如果你一定要给 Category 添加 weak 属性的话，有以下 2 个思路（建议选择第 2 个）：</p><ol><li><p>参考我的这个项目 <a href="https://github.com/internetWei/WeakPointer">WeakPointer</a> 模仿系统的实现手动维护一个弱引用表来支持 Category 的 weak 属性。</p></li><li><p>创建一个中间类，给中间类声明一个 weak 属性，Category 的属性强引用这个中间类，中间类的 weak 属性指向真正的对象。</p><p> 示例代码：</p> <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WeakTarget</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="type">id</span> weakObj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span>(<span class="title">Category</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="type">id</span> weakObj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span> (<span class="title">Category</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setWeakObj:(<span class="built_in">NSObject</span> *)obj &#123;</span><br><span class="line">    WeakTarget *target = [[WeakTarget alloc] init];</span><br><span class="line">    target.weakObj = obj;</span><br><span class="line"></span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(weakObj), target, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)weakObj &#123;</span><br><span class="line">    WeakTarget *target = objc_getAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(weakObj));</span><br><span class="line">    <span class="keyword">return</span> target.weakObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">WeakTarget</span> @<span class="title">end</span></span></span><br></pre></td></tr></table></figure></li></ol><h3 id="为什么在-block-中不能使用-weak-指针访问其成员变量。"><a href="#为什么在-block-中不能使用-weak-指针访问其成员变量。" class="headerlink" title="为什么在 block 中不能使用 weak 指针访问其成员变量。"></a>为什么在 block 中不能使用 weak 指针访问其成员变量。</h3><p>这是我在项目中实际遇到的一个问题，伪代码如下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    weakSelf-&gt;_propertyName;<span class="comment">// 使用 weak 指针直接访问成员变量。</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码无法通过编译，如果改成这样就没问题了：<code>weakSelf.propertyName;</code>。</p><p>众所周知，在 objc 里访问属性最终还是会访问成员变量。那为什么访问属性就正常，访问成员变量就会报错呢？</p><p>之所以会这样，是因为现在的编译器比较智能，考虑的比较多。weakSelf 在运行时有可能为 nil 从而导致崩溃，编译器认为这样的代码不安全所以报错。但是使用 weakSelf 访问属性是安全的，因为访问属性实际上是调用了属性的 get&#x2F;set 方法，在 objc 里对 nil 调用方法是不会导致异常。</p><p>上面的报错代码可以改成以下代码来解决编译报错：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="keyword">if</span> (weakSelf) &#123;<span class="comment">// 这一步很重要，因为这里的 weak 指针有可能已经是 nil 了。</span></span><br><span class="line">        __<span class="keyword">strong</span> <span class="keyword">typeof</span>(weakSelf) strongSelf = weakSelf;</span><br><span class="line">        strongSelf-&gt;_propertyName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="为什么在对象没有弱引用时也会执行-weak-clear-no-lock"><a href="#为什么在对象没有弱引用时也会执行-weak-clear-no-lock" class="headerlink" title="为什么在对象没有弱引用时也会执行 weak_clear_no_lock"></a>为什么在对象没有弱引用时也会执行 weak_clear_no_lock</h3><p>在研究 weak 指针自动赋值 nil 的过程中，我发现，对象只要曾经被 weak 指针指向过，在对象释放的时候即使没有指向它的 weak 指针，也会执行到 weak_clear_no_lock 函数。</p><p>在 storeWeak 函数中会调用这行代码设置对象被 weak 指针指向的标记：<code>newObj-&gt;setWeaklyReferenced_nolock();</code>。</p><p>但是，当对象没有任何 weak 指针指向时，weak_unregister_no_lock 函数中并没有调用相关函数将标记设置为 false。</p><p>这会导致在对象释放的时候，即调用到 rootDealloc 函数时无法执行快速释放逻辑。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">objc_object::rootDealloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isTaggedPointer</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(<span class="built_in">isa</span>().nonpointer                     &amp;&amp;</span><br><span class="line">    <span class="comment">// 如果对象曾经被 weak 指针指向过，即使现在没有了，weakly_referenced 也是 true。</span></span><br><span class="line">                 !<span class="built_in">isa</span>().weakly_referenced             &amp;&amp;</span><br><span class="line">                 !<span class="built_in">isa</span>().has_assoc                     &amp;&amp;</span><br><span class="line">                 !<span class="built_in">isa</span>().<span class="built_in">getClass</span>(<span class="literal">false</span>)-&gt;<span class="built_in">hasCxxDtor</span>() &amp;&amp;</span><br><span class="line">                 !<span class="built_in">isa</span>().has_sidetable_rc)) &#123;</span><br><span class="line">        <span class="built_in">free</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">object_dispose</span>((id)<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我也不太清楚为什么这么做？如果你知道其中的具体细节的话，还请留言告知。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ObjC </tag>
            
            <tag> Runtime </tag>
            
            <tag> ARC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>慎用unsigned类型</title>
      <link href="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%85%8E%E7%94%A8unsigned%E7%B1%BB%E5%9E%8B/"/>
      <url>/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%85%8E%E7%94%A8unsigned%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由 布多(budo) 发布于 2022-07-22</p></blockquote><p>这篇文章我会从计算机基础的角度向大家解释 unsigned 类型 和 signed 类型在内存中到底是如何存储的，以及为什么要慎用 unsigned 类型。</p><blockquote><p>我是站在 iOS 开发角度写的这篇文章，所以会出现一些OC代码，如果你看不懂的话可以跳过这些部分。</p></blockquote><p>在OC中我们一般会使用 <strong>NSUInteger</strong> 而非 <strong>unsigned</strong> 表示无符号整数，但其实它们是一样的，NSUInteger 只是 unsigned 的类型别名而已；NSObjCRuntime.h 文件中有关于 NSUInteger 的详细定义。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __LP64__ || TARGET_OS_WIN32 || NS_BUILD_32_LIKE_64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="built_in">NSUInteger</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">NSUInteger</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)reversePrintObjectWithArray:(<span class="built_in">NSArray</span> *)array &#123;</span><br><span class="line">    <span class="keyword">if</span> (![array isKindOfClass:<span class="built_in">NSArray</span>.class]) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = array.count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;第%lu个元素: %@&quot;</span>, i, array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个方法只是简单的倒序打印数组中的每个元素，而且在打印前也做了类型检查和判空操作。但是它还是有问题，你能看出来吗？</p><p>当你传递的参数是 nil、非 NSArray 类型，或者非空数组时，一切都正常；但如果你不小心传递了一个空数组，将会导致崩溃，崩溃原因是数组访问越界，越界的索引是 18446744073709551615(<code>如果在32位环境下，会是4294967295</code>)。你也可以把这段代码粘贴到你的项目中，测试一下看看结果是否和我说的一样。</p><p>？？？是不是觉得条件都不符合，循环应该一次都没执行，还有 18446744073709551615 是哪来的？</p><p>其实造成这一切的根源在于 __计算机对于正数和负数的读写方式不一样__。</p><hr><p>下面我将用C代码来帮助大家理解 _计算机是如何读写正数和负数_。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">short</span> a = <span class="number">-18</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> b = <span class="number">65518</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a: %hd, %hu\n&quot;</span>, a, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b: %hd, %hu\n&quot;</span>, b, b);</span><br></pre></td></tr></table></figure><p><img src="2022_07_20_16.37.50.png" alt="运行结果"></p><p>计算机规定整数必须以补码形式进行存储，如果你想弄明白为什么，请阅读<a href="#jump1">题外话(为什么要使用补码)</a>。</p><blockquote><p>注意：只有负数需要计算补码，正数的反码、补码其实和原码一样。</p></blockquote><p>变量a的补码计算过程如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-18</span><br><span class="line">= 10010(18的二进制)</span><br><span class="line">= 0000 0000 0001 0010(short 类型占用 2 * 8 = 16 个比特位，所以前面需要补0)</span><br><span class="line">= 1000 0000 0001 0010(计算机规定，有符号数的第1个比特位用于存储符号位，1表示负</span><br><span class="line">数，0表示正数；这就是-18的原码)</span><br><span class="line">= 1111 1111 1110 1101(这是-18的反码，反码就是把除符号位之外的所有数据取反)</span><br><span class="line">= 1111 1111 1110 1110(这是-18的补码，补码是在反码的基础上加1)</span><br></pre></td></tr></table></figure><p>变量a实际存储在内存中的数据不是原码 <code>1000 0000 0001 0010</code> 而是补码 <code>1111 1111 1110 1110</code>；在使用 <code>%hd</code> 打印的时候，计算机会把内存中的数据当作补码处理，所以需要先将它还原成原码 <code>1000 0000 0001 0010</code>，然后把原码转为十进制，所以输出的是 -18。</p><p>当你使用 <code>%hu</code> 去打印变量a的时候，计算机会把这块内存的数据解释为正数，还记得之前提到的正数的补码和原码一样吗，计算机会把内存中的数据直接当作原码处理， <code>1111 1111 1110 1110</code> 转为十进制正好就是 65518 。</p><p>看完变量a的讲解后，你是否能手动验证变量b的结果呢？</p><p>变量b的原码是 <code>1111 1111 1110 1110</code>，由于它是正数，所以补码就等于原码；在使用 <code>%hu</code> 打印的时候，计算机会把内存中的数据直接当成原码处理，所以会输出 65518。</p><p>如果使用 <code>%hd</code> 打印的话，计算机会把内存中的数据当做补码，补码转为原码是 <code>1000 0000 0001 0010</code>，发现了吗，这不就是 -18 的原码吗。</p><blockquote><p>发现了吗，65518 的补码&#x2F;原码正好和 -18 的补码一样(<code>简单的说，在内存中 65518 和 -18 的数据是一样的</code>)；有时候现实中2个完全不同的数可能在内存中的表现会一模一样，这也是为什么大部分情况下二进制无法还原回高级语言的原因。</p></blockquote><blockquote><p>以变量a为例，不管它的类型是 <code>short</code> 还是 <code>unsigned short</code>，都不会影响 -18 这个值在内存中的存储方式，在读取变量a的值时，计算机首先找到变量a的地址，然后根据类型得到它的长度，short 的长度是 2 * 8 &#x3D; 16 个比特位，从变量a的地址开始，往后16个比特位就是变量a在内存中存储的数据，使用不同的符号打印(%hu、%hd)会影响计算机对这块内存的解释，但不会影响内存中的数据。</p></blockquote><hr><p>回到开头那个数组越界的问题，18446744073709551615 其实就是把 -1 当作无符号数读取而来的。</p><p>由于 <code>NSUInteger</code> 实际是 long 类型，占用 <code>8 * 8 = 64</code> 个比特位，-1 的原码是 <code>1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0001</code>，补码是 <code>1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111</code>，由于 <code>NSUInteger</code> 是无符号数，所以计算机会把补码当成原码使用，转为十进制正好就是 18446744073709551615 。</p><p>解决起来也很简单，把 <code>NSUInteger</code> 用 <code>NSInteger</code> 代替就行了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在项目开发过程中，除了返回值、参数等特殊地方，建议统一使用有符号数(<code>NSInteger</code>)代替无符号数(<code>NSUInteger</code>)，这有如下好处：</p><ol><li>提高代码的统一性和兼容性。</li><li>避免不同数字类型之间的转换问题，减少代码复杂度，降低代码BUG率。</li></ol><p>如果必须要使用无符号数，例如返回值、参数等，切记一定要在使用前检查数据正确性，例如使用强转判断值是否正确。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无符号数作为方法参数</span></span><br><span class="line">- (<span class="type">void</span>)fun:(<span class="built_in">NSUInteger</span>)index &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">NSInteger</span>)index &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无符号数作为返回值</span></span><br><span class="line"><span class="built_in">NSInteger</span> _count;</span><br><span class="line">- (<span class="built_in">NSUInteger</span>)count &#123;</span><br><span class="line">    <span class="keyword">return</span> _count &lt; <span class="number">0</span> ? <span class="number">0</span> : (<span class="built_in">NSUInteger</span>)_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像文章中的这种问题属于数据异常，大部分情况下数据异常远比崩溃还要严重。</p><p>数据异常可能会给用户或公司带来巨大损失；假设你开发一个计算器软件，把值算错了大概率会导致非常严重的后果和损失，如果让程序崩溃或死机，至少客户会选择其他计算器或计算方式而不会造成后面更严重的损失。</p><p>另外数据异常这种问题通常很难发现，很容易成为线上BUG导致糟糕的用户体验(<code>建议大家平常使用单元测试来对代码进行定期体检，这样能大大降低类似的这种错误</code>)。</p><p>在Swift中，如果你对一个无符号类型(<code>UInt</code>)变量不小心赋值了负数的话，将会得到一个运行时崩溃，说明数据异常确实比APP崩溃更严重。</p><h2 id="题外话-为什么要使用补码"><a href="#题外话-为什么要使用补码" class="headerlink" title="题外话(为什么要使用补码)"></a><span id = "jump1">题外话(为什么要使用补码)</span></h2><p>由于加法和减法这种操作非常频繁，为了提高运算效率，所以它们一般都由硬件直接支持；如果直接使用原码存储的话，在计算类似 <code>6 - 18</code> 这样的表达式时将会得到错误的结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 - 18 = 6 + (-18)</span><br><span class="line">= 0000 0000 0000 0110(原) + 1000 0000 0001 0010(原)</span><br><span class="line">= 1000 0000 0001 1000(原)</span><br><span class="line">= -24</span><br></pre></td></tr></table></figure><p>很明显计算结果是不对的，于是有些人设计出了反码，用反码计算确实解决了 <code>6 - 18</code> 的问题，但是类似 <code>18 - 6</code> 这样的计算又出错了：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">18 - 6 = 18 + (-6)</span><br><span class="line">= 0000 0000 0001 0010(原) + 0000 0000 0000 0110(原)</span><br><span class="line">= 0000 0000 0001 0010(反) + 1111 1111 1111 1001(反)</span><br><span class="line">= 1 0000 0000 0000 1011(反) </span><br><span class="line">= 0000 0000 0000 1011(反) // 最左边的1内存容纳不了，所以直接截掉。</span><br><span class="line">= 0000 0000 0000 1011(原)</span><br><span class="line">= 11</span><br></pre></td></tr></table></figure><p>计算结果离正确值还差1，__如果按照反码计算的话，小数减去大数会正确，但大数减去小数就始终会相差1__，还是那群人，又绞尽脑汁的设计出了补码(<code>该设计者因此获得了图灵奖</code>)。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">18 - 6 = 18 + (-6)</span><br><span class="line">= 0000 0000 0001 0010(原) + 0000 0000 0000 0110(原)</span><br><span class="line">= 0000 0000 0001 0010(反) + 1111 1111 1111 1001(反)</span><br><span class="line">= 0000 0000 0001 0010(补) + 1111 1111 1111 1010(补)</span><br><span class="line">= 1 0000 0000 0000 1100(补)</span><br><span class="line">= 0000 0000 0000 1100(补) // 最左边的1内存容纳不了，所以直接截掉。</span><br><span class="line">= 0000 0000 0000 1100(反)</span><br><span class="line">= 0000 0000 0000 1100(原)</span><br><span class="line">= 12</span><br></pre></td></tr></table></figure><p>结果终于正确了，如果大家感兴趣的话可以手动计算一下 <code>13 - 5</code>、<code>5 - 13</code> 等等来巩固你学到的知识。</p><blockquote><p>计算机的设计是一门艺术，很多实用的技术都是权衡和妥协的结果。</p></blockquote><p>如果你还是不理解的话，建议你看看 <a href="http://c.biancheng.net/view/vip_1761.html">整数在内存中是如何存储的，为什么它堪称天才般的设计</a>(<code>这是一篇付费文章，如果你不想付费的话请自行百度搜索关键字</code>)。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>不要把无符号数、有符号数和正数、负数搞混，无符号数肯定是正数，但有符号数未必是负数。</p><p>计算机是对正数和负数的读写规则不一样，不是对无符号数和有符号数的读写规则不一样。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Code Review规范</title>
      <link href="/2022/01/20/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/Code%20Reivew%E8%A7%84%E8%8C%83/"/>
      <url>/2022/01/20/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/Code%20Reivew%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由 布多(budo) 发布于 2022-01-20</p></blockquote><blockquote><p>本文的名词解释：</p><ul><li>CR：code review</li><li>CL：change list(指这次改动)</li></ul></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章是站在公司的角度基于 Google的代码审查指南 和笔者实际经验的个人总结，所以相对原文(Google的代码审查指南)有适当的删减，想看完整版的请阅读<a href="https://google.github.io/eng-practices/review/reviewer/">Google的代码审查指南</a>。</p><p>该规范的目的旨在提高公司内部项目的代码库质量。</p><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><ol><li><p>技术事实和数据应该凌驾于意见和个人偏好之上；在代码风格方面，风格指南是绝对权威，任何不在指南中的点(如空格等)都是个人偏好的问题，这些点原则上应该与现有的风格保持一致，但是如果这些点现在还没有形成一定的风格，那么应该接受作者的风格。</p></li><li><p>软件设计的各个方面几乎从来不是纯粹的风格问题，也不只是个人偏好，它们是建立在基本原则的基础上的，应该在这些原则的基础上加以衡量，而不仅仅是只考虑个人意见。有时，如果作者能够证明(通过数据或基于可靠的工程原理)它的方法是同样有效的，那么审查者应该接受作者的偏好。否则，审查者的选择应该取决于软件设计的标准原则。</p></li></ol><h3 id="CR的标准"><a href="#CR的标准" class="headerlink" title="CR的标准"></a>CR的标准</h3><ol><li><p>Code Reivew的主要目的是确保代码库的 <strong>整体代码</strong> 运行状况随着 <strong>时间的推移</strong> 而 <strong>得到改善</strong>，Code Review的所有工具和流程都为此而设计。</p></li><li><p>为了实现这个目标，必须 <strong>综合考虑许多因素</strong>，并且做出 <strong>取舍和平衡</strong>。</p></li><li><p>审查者有责任确保每个CL都具有这样的质量：即随着时间的推移，代码库的整体代码健康状况不会降低。这可能会很棘手，特别是当团队的交付受到严重的时间限制并且他们觉得必须采取捷径才能实现目标时。</p></li><li><p>没有 <strong>完美</strong> 的代码，只有 <strong>更好的代码</strong>，审查者应该权衡发展的需要和别人的建议；不应该追求完美，而应追求持续改进，作为一个整体，如果CL能提高整个系统的可维护性、可读性、可理解性，那么不应该因为它不 “完美” 而拒绝。</p></li><li><p>如果开发人员有些地方做的很好，应该告诉并鼓励开发人员，但是如果这个改进不是很重要，可以告诉作者这种改进只是一种锦上添花的效果，作者可以选择忽略避免重复工作。</p></li></ol><h3 id="CR关注点"><a href="#CR关注点" class="headerlink" title="CR关注点"></a>CR关注点</h3><ol><li><p>在CR中最重要的是看CL的整体设计与结构。CL中不同代码段的交互是否有意义？它与系统的其他部分是否集成良好？现在是添加此功能的合适时机吗？</p></li><li><p>审查者应该按照 <a href="https://juejin.cn/post/7018484631057989663"><strong>风格指南</strong></a>、<a href="https://juejin.cn/post/7055164422662127647"><strong>开发规范</strong></a> 进行检查。</p></li><li><p>审查者应该考虑一些边缘状况，寻找并发性问题，尝试像用户一样思考，并确保不会看到仅通过阅读代码就能发现的错误。</p></li><li><p>审查者应该严查使用了设计模式的地方(例如使用了单例，那么就检查是否一定需要使用)。</p></li><li><p>如果有必要的话可以自己去验证CL。有些时候在阅读代码时，很难理解某些更改会对用户产生怎样的影响，例如UI更改。对于这样的更改，如果不方便自己测试，可以让开发人员演示该功能。</p></li><li><p>在CR期间另一个特别重要的事情是查看代码中是否存在某种 <strong>并发编程</strong>，理论上可能导致死锁或竞争条件，这些类型的问题很难通过运行代码来检测，通常需要有人(开发人员或审查者)仔细考虑它们以确保不会引入问题。</p></li></ol><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ol><li><p>代码的复杂度是否超过预期？有没有更简单的实现方式？单行代码是否过于复杂？函数或方法是否过于复杂？类是否过于复杂？“复杂” 通常意味着该代码很难阅读，也意味着 “当开发人员试图调用或修改这段代码时，他们很可能会引入BUG”。</p></li><li><p>有一种复杂性是过度设计造成的，开发者让那段代码过度通用化，超过了原本所需要的，或者是增加了系统目前不需要的功能；审查者应特别注意一下过度设计，鼓励开发者解决他们现在需要解决的问题，而不是推测将来可能需要解决的问题，当那些问题出现的时候再去解决它们，因为那个时候你可以更清晰的看见问题的样子。</p></li></ol><h3 id="如何浏览CL"><a href="#如何浏览CL" class="headerlink" title="如何浏览CL"></a>如何浏览CL</h3><ol><li><p>用宏观的角度来看待改动，查看CL描述以及它做了什么。</p></li><li><p>找到CL最核心的部分文件，首先查看这些主要部分。这有助于为CL的其他较小部分提供逻辑，而且这样可以提高CR速度。如果CL太大导致无法确定哪里是主要部分时，请向开发者询问重要的部分，或者要求他们将CL拆分为多个CL。如果在主要部分发现存在主要的设计问题，应该立即告诉开发者修改。因为如果设计问题足够严重的话，继续CR其他部分的代码可能只是浪费时间。</p></li></ol><h3 id="浏览每一行代码"><a href="#浏览每一行代码" class="headerlink" title="浏览每一行代码"></a>浏览每一行代码</h3><ol><li><p>仔细审查每一行代码。有些东西，例如资料文件、生成的代码、大型数据结构，你可以稍微扫过，但是不要扫过开发者写的类、函数、方法、代码区块，更不能假设它内部是没问题的。</p></li><li><p>如果代码过于复杂并且需要减慢审查速度时，那么请你告诉开发者这件事，让他们为这段代码做出解释。你要求开发者去说清楚这段代码时，同时也在帮助未来的开发人员理解这些代码。</p></li></ol><h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><ol><li>请结合上下文查看CL，该CL是否改善了整体系统的代码质量，会不会让整个系统更加复杂？是否缺少测试？千万不要授受会降低整体系统代码质量的CL。因为大多数系统是由于许多小改动的累积而变得复杂的。</li></ol><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ol><li><p>一般来说，测试应该添加到与生产代码相同的CL中，除非CL正在处理紧急情况。</p></li><li><p>审查者有必要确保测试是正确、合理、有用的。当代码真的有问题，测试是否会失败？如果被测试的程序发生改动时，测试是否会产生误报？每一个测试是否做出了简单而有用的断言？不同的测试方法之间是否适当分开？</p></li><li><p>请记住，测试代码也是需要维护的代码。不要因为测试不是主分支的一部分就接受测试中的复杂性。</p></li></ol><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><ol><li><p>在CR中遇到任何冲突，首先应该是开发人员和审查者通过本文档的内容和代码规范尝试达成共识。</p></li><li><p>当达成共识比较困难时，审查者可以和作者进行面对面沟通。如果还不能解决问题，可以让更多的人(例如项目管理者)参与进来一起讨论解决冲突。</p></li></ol><h3 id="紧急状况"><a href="#紧急状况" class="headerlink" title="紧急状况"></a>紧急状况</h3><ol><li><p>紧急提交历史只能是一个小的更改：修复严重影响生产中用户的错误，处理紧迫的法律问题，关闭主要的安全漏洞等。</p></li><li><p>在紧急情况下，我们更关心整个代码审查过程的速度，仅在这种情况下，审查者应该更关心审查的速度和代码的正确性(它是否真的解决了紧急情况？)而不是其他任何事情。此外这种审核应该优先于所有其他代码审查。</p></li><li><p>但是，在紧急情况解决后，您应该再次查看紧急情况提交历史并对其进行更彻底的审查。</p></li></ol><h3 id="什么不是紧急情况？"><a href="#什么不是紧急情况？" class="headerlink" title="什么不是紧急情况？"></a>什么不是紧急情况？</h3><ol><li>以下情况不是紧急情况：<ul><li>想要在本周而不是下周发布(除非有一些实际的硬性发布期限，例如合同协议)。</li><li>开发人员已经在一个功能上工作了很长时间，他们很想审查通过。</li><li>今天是星期五，在开发人员开始周末之前审查通过会很棒。</li><li>……</li></ul></li></ol><h3 id="什么是硬期限？"><a href="#什么是硬期限？" class="headerlink" title="什么是硬期限？"></a>什么是硬期限？</h3><ol><li><p>硬期限指的是严格的截止日期，如果您错过它就 <strong>会发生灾难性事情</strong> 的截止日期。例如：</p><ul><li>为了履行合同义务，必须在某个日期之前完成。</li><li>如果未在特定日期之前发布，您的产品将在市场上完全失败。</li><li>一些硬件制造商每年只发货一次新硬件，如果您错过了向他们提交代码的截止日期，那可能是灾难性的。</li><li>……</li></ul></li><li><p>大多数截止日期都是软截止日期，而不是硬截止日期；它们代表了在某个时间完成某项功能的愿望，它们很重要，但不应该牺牲代码质量来达到目的。</p></li></ol><h3 id="CR太严格被抱怨怎么办？"><a href="#CR太严格被抱怨怎么办？" class="headerlink" title="CR太严格被抱怨怎么办？"></a>CR太严格被抱怨怎么办？</h3><ol><li><p>提高CR的速度通常会让这些抱怨逐渐消失。可能需要数个月，但最终开发人员会看到严格的CR所带来的价值，因为严格的CR会帮助他们产生更优秀的代码。</p></li><li><p>如果你遵循这些准则，并且如果CR非常严格的话，后面你会发现整个CR流程会越来越快。因为开发者会知道什么是质量好的代码，并且在开始就提交一个很棒的CL。但不要为提高想象中的速度，而对CR标准和代码质量做出妥协，毕竟从长远来看它实际上并不会让任何事情发生的更快。</p></li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><ol><li>可以转载，但是请注明来源。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://google.github.io/eng-practices/review/reviewer/">Google的代码审查指南</a></li><li><a href="https://juejin.cn/post/7460478066612977704">Code Review：提升代码质量与团队能力的利器作者- 掘金</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发规范 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ObjC 开发规范</title>
      <link href="/2022/01/20/iOS/ObjC%20%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
      <url>/2022/01/20/iOS/ObjC%20%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由 布多(budo) 发布于 2022-01-20 • 最后更新于 2025-02-13</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章是基于笔者个人经验以及一些开发规范总结而成，目的是提高公司内部项目的稳定性与效率。<br>文章的前半部分是一些通用开发规范，适用于所有编程语言甚至是生活中遇到的问题；<br>后半部分是关于OC的开发规范以及开发中容易犯的错误，如果不想看可以跳过。</p><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><p>我们无法写出完全没有BUG的代码，但是我们可以尽量写出容易阅读和逻辑简单清楚的代码，容易阅读和逻辑简单清楚的代码从某种程度上会减少BUG以及BUG的修复难度。</p><h2 id="通用规范"><a href="#通用规范" class="headerlink" title="通用规范"></a>通用规范</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">虽然BUG无法完全避免，但是我们可以遵循一些规范和规则让BUG尽早暴露，或者让它便于排查。</span><br></pre></td></tr></table></figure><ul><li><p><strong>[必须]</strong> 开发完一个模块(<code>功能、页面等等</code>)时，自测一遍，确认没有问题后再开发下一个模块，如果一个模块很大，可以完成一个小功能时自测一遍，不要把所有问题都放到最后测试，更不要依赖测试人员。</p></li><li><p><strong>[必须]</strong> 禁止实现未来可能需要的功能，如果这个功能现在不需要就不要实现它，等未来需要的时候再去实现它，因为那个时候你可以更清晰的看到那个功能完整的模样(<code>如果必须要实现它，必须要考虑所有可能发生的情况以及细节，并且加上注释说明</code>)。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">实现一个未来可能需要的功能在大部分情况下都是得不偿失的，有以下缺点：</span><br><span class="line">1. 未来可能不需要这个功能。</span><br><span class="line">2. 增加垃圾代码，当别人看见这段代码时不理解为什么要这么写。</span><br><span class="line">3. 增加维护成本和开发时间(即使某段代码不使用也是需要维护的)。</span><br><span class="line">4. 后期真正要用的时候可能会发现当初实现的时候考虑不全面，最后还是要重新写一遍。</span><br><span class="line">5. ……</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 不要尝试去推测并解决未来可能发生的问题，等问题出现的时候再去解决它，因为那个时候你可以更清晰的看见问题的真实样子。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">这个规则不是说要你发现问题了不去解决等到被别人发现提出后再解决；</span><br><span class="line">现实生活中有一些完美主义者想让自己写的代码非常完美没有任何问题，所以他们会尽</span><br><span class="line">量假设各种各样的情况，甚至很多极端情况，有时候会为了一个发生概率很小并且</span><br><span class="line">影响不是很重要的问题而大改特改，直到满意为止，这么做很可能会影响别人甚至导致项目延迟上线。</span><br><span class="line">在修改过程中如果改动的范围特别大还可能会引进新的问题，而且由于这个问题是未来</span><br><span class="line">可能会发生的问题，所以可能还会有你没考虑到的地方，最后既引进了新的问题还可能没解决问题。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 对于服务端返回的值，永远不要假设它是正确的类型和值(<code>即使服务端的人保证</code>)，使用之前必须检查它的真实类型和值是否符合预期。</p></li><li><p><strong>[必须]</strong> 不要让代码脱离开发者的掌控。当我们开发一个功能时，总是希望让使用者调用更少的API或者自动调用，但是有些步骤让使用者主动调用会更好一些，这样使用者知道他干了什么，而不是出了问题时一头雾水，当你把某个步骤设置成自动调用时想一下这是否有必要？如果不是请让使用者主动调用它并在文档中加以说明。</p></li><li><p><strong>[必须]</strong> 所见即所得，例如页面上2个控件的间距是10，那么代码中的间距设置也应该是10，而不应该是一个控件很高，有很多的空白区域，然后用-xx(负间距)去填充。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">UILabel *label1 = [[UILabel alloc] init];</span><br><span class="line">label1.frame = CGRectMake(0, 0, 100, 30);</span><br><span class="line"></span><br><span class="line">UILabel *label2 = [[UILabel alloc] init];</span><br><span class="line">label2.frame = CGRectMake(0, 30 + 10, 100, 30);</span><br><span class="line">上述代码明显的告诉你 label2 的顶部和 label1 的底部间距为10。</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">UILabel *label1 = [[UILabel alloc] init];</span><br><span class="line">label1.frame = CGRectMake(0, 0, 100, 30);</span><br><span class="line"></span><br><span class="line">UILabel *label2 = [[UILabel alloc] init];</span><br><span class="line">label2.frame = CGRectMake(0, -20, 100, 90);</span><br><span class="line">假设文字实际展示需要 30 高度，上述代码和正例中的代码给用户的感觉是一样的，</span><br><span class="line">但是阅读性却非常差。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 一般情况下禁止使用过时的方法或类，应该及时去了解和使用新方法或类。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">对于过时的方法或类，大都是因为其自身有缺陷或BUG，</span><br><span class="line">使用新方法前建议了解一下旧方法/类废弃的原因。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 尽量不要使用runtime去交换方法，可以使用中间者模式或者其他方法代替，如果一定要这么做，那么请留下注释说明交换方法后做了什么，以及为什么要这么做？</p></li><li><p><strong>[必须]</strong> 尽量不要直接使用成员变量，而是使用属性替代它。</p></li><li><p><strong>[必须]</strong> 在dealloc方法内禁止将self传递出去，如果self被retain，到下个runloop周期再释放则会多次释放导致crash。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反例：</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [self unsafeMethod:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 对剪切板的读取操作必须放在子线程中进行，因为用户可能在Mac上复制大量数据然后通过接力同步到iPhone上。</p></li><li><p><strong>[必须]</strong> 当方法可能会提前return时，需要注意对象的释放问题，避免内存泄漏。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反例：</span><br><span class="line">CFArrayRef arrayRef = (__bridge CFArrayRef)array;</span><br><span class="line"></span><br><span class="line">if (x == YES) return;</span><br><span class="line"> </span><br><span class="line">CFRelease(arrayRef);</span><br><span class="line"></span><br><span class="line">如果if条件成立那么arrayRef对象就会内存泄漏。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 使用@try处理异常时，需要注意对象的释放问题，避免内存泄漏。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反例：</span><br><span class="line">@try &#123;</span><br><span class="line">CFArrayRef arrayRef = (__bridge CFArrayRef)array;</span><br><span class="line">    </span><br><span class="line">do some thing……</span><br><span class="line"></span><br><span class="line">CFRelease(arrayRef);</span><br><span class="line">        </span><br><span class="line">&#125; @catch (NSException *exception) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果do some thing……出现异常的话那么arrayRef就会出现内存泄漏。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 如果使用到的值和另一个值有所关联，在代码中体现出这种关联性，这能增加代码可读性，也能增加代码稳定性。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">例如有1个头像控件需要显示为圆形，我们经常会这样设置：</span><br><span class="line">1. 给头像控件设置圆角：layer.cornerRadius = 15.0;</span><br><span class="line">2. 给头像控件设置宽高：.frame = CGRectMake(0, 0, 30.0, 30.0);</span><br><span class="line">// 上述代码中的15.0 和 30.0 就没有任何关联性，如果它们之间相隔了很多代码，</span><br><span class="line">   修改宽高的时候可能会忘记修改cornerRadius。</span><br><span class="line">   </span><br><span class="line">正例：</span><br><span class="line">1. 给头像控件设置圆角：layer.cornerRadius = 15.0;</span><br><span class="line">2. 给头像控件设置宽高：.frame = CGRectMake(0, 0, layer.cornerRadius * 2.0, layer.cornerRadius * 2.0);</span><br><span class="line">// 这样后面阅读代码的人一眼就能明白宽高和 layer.cornerRadius 的关系，既增加了可读性，又增加了稳定性。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 如果一个值需要特别多个变量计算出来，请把它们提取成一个变量并且加上注释说明这个变量是怎么组成的。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">// 屏幕宽度 - label左边距 - label右边距 - 开关按钮宽度 - 按钮右边距</span><br><span class="line">    CGFloat titleMaxWidth = kScreenWidth - labelLeftSpacing - labelRightSpacing - buttonWidth - buttonRightSpacing;</span><br><span class="line"></span><br><span class="line">// 这样写的好处在于以后如果需要修改某个控件的布局信息，只需要修改一处即可，降低了后续维护难度。</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 声明常量尽量使用const类型，不要使用#define。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips: </span><br><span class="line">宏定义声明常量的缺点：</span><br><span class="line">1. 宏定义只是简单的替换，缺少编译检查，运行期可能会出现溢出或数据错误等问题。</span><br><span class="line">2. 宏定义缺少类型，不方便编写文档用例。</span><br><span class="line">3. 宏定义可能会被替换。</span><br><span class="line">4. 宏定义无法编写符合规范的注释信息。</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">#define kTime @&quot;10&quot;</span><br><span class="line">    </span><br><span class="line">if (NO) &#123;</span><br><span class="line">#define kTime @&quot;20&quot;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">NSLog(@&quot;time = %@&quot;, kTime);</span><br><span class="line"></span><br><span class="line">即使if永远不会执行，但是编译器也会将kTime替换为@&quot;20&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 工具类尽量在头文件的注释中写清楚该功能如何使用，以及需要注意的事项。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">1. 如果是一个UI工具，使用时是否需要提前设置frame，是否可以使用约束布局？</span><br><span class="line">2. 对于一些比较复杂的工具，最好在注释中给出一段示例代码。</span><br><span class="line">包括但不限于上述的注意事项，</span><br><span class="line">例如一个封装好的弹窗工具，应该说明如何弹出，是否需要提前设置frame或者约束</span><br><span class="line"></span><br><span class="line">以下是一个简单的示例伪代码:</span><br><span class="line">/**</span><br><span class="line">* @brief UIActivityIndicatorView的增强版，和UIActivityIndicatorView使用方式一致，但扩展了一些额外功能。</span><br><span class="line">* @discussion 1. 除了可以自定义颜色之外，还可以自定义指示器的详细大小(例如指示器宽度、高度、离心距离等)。</span><br><span class="line">* @discussion 2. 内部会自动计算控件所需要的最小宽高，可以不设置宽高约束或宽高Frame。</span><br><span class="line">* @discussion 3. 可以暂停/恢复指示器动画。</span><br><span class="line">* @code</span><br><span class="line">* LLActivityIndicatorView *activityIndicatorView = [LLActivityIndicatorView activityIndicatorWithStyle:LLActivityIndicatorViewStyleGrayMedium];</span><br><span class="line">* activityIndicatorView.backgroundColor = UIColor.redColor;</span><br><span class="line">* activityIndicatorView.frame = CGRectMake(0, 0, 50, 50);</span><br><span class="line">* activityIndicatorView.center = self.view.center;</span><br><span class="line">* [self.view addSubview:activityIndicatorView];</span><br><span class="line">* [activityIndicatorView startAnimating];</span><br><span class="line">* @encode</span><br><span class="line">*/</span><br><span class="line">@interface LLActivityIndicatorView : UIView</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 不要滥用懒加载，只在必要时刻使用它。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">只在以下三种情况下才使用懒加载：</span><br><span class="line">1. 对象的创建需要依赖其他对象</span><br><span class="line">2. 对象可能被使用，也可能不被使用</span><br><span class="line">3. 对象创建比较消耗性能</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 使用NSUserDefaults存储数据时禁止调用synchronize方法，因为系统会在合适的时机将数据保存到本地(即使程序闪退等极端情况)。</p></li><li><p><strong>[建议]</strong> 对于一些体积小并且不是特别重要的数据，不要频繁的进行写入操作，可以使用NSUserDefaults。它会在合适的时机将数据存储到本地，这避免了频繁的写入操作，而且在某些极端情况下它也能保证数据存储到本地(例如程序闪退等情况)。</p></li><li><p><strong>[必须]</strong> 添加到集合中的对象应该是不可变的，或者在加入之后其哈希值是不可变的。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反例：</span><br><span class="line">NSMutableSet *sets = [NSMutableSet set];</span><br><span class="line">NSMutableString *string1 = [NSMutableString stringWithString:@&quot;1&quot;];</span><br><span class="line">[sets addObject:string1];</span><br><span class="line">[sets addObject:@&quot;12&quot;];</span><br><span class="line">    </span><br><span class="line">[string1 appendString:@&quot;2&quot;];</span><br><span class="line"></span><br><span class="line">当 [string1 appendString:@&quot;2&quot;] 执行完以后sets对象内会包含2个@&quot;12&quot;。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 不可变对象请使用copy修饰，如果重写set方法，请注意调用copy方法。</p></li><li><p><strong>[必须]</strong> 请使用CGRectGet函数获取Frame的各种值，而不是通过frame.的方式获取。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">CGRect t_frame = CGRectMake(-10, -10, -10, -10);</span><br><span class="line">当一个view的frame设置成t_frame后，其坐标会隐式的转换为CGRectMake(-20, -20, 10, 10)，</span><br><span class="line">因为宽高不可能出现负值；</span><br><span class="line">这时通过t_frame.的方式获取的值都是错误的，而CGRectGet会自动帮您处理这些隐式转换。</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line">CGRectGetWidth(frame)、CGRectGetMinX(frame)、CGRectGetMaxX(frame)</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">frame.size.width、frame.origin.x、frame.size.width + frame.origin.x</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 代码中单行字符数不要超过150个，超过请换行(空格除外)，可以在 Xcode -&gt; Preferences… -&gt; Text Editing -&gt; Page guide at column 中设置为150方便排查。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">- (void)setImageWithURL:(nullable NSURL *)imageURL</span><br><span class="line">            placeholder:(nullable UIImage *)placeholder</span><br><span class="line">                options:(YYWebImageOptions)options</span><br><span class="line">               progress:(nullable YYWebImageProgressBlock)progress</span><br><span class="line">               ransform:(nullable YYWebImageTransformBlock)transform</span><br><span class="line">             completion:(nullable YYWebImageCompletionBlock)completion;</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 单个方法的行数建议不超过80行，注释、左右大括号、空行、回车等除外。</p></li><li><p><strong>[必须]</strong> 在多线程环境下谨慎使用可变集合，必要时候可以采用加锁或GCD的同步线程进行保护，或者在访问可变集合时先将其copy为不可变对象然后再对其访问。</p></li><li><p><strong>[必须]</strong> 属性和方法必须有 <strong>nullable</strong> 或 <strong>nonnull</strong> 限定符，由于OC是动态语言，所以即使使用 <code>nonnull</code> 声明对象不为空，使用前也必须判断是否为空。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">- (void)setName:(NSString * _Nonnull)name &#123;</span><br><span class="line">    if (name == nil) &#123;</span><br><span class="line">      ………</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 如果有使用到数组、字典等类型，尽量使用泛型声明其包含的类型，这样可以提高代码可读性。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">NSArray&lt;NSString *&gt; *array;</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">NSArray *array;</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 如果类中包含多个初始化方法，请使用 <code>NS_DESIGNATED_INITIALIZER</code> 和 <code>NS_UNAVAILABLE</code> 宏标记提高代码可读性。</p></li><li><p><strong>[必须]</strong> 避免使用无符号整数(除非匹配系统接口使用的类型)，在工程中全部使用一种类型可以提高代码安全与一致性，无符号整数在进行数学运算和倒数到零的时候会出现细微的错误。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">NSUInteger numberOfObjects = array.count;</span><br><span class="line">for (NSInteger counter = numberOfObjects - 1; counter &gt; 0; counter--)</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">for (NSUInteger counter = numberOfObjects - 1, counter &gt; 0; counter--)</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 在自动引用计数下，OC对象会自动初始化为nil，但是有些对象不会自动初始化为nil，例如CoreFoundation中的对象，所以在声明局部对象时需要手动初始化。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">NSObject *obj = nil;</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">NSObject *obj;</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 不要使用一个类去维护多个类的内容，例如使用一个常量类维护所有的常量，要按功能进行归类，分开维护。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips: </span><br><span class="line">大而全的类，杂乱无章，使用查找功能才能定位到具体位置，不利于理解也不利于维护。</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line">缓存相关常量类放在CacheConsts下，系统配置相关常量类放在SystemConfigConsts下。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 如果超类的某个初始化方法不适用于子类，那么子类一定要重写超类的这个方法解决问题或抛出异常。</p></li><li><p><strong>[必须]</strong> 把一些稳定的、公共的变量或者方法抽取到父类中。子类尽量只维持父类所不具备的特性和功能。</p></li><li><p><strong>[必须]</strong> 禁止将布尔对象直接和 YES 或者 NO进行判断，例如 &#x3D;&#x3D; YES， !&#x3D; YES，&#x3D;&#x3D; NO，!&#x3D; NO。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">在32位机器上YES被定义为1，NO定义为0；</span><br><span class="line">而64位机器上YES被定义为非0，NO定义为0；</span><br><span class="line"></span><br><span class="line">BOOL result = 4;</span><br><span class="line"></span><br><span class="line">if (result == YES) &#123;</span><br><span class="line">    NSLog(@&quot;YES&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    NSLog(@&quot;NO&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">以上代码在64位机器会输出YES，而上32位机器上则会输出NO。因为在32位机器上 </span><br><span class="line">(result == YES) 会被解释为 (4 == (signed int) 1)，</span><br><span class="line">所以会输出NO，而在64位机器上会认为result不等于0所以输出YES。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 删除代码时将内部用到的无用文件、无用类、无用函数等统一删除干净。</p></li><li><p><strong>[建议]</strong> 如果可以，尽量使用 #undef 限制宏的作用范围。</p></li><li><p><strong>[建议]</strong> 局部变量尽量定义在最靠近使用它的地方。</p></li><li><p><strong>[建议]</strong> 在写一些简单的类方法和宏方法时，尽量使用内联函数或全局函数代替它。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">函数不通过对象调用，所以不会走OC的消息转发流程，效率高于方法调用；</span><br><span class="line">而且函数会有返回值和参数类型以及参数检查，这些都是宏定义没有的。</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line">UIKIT_STATIC_INLINE NSString * kNSStringFromInteger(NSInteger a) &#123;</span><br><span class="line">    return [NSString stringWithFormat:@&quot;%zd&quot;, a];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">#define kNSStringFromInteger(a) [NSString stringWithFormat:@&quot;%zd&quot;, a]</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 如果用到了很多协议，必要时可以把协议封装到一个单独的头文件中，这样做不仅可以减少编译时间，还能避免循环引用。</p></li><li><p><strong>[建议]</strong> 使用switch枚举时尽量将所有枚举类型都case出来而不要使用default，这样的话以后增加或删除枚举类型时如果switch没有处理的话编译器会有警告提醒。</p></li><li><p><strong>[建议]</strong> 尽量使用字面量语法创建对象，少用与之等价的方法。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">OC中的NSArray、NSString、NSDictionary、NSNumber都有与之对应的字面量语法: @[]、@&quot;&quot;、@&#123;&#125;、@()；</span><br><span class="line">使用它们有以下优点：</span><br><span class="line">1. 简单易读，提高代码的可读性和维护性。</span><br><span class="line">2. 使用字面量创建数组、字典时如果元素里在nil则会抛出异常，</span><br><span class="line">   而使用arrayWithObjects:方法创建则会丢失nil后的数据，</span><br><span class="line">   抛出异常能让你知道这里有问题及时修改防止问题在线上发生。</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">1. 使用字面量创建的对象默认是不可变的，如果要创建可变对象需要进行mutableCopy操作。</span><br><span class="line">2. 不支持子类，如果你创建了一个NSString的子类，@&quot;&quot;并不会返回你想要的子类对象。</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> UI控件尽量使用weak修饰而不是strong修饰，这样对梳理对象引用会更清晰明了。</p></li><li><p><strong>[建议]</strong> 尽量不要使用+load方法，如果必须要使用那么不要在方法内实现复杂逻辑或堵塞线程。</p></li><li><p><strong>[建议]</strong> 尽量减少继承层级，类的继承建议不要超过3层，必要时刻可以考虑用分类、协议来代替继承。</p></li></ul><h2 id="头文件规范"><a href="#头文件规范" class="headerlink" title="头文件规范"></a>头文件规范</h2><ul><li><p><strong>[必须]</strong> 头文件中尽量不要直接引用其他头文件，而是使用@class向前声明，每次引入其他头文件时先问问自己是否必须要这样做。</p></li><li><p><strong>[建议]</strong> 头文件中暴露的方法和属性尽可能少，例如外部只需要覆值操作，那就不要提供getter方法或者属性。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">@interface BookView : NSObject</span><br><span class="line"></span><br><span class="line">- (void)setBookName:(NSString *)bookName;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">@interface BookView : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSString *bookName;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 头文件中的属性尽量声明为只读，可以在实现文件中再将属性声明为可读可写。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">@interface WXYZModel : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, readonly) NSString *name;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface WXYZModel ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSString *name;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation WXYZModel</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li></ul><h2 id="Block开发规范"><a href="#Block开发规范" class="headerlink" title="Block开发规范"></a>Block开发规范</h2><ul><li><p><strong>[必须]</strong> 在Block内部使用上下文的对象时要注意相互引用的问题(<code>不一定要在 block 内使用 self 才会相互引用</code>)。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips: </span><br><span class="line">1. 不一定在Block内使用self才会相互引用，如下情况也会造成循环引用:</span><br><span class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">    WXYZ_TitleTableViewCell *cell = ………</span><br><span class="line">    </span><br><span class="line">    cell.refreshTableViewBlock = ^&#123;</span><br><span class="line">        [tableView reloadData];</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    return cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2. Block内部是否要使用weak需要看Block本身和weak的这个对象是否存在直接或间接的相互引用，</span><br><span class="line">   若无相互引用则不需要使用weak。</span><br><span class="line"></span><br><span class="line">3. 如果Block内部使用了strong修饰了外部的weak变量，那么当使用strong指向成员变量时需要进行判空，否则会崩溃，参考以下代码:</span><br><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">    cell.refreshTableViewBlock = ^&#123;</span><br><span class="line">        __strong typeof(weakSelf) strongSelf = weakSelf;</span><br><span class="line">        if (strongSelf != nil) &#123;</span><br><span class="line">            strongSelf-&gt;_name = @&quot;name&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">如果把(strongSelf != nil)的判断去掉那么可能会崩溃。</span><br></pre></td></tr></table></figure></li></ul><h2 id="通知开发规范"><a href="#通知开发规范" class="headerlink" title="通知开发规范"></a>通知开发规范</h2><ul><li><p><strong>[必须]</strong> 在发送通知时，请使用<code>userInfo</code>对象进行传值，而不是<code>object</code>。</p></li><li><p><strong>[必须]</strong> 避免重复注册通知，这会导致重复执行通知方法。</p></li><li><p><strong>[必须]</strong> 在使用通知的<code>object</code>参数时，需要确保接收方和发送方的object对象类型是一致的。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反例：</span><br><span class="line">[NSNotificationCenter.defaultCenter addObserver:self selector:@selector(testFunction) name:@&quot;testNotificationName&quot; object:model.bookID];</span><br><span class="line">[NSNotificationCenter.defaultCenter postNotificationName:@&quot;testNotificationName&quot; object:@&quot;123&quot;];</span><br><span class="line"></span><br><span class="line">假设 model.bookID 的值就是字符串123，也可能无法收到通知，</span><br><span class="line">因为NSString有__NSCFConstantString， __NSCFString， NSTaggedPointerString等多个子类对象，</span><br><span class="line">如果 model.bookID 的真实对象类型是 NSTaggedPointerString 的话就会收不到通知。</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 在工程里能不用通知尽量不用通知，通知虽然灵活强大，但是如果滥用会导致工程质量下降并且增加维护难度。</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://book.douban.com/subject/25829244/">Effective Objective-C 2.0  编写高质量iOS与OS X代码的52个有效方法</a></li><li><a href="https://google.github.io/styleguide/objcguide.html">Google的Objective-C风格指南</a></li><li><a href="https://google.github.io/eng-practices/review/reviewer/">Google的代码审查指南</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 开发规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ObjC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git命令手册</title>
      <link href="/2021/08/11/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/"/>
      <url>/2021/08/11/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由 布多(budo) 发布于 2021-08-11</p></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr><p>&nbsp;&nbsp;&nbsp;&nbsp;该手册(以下简称它)不是Git入门教程，如果您想入门Git推荐<a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰的Git教程</a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;这只是一篇个人学习Git时顺带记录的命令手册以及对Git的一些理解心得，如有不正确的地方欢迎大家留言指正。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;它包含了Git几乎所有的高级命令和部分底层命令，每个命令都有详细的解释和示例告诉您如何使用，以及使用时需要注意的地方；内容按模块划分，比如和<code>add</code>相关的命令就都会集中在一个模块，大家可以选择自己感兴趣的模块自由阅读，由于某些命令的选项非常多但是并不常用，所以该手册可能没有记录，如果想查看某个命令的所有选项请查阅<a href="https://git-scm.com/docs">Git命令参考</a>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;有些比较简单的命令这里可能没有记录，文章中的()表示的是全称，例如{u(upstream)}，表示upstream是u的全称，实际使用的时候用@{u}或者@{upstream}都可以。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Git本身是一个内容寻址文件系统，Git的核心部分是一个简单的键值对数据库，你可以向Git仓库中插入任意类型的内容，它会返回一个唯一的键，通过该键可以在任意时刻再次取回该内容。</p><blockquote><p>Tips： </p><ol><li><p>Git里一些同名的选项在相似的地方也可以使用。例如<code>--abort</code>选项，和<code>git merge --abort</code>搭配可以撤销合并操作，和<code>git rebase --abort</code>搭配可以撤销rebase操作。</p></li><li><p>Git里的大部分选项都是可以搭配一起使用的，例如<code>git log --author=&#39;internetwei&#39; --after=&quot;2020-01-01&quot; --before=&quot;2020-06-01&quot; --no-merges -- WXReader/Book/BookRack/BookReader</code><br>这行命令搭配了多达5个选项(指定作者，指定开始时间，指定结束时间，非合并提交，指定路径)， 它的意思是：打印<code>internetwei</code>作者在2020年1月1号到2020年6月1号之间对<code>WXReader/Book/BookRack/BookReader</code>这个文件夹(包括文件夹下所有文件)进行修改的所有提交记录但不包括合并提交。</p></li><li><p>Git里需要使用哈希值的地方不需要复制整个哈希字符串，通常只需要复制前6~8个字符就够了，如果项目比较大可以扩大到前8~10个，即使是像<code>Linux</code>这样的项目也只需要前10~12个字符即可保证唯一性。</p></li></ol></blockquote><h3 id="Git的特点"><a href="#Git的特点" class="headerlink" title="Git的特点"></a>Git的特点</h3><hr><ol><li><p>Git和SVN(其他版本控制工具)对待文件的区别？</p><blockquote><p>Git保存的不是文件的差异或变化，而是文件快照(快照可以简单的理解为这个文件的副本)，如果一个文件在提交的时候没有任何变化那么Git只会保留一个链接指向之前存储的内容；而SVN保存的是这个文件提交时的差异变化。 </p></blockquote></li><li><p>Git如何保证完整性?</p><blockquote><p>Git所有的数据在存储前都会计算校验和，计算校验和的机制叫做SHA－1散列(hash、哈希)，这是一个由40个16进制字符(0<del>9,a</del>f)组成的字符串，基于文件的内容和目录结构计算出来的(由于相同的文件计算出来的哈希值是一样的，所以当你存储一个文件到Git仓库时，如果Git发现已经有了就只会创建一个链接指向之前存储的那个对象)，计算出来的哈希值就像这样：<code>a6b6695a3594cc79b3c3fa9ef5772df036ec8d8e</code>，校验和的前两个字符用于命名子目录，剩下的38个字符则用作文件名，Git数据库中保存的信息都是以哈希值来索引。</p></blockquote></li><li><p>Git暂存和提交时分别做了什么？</p><blockquote><p>当你进行暂存操作时，Git会对每个文件计算校验和，然后将这些校验和加入到暂存区等待提交。</p><p>当你进行提交操作时，Git会计算每个子目录的校验和以及对所有的文件创建快照并保存快照的索引，然后Git会在仓库中把这些校验和保存为一个树对象，然后Git会创建一个提交对象，它包含一个指向最上层树对象的指针和一个指向父对象的指针(如果是合并提交会有2个父对象，如图1)，还有作者的名称、邮箱地址、提交说明。</p></blockquote><p> <img src="50c7be27cd9a4bca9c4a75c2f7df54ea~tplv-k3u1fbpfcp-zoom-1.image"> 图1</p></li><li><p>Git暂存区的作用</p><blockquote><p>大部分的版本管理(SVN)都没有暂存区的概念，Git的add命令和其他类似工具的add命令也不太一样，其他工具的add命令是将文件加入到版本管理，而Git的add命令有3种作用：1. 将未跟踪的文件加入到版本管理；2. 将已修改的文件内容加入到暂存区；3. 将冲突文件标记为冲突已解决状态。由于Git暂存区的存在，你可以在完成提交前审查你的提交内容，还可以精确的控制每一行的提交内容。例如一个文件有20行是修改BUG，另外有100行是添加新功能，现在我只想提交这个文件的修改BUG的那20行代码，那么只需要把这20行代码加入到暂存区就行了。 </p></blockquote></li><li><p>Merge的逻辑</p><blockquote><p>如果Git发现可以快进合并的话那么Git会直接把当前分支指向合并分支的最新提交(快进合并有一个缺点就是当你删除合并分支后会无法知道这个分支以前是从哪个分支合并过来的，如果想禁用快进合并可以使用<code>--no-ff</code>选项，这样Git会创建一个合并提交)，如果不可以快进合并的话Git会使用这两个分支的末端提交对象以及这两个分支的首个公共祖先提交，做一个简单的三方合并。</p></blockquote></li><li><p>GPG签名</p><blockquote><p>GPG可以签名你的提交或标签，它能够有效的提高Git仓库的安全性，因为它可以证明这个提交或标签是通过你信任的电脑提交的而不是某个冒用你名号的黑客，这相当于赋予了提交对象一种不可更改性，即使黑客通过某种办法拿到了Git仓库的读写权，他也没有办法添加或使用–force修改任何带有你GPG签名的提交或标签。</p><p>由于Git的作者名称和邮箱地址是可以随意填写的，如果有人将他的作者名称和邮箱地址改成和你的一样，然后通过某种方式将代码推送到了你的仓库中……这可能会导致你或其他人遭受损失，使用GPG签名可以尽量避免这种情况的发生。使用GPG签名过的提交在Github上显示如图2，你可以点击标签查看具体的签名信息。<br> <img src="5e21c63b735445c6b17e2d4790a291a1~tplv-k3u1fbpfcp-zoom-1.image"> 图2 </p></blockquote></li><li><p>HEAD是什么？</p><blockquote><p>HEAD本质就是一个指针，也可以叫做符号指针，因为通常情况下它指向一个分支(符号)，通过它可以获取你仓库当前的状态，可以使用<code>git symbolic-ref HEAD</code>查看当前HEAD的状态。</p><p>当HEAD指向一个具体的提交对象而不是分支引用时，Git会提示您处于“游离状态”，“游离状态”表示你当前不处于任何分支，所以你不能进行提交，只能查看提交快照的内容，也可以进行修改运行，如果你想要进行提交则需要先创建一个分支，“游离状态”通常用于调试或回滚某次提交。 </p></blockquote></li><li><p>HEAD^和HEAD~的区别？</p><blockquote><p>当后面不跟数字的时候^和~表示的意思相同，都表示第1个父提交对象；如果后面跟上数字就有差别了，^后面只能跟数字1或者数字2，^1表示当前对象的第1父提交，^2表示当前对象的第2父提交，只有合并提交对象才有第2父提交，第1父提交就是合并时接受合并的分支，第2父提交就是合并时被合并的那个分支；~后面理论上可以跟任意大于0的数字，~1表示当前提交对象的第1个父提交对象，~2表示当前提交对象的第2个父提交对象，以此类推，~2和~~表达同一个意思，不过当你想表示第100个父提交时，显然用~100比写100个~更现实，~和^可以组合使用，例如<code>git show HEAD~2^2</code>这行命令表示查看当前提交的第2个父提交的第2父提交内容。 </p></blockquote></li><li><p>Git中危险的命令</p><blockquote><p>在Git中任何已提交的内容几乎都是可以恢复的(那些被覆盖的提交也可以恢复)，但是未提交的内容丢失后可能再也找不回了，任何可能会导致工作区内容丢失的命令都是危险的命令，在Git中危险的命令总共可以分为3类:</p><ol><li>所有带<code>-f</code>选项的命令，<code>-f</code>的全称是<code>--force</code>，它表示强制的意思，例如<code>git push -f</code>表示强行将本地仓库推送到远程仓库，<code>git switch -f dev</code>表示强行切换到dev分支，总之使用<code>-f</code>选项时请小心。</li><li><code>git reset</code>命令总共有3个选项，<code>--soft</code>、<code>--mixed</code>、<code>--hard</code>，其中只有<code>--hard</code>选项是危险的命令，其他两个都是安全的，当你使用<code>--hard</code>选项时Git会使用仓库中指定的快照内容覆盖工作区。</li><li><code>git checkout</code>命令的本质是操纵HEAD指针，它的后面可以是分支名表示切换分支，也可以是文件路径，如果后面是文件路径，那么它就是一个危险的命令，Git会使用仓库中指定的快照内容覆盖工作区的指定文件(建议使用switch命令来切换分支，防止误操作导致丢失文件内容)。</li></ol></blockquote></li><li><p>checkout和reset的区别</p><blockquote><p>很多人容易把<code>checkout</code>和<code>reset</code>弄混，因为它们都可以用来回滚历史提交，虽然最终效果是一样的，但是实现过程确不一样；简单的说checkout命令会直接修改HEAD指针的指向，而reset命令修改的是HEAD指针指向的对象。</p><p>假设master分支有一个提交对象(ab4adf)，你想回滚到这次提交，Git提供了2种方式：<code>git checkout ab4adf</code>和<code>git reset --hard ab4adf</code>都可以达到你的目的，但它们的实现机制略微不一样；<code>git checkout ab4adf</code>会把HEAD指针直接指向ab4adf这个提交对象，然后再使用ab4adf这个提交对象的快照内容覆盖工作区的内容来达到目的(如果你细心观察的话会发现Git会提示你当前进入了HEAD游离状态)，如图3所示；<code>git reset --hard ab4adf</code>的实现就稍微复杂一些，它会操纵HEAD指针指向的对象(这里是master分支)指向ab4adf这次提交，然后再使用ab4adf这次提交中的快照内容覆盖暂存区和工作区的内容，如图4所示。<br><img src="%E6%88%AA%E5%B1%8F2021-08-03%2015.49.02.png"> 图3<br><img src="%E6%88%AA%E5%B1%8F2021-08-03%2015.49.49.png"> 图4</p></blockquote></li><li><p>Git协议的区别</p><blockquote><p>HTTP协议</p><blockquote><p>HTTP协议有2个版本，一种是哑协议(只能通过GET方式读取仓库内容)，另一种是智能协议，哑协议由于自身问题已经基本退出舞台了；相比SSH协议，HTTP协议可以使用用户名、密码授权是一个优势，就算不知道用户名和密码也可以获取项目，这很适合开源项目的推广，另一个优势就是HTTPS协议被广泛使用，一般的企业防火墙都会允许这些端口的数据通过；唯一的缺点就是在一些服务器上，架设HTTPS协议的服务端稍微棘手一些</p><blockquote><p>在使用HTTPS协议时，可能要重复输入用户名和密码，这时可以执行<code>git config --global credential.helper cache</code>命令来将用户名和密码临时缓存到内存中，可以使用<code>--timeout &lt;seconds&gt;</code>选项控制保留时长，默认是900秒(15分钟)</p></blockquote></blockquote></blockquote><blockquote><p>SSH协议</p><blockquote><p>架设SSH协议相对简单，SSH守护进程很常见，多数管理员都会使用，多数操作系统都包含它及相关的管理工具，相对于HTTPS协议它不用输入用户名和密码也更加方便；它的缺点是不支持匿名访问Git仓库，即使只是读取数据，使用者也必须通过SSH访问你的主机，所以SSH不利于开源项目</p></blockquote></blockquote><blockquote><p>Git协议</p><blockquote><p>是所有协议里传输速度最快的，因为没有加密和授权的开销；它的缺点是由于没有加密和授权，要么谁都可以克隆这个仓库，要么谁也不能，它也是最难架设的协议，还要求防火墙开放9418端口，但是企业防火墙一般都不会开放这个非标准端口。Git协议一般和其他协议(例如HTTPS)搭配使用，使用Git协议进行拉取，使用HTTPS协议进行推送。</p></blockquote></blockquote><blockquote><p>Local协议</p><blockquote><p>一般不会用到，所有没有去了解这方面的知识，有兴趣的可以自行搜索</p></blockquote></blockquote></li></ol><h4 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h4><ul><li><p><code>git help &lt;verb&gt;</code> 获取指定Git命令的帮助文档</p><blockquote><p>示例：</p><p><code>git help add</code> 获取add命令的帮助文档</p><p><code>-a</code> 列出所有的Git命令</p><p><code>-c(--config)</code> 列出所有可用的配置变量</p><p><code>git add -h</code> 简易版的帮助文档</p><blockquote><p>等价命令：</p><p>git &lt;verb&gt; –help</p><p>man git-&lt;verb&gt;  </p></blockquote></blockquote></li><li><p><code>git rm &lt;path&gt;</code> 删除指定文件</p><blockquote><p><code>--cached(--staged)</code> 从暂存区删除指定文件</p><blockquote><p>如果不小心把要忽略的文件添加到了Git仓库中，后续即使在忽略文件中声明也还是会在每次提交时提示你该文件未暂存；这时可以使用该命令从暂存区删除指定文件，该操作不会影响工作区。</p></blockquote><p><code>-n(--try-run)</code> 列出需要删除的文件  </p></blockquote></li><li><p><code>git describe &lt;commit&gt;</code> 根据指定提交对象生成一个字符串构建号。它由提交对象最近的标签名、自该标签之后的提交数目和你所描述的提交的部分哈希值构成(可以为提交附上一个可读的名称)。</p></li><li><p><code>git reflog</code> 显示所有的引用日志</p><blockquote><p>reflog的本质只是记录HEAD指针发生变化的记录，它只存在于本地仓库，一般情况下Git只会保留最近几个月(默认是90天)的记录  </p></blockquote></li><li><p><code>git reflog --date=local --all | grep &lt;分支名&gt;</code> 获取指定分支的HEAD变更记录</p><blockquote><p>可以用来查看某个分支是基于哪个分支创建的，由于reflog所以只能在创建分支的那台电脑上才能生效并且时间太长也会失效。  </p></blockquote></li><li><p><code>git clean</code> 移除那些没有被Git跟踪的文件，该命令需要搭配以下选项执行</p><blockquote><p><code>-d</code> 递归删除子目录下的文件&#x2F;文件夹</p><p><code>-f</code>如果<code>clean.requireForce</code>没有被设置为false，则必须要使用<code>-f</code>告诉Git需要删除那些文件</p><p><code>-n(--dry-run)</code> 只显示那些会被移除的文件</p><p><code>-x</code> 默认情况下不会删除被忽略的文件，-x表示将移除那些被忽略的文件</p><p><code>-X</code> 仅删除被忽略的未跟踪文件  </p></blockquote></li><li><p><code>git gc</code> 手动对Git仓库进行打包优化</p><blockquote><p><code>--aggressive</code> 加上此选项Git将会花费更多时间优化仓库</p></blockquote></li><li><p><code>git fsck</code> 验证数据库中对象的有效性</p><blockquote><p><code>--unreachable</code> 打印那些存在但无法从任何节点访问的对象  </p></blockquote></li><li><p><code>git restore</code> 恢复工作区的文件</p><blockquote><p><code>--staged &lt;path&gt;</code> 将指定文件从暂存区移除</p><p><code>-s(--source) &lt;tree_id&gt; &lt;path&gt;</code> 使用指定树中的文件恢复工作区的指定文件</p></blockquote></li><li><p><code>git clone -d &lt;分支名&gt; &lt;path&gt; --depth=&lt;number&gt;</code> 克隆指定仓库下指定分支的number条提交历史</p><blockquote><p>示例：</p><p><code>git clone -b master &lt;path&gt; --depth=1</code> 只克隆远程仓库的master分支的最近一条提交</p></blockquote></li></ul><h4 id="Git-Config"><a href="#Git-Config" class="headerlink" title="Git Config"></a>Git Config</h4><ul><li><p><code>git config --list</code> 查看Git配置信息，配置信息可能会重复，如果存在重复Git会以最后一个值为准。</p><blockquote><p><code>--show-origin</code> 显示该配置的来源(路径)</p></blockquote></li><li><p><code>git config &lt;范围&gt; &lt;选项&gt; &lt;值&gt;</code> 在指定范围内设置指定配置信息。</p><blockquote><p>示例：</p><p><code>git config --global user.name &#39;author&#39;</code> 在全局范围内设置提交者的名称。<br>Git Config总共有3个范围，分别是system、global、local(默认值)，权重依次递增，system的影响范围是最大的，针对当前电脑下的所有Git仓库都生效；global针对当前用户下的所有Git仓库生效；local只对当前Git仓库生效。  </p></blockquote></li><li><p><code>git config --global merge.conflictstyle diff3</code> 修改合并冲突样式为diff3，这种样式下会额外显示base的内容，如图5。</p><p>  <img src="%E6%88%AA%E5%B1%8F2021-08-10%2010.03.08.png"> 图5</p></li><li><p><code>git config --global help.autocorrect 50</code> 设置该选项后，当Git匹配了相似的命令时会在倒计时结束后自动执行该命令</p></li><li><p><code>git config --global core.autocrlf true</code> 启用该功能的话当你提交时Git会自动把回车和换行转换成一个换行符，而在检出代码时把一个换行符转换成回车和换行。</p><blockquote><p>在Windows的某些编辑器中，换行符是由回车符和换行符2个命令组成的，而在macOS和Linux系统中换行符只有一个符号。如果同一个项目在Windows和其他平台上开发，可能会遇到空格冲突。</p><p><code>input</code> 设置为input告诉Git在提交时把回车和换行转换成换行，检出时不转换</p></blockquote></li><li><p><code>core.whitespace</code> 空格处理方案，Git提供了6种处理多余空白字符的主要选项，3项默认开启，3项默认关闭</p><blockquote><p>默认开启：blank-at-eol(查找行尾的空格)，blank-at-eof(盯住文件底部的空行)，space-before-tab(警惕行头tab前面的空格)</p><p>默认关闭：indent-with-non-tab(揪出以空格而非tab开头的行，你可以用tabwidth选项控制它)，tab-in-indent(监视在行头表示缩进的tab)，cr-at-eol(告诉Git忽略行尾的回车)</p></blockquote></li></ul><p>如果想关闭某个选项，可以在输入设置选项时不指定它或在它前面加个 －</p><ul><li><p><code>git config &lt;范围&gt; alias.&lt;别名&gt; &#39;&lt;全名&gt;&#39;</code> 在指定范围内设置一个Git别名。</p><blockquote><p>示例：</p><p><code>git config --global alias.st &#39;status&#39;</code> 在全局范围内给status设置一个别名st。</p><p>别名通常用来简化命令，如果想给非Git命令起别名，例如gitk，可以这样设置<code>git config --global alias.gitk &#39;!gitk&#39;</code>，当你调用”git gitk”时会执行”gitk”命令。</p><blockquote><p>一些常用的别名：</p><p><code>git config --global alias.co checkout</code></p><p><code>git config --global alias.br branch</code></p><p><code>git config --global alias.ci commit</code></p><p><code>git config --global alias.st status</code></p><p><code>git config --global alias.s &#39;status -s&#39;</code></p><p><code>git config --global alias.last &#39;log -1&#39;</code>  </p></blockquote></blockquote></li><li><p><code>git config &lt;范围&gt; --unset alias.&lt;name&gt;</code> 删除指定别名</p></li></ul><h4 id="Git-Diff"><a href="#Git-Diff" class="headerlink" title="Git Diff"></a>Git Diff</h4><ul><li><p><code>git diff</code> 显示工作区和暂存区之间的差异</p><blockquote><p><code>--cached(--staged)</code> 显示暂存区和最新提交之前的差异</p><p><code>--check</code> 打印所有可能的空格错误</p><p><code>--ours</code> 冲突时查看合并引入了什么</p><p><code>--theirs -b</code> 冲突时查看合并的结果与另一边有什么不同，-b表示去除空格</p><p><code>--base</code> 冲突时查看文件在两边是如何改动的</p></blockquote></li></ul><h4 id="Git-Log"><a href="#Git-Log" class="headerlink" title="Git Log"></a>Git Log</h4><ul><li><p><code>git log</code> 显示当前分支下的提交历史</p><blockquote><p><code>-n</code> 显示指定数量的提交记录，例如<code>git log -2</code>显示最近2条提交记录</p><p><code>--show-signature</code> 显示GPG签名信息</p><p><code>--stat</code> 显示提交时的简略信息</p><p><code>--abbrev-commit</code> 显示简短的哈希值</p><p><code>--relative-date</code> 显示一个相对时间(例如 9 hours ago)</p><p><code>--graph</code> 在日志旁以ASCII图形显示分支和合并历史</p><p><code>--oneline</code> –pretty&#x3D;oneline和–abbrev-commit的缩写</p><p><code>--pretty=</code>  使用其他格式显示提交历史</p><blockquote><p><code>oneline</code> 将每条提交放在一行显示</p><p><code>short</code> 不显示提交时间</p><p><code>full</code> 不显示提交时间但额外显示提交者信息</p><p><code>fuller</code> 显示提交者信息以及提交时间</p><p><code>format</code> 自定义显示风格(自定义风格可以不受Git版本影响)</p><blockquote><p>示例：</p><p><code>git log --pretty=format:&quot;%Cred%h%Creset - %C(yellow)%an%Creset, %C(green)%ar%Creset : %s&quot;</code> 一行显示简写的提交哈希值 - 作者名称, 提交相对时间 : 提交说明。</p><p>format可接受的选项如下：</p><p><code>%H</code> 提交的完整哈希值</p><p><code>%h</code> 提交的简写哈希值</p><p><code>%T</code> 树的完整哈希值</p><p><code>%t</code> 树的简写哈希值</p><p><code>%P</code> 父提交的完整哈希值</p><p><code>%p</code> 父提交的简写哈希值</p><p><code>%an</code> 作者的名称</p><p><code>%ae</code> 作者的电子邮件地址</p><p><code>%ad</code> 作者的修订日期</p><p><code>%ar</code> 作者的修订日期，按多久以前的方式显示，例如20 hours ago</p><p><code>%cn</code> 提交者的名称</p><p><code>%ce</code> 提交者的电子邮件地址</p><p><code>%cd</code> 提交日期</p><p><code>%cr</code> 提交日期，按多久以前的方式显示</p><p><code>%s</code> 提交说明</p><p>Git支持的颜色选项：</p><p>normal、black、red、green、yellow、blue、magenta、cyan、white</p><p>Git支持的字体属性</p><p>bold、dim、ul、blink、reverse</p></blockquote></blockquote><p><code>--author</code> 显示和指定作者的提交记录</p><p><code>--committer</code> 显示和指定提交者的提交记录</p><p><code>--grep</code> 显示提交说明中包含指定字符串的提交记录</p><p><code>-S</code> 显示对指定字符串进行了修改的提交记录(常用来查找某个函数的修改提交记录)</p><p><code>-G &lt;正则表达式&gt;</code> 使用正则查找相关的提交记录</p><p><code>-- &lt;path&gt;</code> 显示指定路径下的修改记录(常用来和其他选项搭配查找某个文件下某个函数的修改提交记录，一般写在最后)</p><p><code>-L</code> 显示指定文件中指定函数的相关修改提交记录</p><blockquote><p>示例：</p><p><code>git log -L :firstApplication:WXReader/AppDelegate.m</code> 显示AppDelegate.m文件下与firstApplication相关的修改提交</p></blockquote><p><code>--no-merges</code> 不显示合并提交</p><p><code>--after(--since)</code> 显示指定时间之后的提交记录</p><p><code>--before(--until)</code> 显示指定时间之前的提交记录</p><blockquote><p><code>--after</code>和<code>--before</code>可以搭配指定的时间值，例如”2008-08-08”，也可以是”2 years 1 day 3 minutes ago”、”2.weeaks”这样的相对日期</p><p>示例：</p><p><code>git log --author=&#39;internetwei&#39; --after=&quot;2020-01-01&quot; --before=&quot;2020-06-01&quot; --no-merges -- WXReader/Book/BookRack/BookReader</code> 显示作者internetwei在2020年1月1号到2020年6月1号之间对<code>WXReader/Book/BookRack/BookReader</code>这个文件夹(包括文件夹下所有的文件)有关的所有修改提交但不包括合并提交</p></blockquote><p><code>&lt;分支1&gt;..&lt;分支2&gt;</code> 显示分支2有但分支1没有的提交记录(常用来检查分支哪些提交未推送)</p><blockquote><p>和..语法等价的命令：</p><p><code>git log ^&lt;分支1&gt; &lt;分支2&gt;</code></p><p><code>git log &lt;分支2&gt; --not &lt;分支1&gt;</code></p><p>上面两种命令是..语法的扩展，除了查询2个引用，还支持查询超过2个引用，例如<code>git log refA refB ^refC</code>表示显示所有被<code>refA</code>或<code>refB</code>包含但不被<code>refC</code>包含的提交记录</p></blockquote><p><code>&lt;分支1&gt;...&lt;分支2&gt;</code> 显示分支1和分支2不共有的提交</p><blockquote><p><code>--left-right</code> 和…等类似语法搭配使用，可以用&lt;、&gt;表示左右分支  </p></blockquote></blockquote></li><li><p><code>git shortlog</code> 显示当前分支的修改日志文档</p><blockquote><p>示例：</p><p><code>git shortlog --no-merges master --not v1.0</code> 显示master分支从v1.0标签后的所有非合并提交提交日志</p></blockquote></li></ul><h4 id="Git-Rebase"><a href="#Git-Rebase" class="headerlink" title="Git Rebase"></a>Git Rebase</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Merge和Rebase的区别：</span><br><span class="line"></span><br><span class="line">在Git中用来整合不同分支的修改有两种办法，一种是merge，另一种是rebase，这两种方案最终的结果没有任何区别，只不过提交历史不一样罢了，Rebase是将一系列的提交按照原有次序依次应用到另一个分支上，这样做可以使提交历史更加整洁；而合并是把最终结果合在一起。</span><br><span class="line"></span><br><span class="line">提取某次提交中引入的补丁和修改，然后在当前分支的基础上应用一次，这种操作就叫做rebase。</span><br><span class="line"></span><br><span class="line">rebase后的提交历史如图6，merge提交历史如图7，同样的提交，使用merge和rebase的区别一目了然。</span><br><span class="line"></span><br><span class="line">你可以自由选择`rebase`或`merge`，不过如果你选择`rebase`的话，请记住只对尚未推送或分享给别人的提交进行`rebase`操作。</span><br></pre></td></tr></table></figure><p><img src="%E6%88%AA%E5%B1%8F2021-08-03%2010.45.35.png"> 图6</p><p><img src="%E6%88%AA%E5%B1%8F2021-08-03%2010.49.53.png"> 图7</p><ul><li><p><code>git rebase &lt;分支&gt;</code> 将当前分支上的提交依次变基到目标分支上</p></li><li><p><code>git rebase &lt;分支1&gt; &lt;分支2&gt;</code> 将分支2上的提交依次变基到分支1上</p><blockquote><p>示例：</p><p><code>git rebase master experiment</code> 将experiment分支上的提交内容依次变基到master分支上，如图8</p><p><img src="0b1bc478bd2f48d5a25d5b886ec99f8d~tplv-k3u1fbpfcp-zoom-1.image"> 图8</p><p>切换到master分支再合并experiment分支就不会有分叉的提交历史了，如图9</p><p><img src="6518e127a0e446b8b790c21f620f7c26~tplv-k3u1fbpfcp-zoom-1.image"> 图9</p><blockquote><p>rebase的原理：</p><ol><li><p>首先找到这2个分支的最近共同祖先C2</p></li><li><p>然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件</p></li><li><p>然后将当前分支指向目标基底C3</p></li><li><p>最后以此将之前保存的临时文件的修改依次应用</p></li></ol></blockquote></blockquote></li><li><p><code>git rebase --onto &lt;分支1&gt; &lt;分支2&gt; &lt;分支3&gt;</code> 找到分支3在分支2分歧后的提交，然后把这些提交在分支1上依次应用一遍</p><blockquote><p>示例：</p><p><code>git rebase --onto master server client</code> 找到client分支，找出它从server分支分歧之后的提交，然后把这些提交在master分支上重放一遍，如图10所示</p></blockquote><p>  <img src="567d0c68f2854ef08fa29313a8ecaee7~tplv-k3u1fbpfcp-zoom-1.image"> 图10</p></li><li><p><code>git rebase -i &lt;区间&gt;</code> 对指定区间内的提交进行交互式变基</p><blockquote><p>示例：</p><p><code>git rebase -i HEAD~2</code> 对最近3次提交进行交互式变基，交互式变基的功能非常强大，可以实现“将任意提交压缩成一个提交”、“将一个提交拆成多个提交”、“修改任意提交的提交说明”、“重新排序”、“移除提交”等功能</p></blockquote></li><li><p><code>git commit --amend</code> 修改最新的提交信息</p><blockquote><p>虽然它是commit开头的命令，不过它的本质就是rebase操作，所以把它放在rebase里</p><p>该命令有2个作用：</p><ol><li><p>修改最新的提交说明；确保当前暂存区是干净的，然后运行此命令，它会将你带到提交说明编辑框，重新编辑提交信息然后保存退出即可。</p></li><li><p>补充提交文件；例如上次提交时忘记添加一个文件，或者上次提交的文件又有修改了，而这次修改应该和上次提交是一起的；首先将需要补充提交的文件添加到暂存区，确保暂存区的文件是你要补充提交的，然后运行此命令，编辑提交信息保存退出即可。</p></li></ol></blockquote></li><li><p><code>git cherry-pick &lt;commit&gt;</code> 将指定提交的修改在当前分支的基础上重放一遍并提交</p></li></ul><h4 id="Git-Remote"><a href="#Git-Remote" class="headerlink" title="Git Remote"></a>Git Remote</h4><ul><li><p><code>git remote</code> 显示所有远程仓库的名称</p><blockquote><p><code>-v</code> 显示远程仓库的具体信息</p><p><code>show &lt;仓库名&gt;</code> 显示指定远程仓库的详细信息</p><p><code>ls-remote &lt;仓库名&gt;</code> 显示指定远程仓库的完整引用列表</p><p><code>prune &lt;仓库名&gt;</code> 删除本地镜像仓库存在但远程已删除的分支信息</p><p><code>git remote set-url &lt;仓库名&gt; &lt;url&gt;</code> 修改指定仓库的地址  </p></blockquote></li><li><p><code>git fetch &lt;仓库名&gt;</code> 拉取指定仓库的信息并更新本地的仓库信息(这只会更新本地的远程镜像仓库，不会修改本地分支和工作区内容)</p></li><li><p><code>git pull</code> 拉取上游分支的新提交并合并，它是<code>fetch</code>和<code>merge</code>2个命令的缩写</p><blockquote><p>pull 命令需要该分支拥有上游分支，如果没有上游分支会提示错误信息，它会运行<code>git fetch</code>将远程仓库的信息拉取下来，然后运行<code>git merge</code>合并远程的提交</p></blockquote></li><li><p><code>git branch -u(--set-upstream-to) &lt;远程分支引用&gt;</code> 设置&#x2F;修改当前分支的上游分支引用</p><blockquote><p><code>git branch -u origin/dev</code> 设置&#x2F;修改当前分支的上游分支为origin仓库的dev分支</p><p>当某个分支拥有上游分支后，可以使用{u(upstream)}代替上游分支</p></blockquote></li><li><p><code>git push</code> 将当前分支的新提交推送到上游分支</p><blockquote><p><code>git push origin refs/head/dev:refs/head/dev</code> 这是推送命令的全称，将本地dev分支推送到远程dev分支上</p><p><code>git push origin v1.0</code> 推送指定标签到远程仓库(默认推送并不会推送标签)</p><p><code>git push origin --tags</code> 推送所有标签到远程仓库</p><p><code>git push origin --delete dev</code> 删除远程仓库的dev分支</p><p><code>git push origin --delete v1.0</code> 删除远程仓库的v1.0分支</p><p><code>git push origin --delete</code>命令实际是<code>git push origin :refs/head/dev</code>，推送一个空对象覆盖远程仓库的dev分支(这么做只是从服务器上移除一个指针，Git通常会将数据保存一段时间直到垃圾回收机制运行。</p></blockquote></li></ul><h4 id="Git-Tag"><a href="#Git-Tag" class="headerlink" title="Git Tag"></a>Git Tag</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tag和Branch的区别：</span><br><span class="line"></span><br><span class="line">相同点：都是一个指向commit对象的指针</span><br><span class="line"></span><br><span class="line">不同点：Tag的位置是固定的，永远指向一个具体的commit对象。而Branch会随着分支的提交或回滚变化位置。</span><br><span class="line"></span><br><span class="line">轻量Tag和附注Tag的区别：</span><br><span class="line"></span><br><span class="line">轻量Tag就像一个不会改变的分支，它只是某个特定提交的引用；而附注Tag则是一个完整的Git对象，它包含打标签者的相关信息、打标签的时间、打标签的说明，还支持GPG签名和验证。</span><br></pre></td></tr></table></figure><ul><li><p><code>git tag &lt;标签名&gt;</code> 给当前提交创建一个轻量Tag</p><blockquote><p><code>-a</code> 创建一个附注Tag</p><p><code>&lt;hash&gt;</code> 尾随一个哈希值，可以给指定提交创建Tag</p><p><code>-s</code> 使用GPG对标签进行签名</p><p><code>-l(--list) &quot;v1.*&quot;</code> 显示所有以”v1.”开头的标签，支持正则匹配</p><p><code>-v</code> 使用GPG验证签名(前提是签名者的公钥需要在你的钥匙链中)</p></blockquote></li></ul><h4 id="Git-Branch"><a href="#Git-Branch" class="headerlink" title="Git Branch"></a>Git Branch</h4><ul><li><p><code>git branch</code> 显示所有本地分支</p><blockquote><p><code>-v</code> 显示分支对应的最新提交</p><p><code>-vv</code> 显示分支与上游分支的落后&#x2F;领先情况</p><p><code>-merged</code> 显示与当前分支已合并的分支</p><p><code>--no-merged</code> 显示与当前分支未合并的分支</p></blockquote></li></ul><h4 id="Git-Merge"><a href="#Git-Merge" class="headerlink" title="Git Merge"></a>Git Merge</h4><ul><li><p><code>git merge &lt;分支名&gt;</code> 合并指定分支</p><blockquote><p><code>--squash</code> 将合并产生的多个提交压缩成一个提交</p><p><code>--verify-signature</code> 拒绝合并那些GPG签名验证不通过的提交</p><p><code>-Xignore-space-change</code> 将一个空白符与多个连续的空白字符视作等价</p><p><code>-Xignore-all-space</code> 合并时完全忽略空白修改</p><p><code>-Xours</code> 遇到冲突时保留当前分支的修改内容</p><p><code>-Xtheirs</code> 遇到冲突时保留目标分支的修改内容  </p></blockquote></li><li><p><code>git merge-base &lt;分支1&gt; &lt;分支2&gt;</code> 获取2个分支最近的公共提交</p></li><li><p><code>git merge --verity-signature -S &lt;分支名&gt;</code> 生成一个签名的合并提交</p></li><li><p><code>git merge -s ours &lt;分支名&gt;</code> 做一次假的合并，记录一个以两边分支作为父结点的新合并提交，但是它甚至根本不关注你正合并入的分支，它只会简单地把当前分支的代码当作合并结果记录下来</p><blockquote><p>假如你有一个分叉的release分支并且在上面做了一些你想要在未来某个时候合并回master的工作，与此同时master分支上的某些bugfix需要向后移植回release分支，你可以合并bugfix分支进入release分支同时也merge -s ours 合并进入你的master分支(即使那个修复已经在那里了)这样当你之后再次合并release分支时，就不会有来自bugfix的冲突。</p></blockquote></li></ul><h4 id="Git-邮箱工作"><a href="#Git-邮箱工作" class="headerlink" title="Git 邮箱工作"></a>Git 邮箱工作</h4><ul><li><p><code>git format-patch -M &lt;分支名&gt;</code> 生成当前分支和指定分支之间不共有的提交补丁文件到根目录下(有几个提交就会生成几个补丁文件)</p><blockquote><p>示例：</p><p><code>git format-patch -M origin/master</code> 生成当前分支和origin&#x2F;master分支之间不共有的提交补丁文件到根目录下(这会生成一份可以邮寄的mbox格式的文件，它将每一个提交转换为一封电子邮件)。<code>-M</code>表示允许Git检查是否有对文件重命名的提交</p></blockquote></li><li><p><code>git apply --check &lt;path&gt;</code> 检查指定路径下的补丁内容是否可以被应用</p></li><li><p><code>git apply &lt;path&gt;</code> 应用指定路径下的补丁内容</p></li><li><p><code>git am &lt;path&gt;</code> 和<code>git apply</code>功能类似，不过比它更智能</p><blockquote><p><code>--resolved</code> 继续应用下一个补丁</p><p><code>-3</code> 表示当应用补丁发生冲突时Git会尝试进行三方合并，该选项默认是关闭的</p><p><code>am</code>的含义：应用(Apply)一系列来自邮箱(Mailbox)的补丁</p><p><code>git apply</code>用于应用<code>git diff</code>或<code>Unix diff</code>命令创建的补丁，它和<code>patch -p1</code>命令几乎是等效的，但是<code>git apply</code>更加严格，相对于<code>patch</code>来说它能够接受的模糊匹配更少，<code>git apply</code>采用了一种”要么全部应用，要么就全部撤销”的模型，即补丁只有全部内容都被应用和全部不被应用两种状态，如果补丁是用<code>git format-patch</code>来创建的，那么建议使用<code>git am</code>来应用补丁，只有对老式的补丁，你才必须使用<code>git apply</code></p></blockquote></li></ul><h4 id="Git-Rerere"><a href="#Git-Rerere" class="headerlink" title="Git Rerere"></a>Git Rerere</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Rerere是“重用已记录的冲突解决方案”的意思，它是一种简化冲突解决的方法，当启动rerere时，Git会维护一些成功合并之前和之后的镜像，当Git发现之前已经修复过类似的冲突时，便会使用之前的修复方案而不需要你的干预</span><br></pre></td></tr></table></figure><ul><li><p><code>git config --global rerere.enabled true</code> 启用Rerere功能</p><blockquote><p>对于已经创建的仓库如果想启动Rerere功能，需要手动在.git文件夹下创建一个rr-cache文件夹</p><p>开启Rerere后会增加本地仓库的体积，rr-cache文件夹只存在于本地仓库，不会推送到远程  </p></blockquote></li><li><p><code>git checkout --conflict=merge &lt;path&gt;</code> 将指定文件恢复到Rerere执行前的状态</p></li></ul><h4 id="Git-归档"><a href="#Git-归档" class="headerlink" title="Git 归档"></a>Git 归档</h4><ul><li><p><code>git archive &lt;commit&gt; --prefix=&#39;&lt;解压后的文件名&gt;/&#39; | gzip &gt; &lt;压缩包的名称&gt;.tar.gz</code> 基于指定提交对象创建一个当前所有快照内容的压缩文件</p><blockquote><p>示例：</p><p><code>git archive master --prefix=&#39;project/&#39; &gt; gzip &gt; master.tar.gz</code> 基于master最新提交的所有快照内容创建一个tar.gz压缩文件</p><p>git archive master –prefix&#x3D;’project&#x2F;‘ –format&#x3D;zip &gt; `git describe master`.zip 基于master最新提交的所有快照内容创建一个zip压缩文件  </p></blockquote></li><li><p><code>git bundle</code> 对分支进行打包</p><blockquote><p>示例：</p><p><code>git bundle create repo.bundle HEAD master</code> 对master分支的所有提交历史进行打包  </p></blockquote></li><li><p><code>git bundle verify &lt;path&gt;</code> 检查指定bundle包是否合法</p></li><li><p><code>git bundle list-heads &lt;path&gt;</code> 列出指定bundle包的引用</p></li></ul><h4 id="Git-Stash"><a href="#Git-Stash" class="headerlink" title="Git Stash"></a>Git Stash</h4><ul><li><p><code>git stash</code> 贮藏所有已跟踪的未提交文件，并还原暂存区和工作区的修改变化</p><blockquote><p><code>-u(--include-untracked)</code> 贮藏所有已跟踪和未跟踪的文件(不包括忽略文件)</p><p><code>-a(--all)</code> 贮藏所有文件(包括忽略文件)</p><p><code>--keep-index</code> 保存到贮藏的同时不清空暂存区的内容</p><p><code>list</code> 查看所有贮藏文件列表</p><p><code>apply</code> 恢复最新的贮藏文件但不删除，可以指定某个贮藏文件</p><p><code>pop</code> 和apply命令一样但是会自动删除贮藏文件(仅在恢复成功时自动删除)</p><p><code>--index</code> 如果在<code>pop</code>和<code>apply</code>时加上此选项会把贮藏前在暂存区的内容重新加到暂存区中，默认全部恢复在工作区  </p></blockquote></li><li><p><code>git stash &lt;贮藏文件&gt; &lt;分支名&gt;</code> 使用指定贮藏文件创建一个分支</p></li></ul><h4 id="Git-Add"><a href="#Git-Add" class="headerlink" title="Git Add"></a>Git Add</h4><ul><li><p><code>git add</code> 将文件加入到暂存区中</p><blockquote><p><code>-i(--interactive)</code> 使用交互式终端模式进行暂存</p><p><code>-p(--patch)</code> 自定义暂存补丁文件(该命令只是-i的一个子命令)</p></blockquote></li></ul><h4 id="Git-Commit"><a href="#Git-Commit" class="headerlink" title="Git Commit"></a>Git Commit</h4><ul><li><p><code>git commit</code> 将暂存区的文件提交到Git仓库</p><blockquote><p><code>-S</code> 使用GPG签名此次提交</p><p><code>-m &quot;注释&quot;</code> 使用指定注释作为提交内容</p><p><code>-a</code> 将已跟踪的所有文件加入到暂存区(未跟踪的文件不会加入到暂存区)</p><p><code>-am</code> -a和-m这2个命令的缩写</p></blockquote></li></ul><h4 id="Git-搜索"><a href="#Git-搜索" class="headerlink" title="Git 搜索"></a>Git 搜索</h4><ul><li><p><code>git grep &lt;字符串&gt;</code> 在工作区中搜索指定字符串出现的所有位置</p><blockquote><p>示例：</p><p><code>git grep --break --heading -n -e &#39;#define&#39; --and \( -e kEncryptionSecret -e kEncryptionKey \) v4.6.0</code> 查看在v4.6.0标签的Git代码库中定义了常量名包含”kEncryptionSecret”或”kEncryptionKey”这两个字符串的位置</p><p><code>-n(--line-number)</code> 显示在文件中的行数</p><p><code>-c(--count)</code> 显示在文件中匹配的数量</p><p><code>-p(--show-function)</code> 显示该字符串上下文内容</p></blockquote></li></ul><h4 id="Git-Subtree"><a href="#Git-Subtree" class="headerlink" title="Git Subtree"></a>Git Subtree</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这里没有提到 git submodule(子模块)，因为使用子模块相比Subtree更麻烦，例如在有子模块的仓库中切换分支需要重新初始化一下子模块，git subtree可以实现git submodule的功能，并且比git submodule更简单。</span><br></pre></td></tr></table></figure><ul><li><p><code>git subtree add --prefix=&lt;path&gt; &lt;link&gt; &lt;分支名&gt;</code> 添加指定仓库下的指定分支内容到指定路径下</p><blockquote><p>示例：</p><p><code>git subtree add --prefix=sub/libpng &lt;link&gt; master</code> 拉取指定仓库下master分支到sub&#x2F;libpng文件夹下  </p></blockquote></li><li><p><code>git subtree pull --prefix=&lt;path&gt; &lt;link&gt; &lt;分支名&gt;</code> 拉取子树的修改提交</p></li><li><p><code>git subtree push --prefix=&lt;path&gt; &lt;link&gt; &lt;分支名&gt;</code> 推送子树的修改提交</p></li></ul><h4 id="Git-Filter"><a href="#Git-Filter" class="headerlink" title="Git Filter"></a>Git Filter</h4><ul><li><p><code>git filter-branch</code> 重写提交历史</p><blockquote><p>示例：</p><p><code>git filter-branch --tree-filter &#39;rm -f password.txt&#39; HEAD</code> 从Git仓库中删除password.txt，–tree-filter表示检出项目的每一个提交后运行指定的命令然后重新提交结果，如果要让上述命令在所有分支上运行，可以加上–all</p><p><code>git filter-branch --subdirectory-filter trunk HEAD</code> 将trunk子目录设置为项目的根目录，Git会自动移除所有不影响子目录的提交</p></blockquote>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git filter-branch --commit-filter &#x27;</span><br><span class="line">if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;internetwei@foxmail.com&quot; ];</span><br><span class="line">then</span><br><span class="line">        GIT_AUTHOR_NAME=&quot;Scott Chacon&quot;;</span><br><span class="line">        GIT_AUTHOR_EMAIL=&quot;schacon@example.com&quot;;</span><br><span class="line">        git commit-tree &quot;$@&quot;;</span><br><span class="line">else</span><br><span class="line">        git commit-tree &quot;$@&quot;;</span><br><span class="line">fi&#x27; HEAD </span><br><span class="line"></span><br><span class="line">遍历所有提交，如果作者邮件地址是internetwei@foxmail.com则修改作者名称和邮件地址(即使某个提交不用修改但是它的哈希值也会更改)</span><br></pre></td></tr></table></figure></li><li><p><code>git filter-repo</code> 重写提交历史</p><blockquote><p>Git官方建议使用git filter-repo而不是git filter-branch，因为git filter-branch在重写提交历史时充满大量的陷阱，性能也很低，它的设计架构在接口的每一层都存在泄漏，这使得它几乎不可能在不向后兼容的情况下更改设计的任何内容。相比较而言git filter-repo的功能更多，而且性能也高出很多(有资料说用git filter-repo几个小时完成的任务用git filter-branch需要等待3个月)。</p><p><code>git filter-repo --path-rename &lt;old_name:new_name&gt;</code> 遍历提交历史，将作者名从old_name修改为new_name</p><p><code>--tag-rename &lt;old_tag:new_tag&gt;</code> 遍历提交历史，重命名以old开头的标签并以new开头，例如<code>--tag-rename foo:bar</code>会将foo-1.2改为bar-1.2</p><p>想学习git filter-repo请查看<a href="https://htmlpreview.github.io/?https://github.com/newren/git-filter-repo/blob/docs/html/git-filter-repo.html">git filter-repo命令手册</a></p></blockquote></li></ul><h4 id="Git-Show"><a href="#Git-Show" class="headerlink" title="Git Show"></a>Git Show</h4><ul><li><p><code>git show &lt;分支名&gt;@&#123;yesterday&#125;</code> 查看指定分支在昨天的最后一次提交对象</p><blockquote><p>yesterday可以是其他任意Git可以识别的时间  </p></blockquote></li><li><p><code>git show &lt;commit&gt;:&lt;path&gt;</code> 查看指定提交下指定文件的内容</p></li></ul><h4 id="Git-Reset"><a href="#Git-Reset" class="headerlink" title="Git Reset"></a>Git Reset</h4><ul><li><p><code>git reset --soft &lt;commit&gt;</code> 将当前分支移动到指定提交上(这样做会导致Git仓库和暂存区与工作区的内容不一致，而暂存区和工作区的内容一致，所以Git会提示你进行commit操作和Git仓库保持一致)，如图11。</p><p>   <img src="646fd8d8cf5941a1a2a3bbd2c140423c~tplv-k3u1fbpfcp-zoom-1.image"> 图11</p></li><li><p><code>git reset --mixed &lt;commit&gt;</code> 默认行为，将当前分支移动到指定提交上并且更新暂存区的内容(这样做会导致Git仓库和暂存区的内容一致，但是和工作区的内容不一致，这时Git会提交你进行add操作将需要提交的文件添加到暂存区)，如图12</p><p>   <img src="aefb6b8501144712b39ccb51ad152e54~tplv-k3u1fbpfcp-zoom-1.image"> 图12</p></li><li><p><code>git reset --hard &lt;commit&gt;</code> 将当前分支移动到指定提交上并且更新暂存区和工作区的内容，这也是reset唯一危险的命令(这样做Git会使用版本库中的内容更新(覆盖)暂存区和工作区的内容)，如图13</p><p>   <img src="63c1aeeafb13499885b805f05815048a~tplv-k3u1fbpfcp-zoom-1.image"> 图13</p></li><li><p><code>git reset &lt;path&gt;</code> 将指定文件从暂存区中删除</p><blockquote><p>它本质上调用的是<code>git reset --mixed HEAD &lt;path&gt;</code>命令，使用版本库中的指定文件覆盖暂存区的文件，所以它可以将文件从暂存区中移除</p></blockquote></li></ul><h4 id="Git-Checkout"><a href="#Git-Checkout" class="headerlink" title="Git Checkout"></a>Git Checkout</h4><ul><li><p><code>git checkout -b &lt;分支名&gt;</code> 创建并切换到指定分支</p><blockquote><p>该命令其实是<code>git branch &lt;分支名&gt;</code>和<code>git checkout &lt;分支名&gt;</code>的缩写</p><p>切换分支建议使用<code>git switch &lt;分支名&gt;</code>，一是因为switch比checkout更容易理解，二是因为switch命令比checkout命令更安全(例如本地有一个文件名和某一个分支同名，当你使用git checkout &lt;文件&#x2F;分支名&gt; 时可能会不小心覆盖工作区的内容)</p></blockquote></li><li><p><code>git checkout -- &lt;path&gt;</code> 撤销工作区指定文件的修改</p><blockquote><p>该命令会使用当前版本库中的指定文件覆盖工作区的指定文件，如果工作区的文件有任何修改将会丢失</p></blockquote></li></ul><h4 id="Git-Revert"><a href="#Git-Revert" class="headerlink" title="Git Revert"></a>Git Revert</h4><ul><li><p><code>git revert &lt;commit&gt;</code> 还原指定提交的内容</p><blockquote><p>该命令用于将某次提交的内容重置并生成一次新提交</p></blockquote></li></ul><h4 id="Git-Blame"><a href="#Git-Blame" class="headerlink" title="Git Blame"></a>Git Blame</h4><ul><li><p><code>git blame -L &lt;range&gt; &lt;path&gt;</code> 查看指定文件中指定范围内的修改提交记录</p><blockquote><p>示例：</p><p><code>git blame -L 68,100 WXYZ_BookReaderViewController.m</code> 查看WXYZ_BookReaderViewController.m文件有关第68到100行的修改提交记录</p><p><code>-C</code> 该选项表示Git会分析你正在标注的文件，并且尝试找出文件中代码片段的原始出处</p></blockquote></li></ul><h4 id="Git-Bisect"><a href="#Git-Bisect" class="headerlink" title="Git Bisect"></a>Git Bisect</h4><ul><li><p><code>git bisect</code> 使用二分搜索查找引入错误的提交</p><blockquote><p>使用流程：</p><p><code>git bisect start</code> 启动二分查找</p><p><code>git bisect bad</code> 告诉Git当前提交是有问题的</p><p><code>git bisect good &lt;commit&gt;</code> 告诉Git没有问题的提交是哪一次</p><p><code>git bisect good</code> 告诉Git当前提交没有问题</p><p><code>git bisect reset</code> 结束二分查找</p><p><code>git biesect start &lt;bad_id&gt; &lt;good_id&gt;</code> 快速执行二分查找，第一个参数是不正常的提交，第二个参数是正常的提交</p><p><code>git bisect run &lt;path&gt;</code> 执行脚本进行二分查找</p></blockquote></li></ul><h4 id="Git-Replace"><a href="#Git-Replace" class="headerlink" title="Git Replace"></a>Git Replace</h4><ul><li><p><code>git replace</code> 替换指定对象</p><blockquote><p><code>git replace &lt;commit1&gt; &lt;commit2&gt;</code> 将commit1替换为commit2</p></blockquote></li></ul><h4 id="Git-底层命令"><a href="#Git-底层命令" class="headerlink" title="Git 底层命令"></a>Git 底层命令</h4><ul><li><p><code>git ls-files</code> 显示有关索引和工作树中文件的信息</p><blockquote><p><code>-u(--unmerged)</code> 显示冲突对象的哈希值</p><p><code>-s(--stage)</code> 显示暂存区当前状态  </p></blockquote></li><li><p><code>git rev-list</code> 按时间倒序列出提交对象</p><blockquote><p><code>--count &lt;分支名&gt;</code> 查看指定分支的提交数量  </p></blockquote></li><li><p><code>git cat-file</code> 查看指定对象的内容或类型和大小信息</p><blockquote><p><code>-p</code> 获取指定对象的内容或类型信息</p><p><code>-t</code> 获取指定对象的类型</p><p><code>-s</code> 获取指定对象的大小  </p></blockquote></li><li><p><code>git ls-tree</code> 列出树对象的内容</p><blockquote><p><code>-r</code> 递归子树对象下的内容  </p></blockquote></li><li><p><code>git update-ref</code> 更新存储在ref中的对象名称</p><blockquote><p>示例：</p><p><code>git update-ref refs/tags/v1.0 c7cfb9</code> 给指定提交对象添加一个轻量标签  </p></blockquote></li><li><p><code>git count-objects -v</code> 查看仓库的详细占用空间</p></li><li><p><code>git for-each-ref</code> 显示所有的引用</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ObjC 风格指南</title>
      <link href="/2021/08/07/iOS/ObjC%20%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/"/>
      <url>/2021/08/07/iOS/ObjC%20%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由 布多(budo) 发布于 2023-10-26 • 最后更新于 2023-10-29</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>制定风格指南主要的目的是统一团队的代码风格与样式，提高工作效率与阅读性还有维护性；<br>这篇文章虽然是OC风格指南，但是有些风格是所有编程语言通用的，另外它还参考了<a href="https://github.com/alibaba/Alibaba-Java-Coding-Guidelines">阿里巴巴Java代码规范</a>，想不到吧。</p><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><h3 id="优化阅读体验，而非写代码的体验"><a href="#优化阅读体验，而非写代码的体验" class="headerlink" title="优化阅读体验，而非写代码的体验"></a>优化阅读体验，而非写代码的体验</h3><p>&nbsp;&nbsp;&nbsp; 代码库通常具有较长的生命周期，并且花在阅读代码上的时间也远多于编写代码的时间。所以我们应该明确一个目标：去优化别人阅读、维护我们代码时的体验，而不是优化写代码时的体验(<code>例如随便使用缩写进行编码，代码量变少了，但是增加了阅读和维护的难度</code>)。</p><p>&nbsp;&nbsp;&nbsp; 适当的规范限制和标准不是消灭代码内容的创造性、优雅性，而是限制过度个性化，以一种普遍认可的方式一起做事，进而提高工作效率，降低沟通成本。提高稳定性。</p><h3 id="与上下文尽量保持一致"><a href="#与上下文尽量保持一致" class="headerlink" title="与上下文尽量保持一致"></a>与上下文尽量保持一致</h3><p>&nbsp;&nbsp;&nbsp; 尽量保持代码库中的风格样式一致。在整个代码库中始终保持一种风格可以让工程师更专注于其他(更重要的)问题。一致性还可以实现更好的自动化。</p><p>&nbsp;&nbsp;&nbsp; 如果风格指南中没有说明，那么就按照代码库之前的风格样式或者参考 <code>Apple SDK</code> 的风格样式。</p><h2 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h2><h3 id="通用命名风格"><a href="#通用命名风格" class="headerlink" title="通用命名风格"></a>通用命名风格</h3><ul><li><p><strong>[必须]</strong> 清晰和简洁(<code>好的名称应该是能自我描述的</code>)，简洁的原则是为了保持更好的清晰度和可读性，记住 <strong>不要本末倒置</strong>。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">// 移除一个对象。</span><br><span class="line">1. removeObject:</span><br><span class="line">// 使用指定字符串替换出现过的字符串。</span><br><span class="line">2. stringByReplacingOccurrencesOfString: withString:</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">// 要移除什么？</span><br><span class="line">1. remove:</span><br><span class="line">// 要将什么替换成什么？是全部都替换还是只替换第一个匹配的位置？</span><br><span class="line">2. replace(&quot;1&quot;, &quot;2&quot;)</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 一致性：命名应该和上下文乃至全局保持一致性，相同类型或者具有相同作用方法的名称应该相同或类似。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">1. NSDictionary、NSArray、NSSet这些类中名叫 count 的方法所体现的作用都是一样的。</span><br><span class="line">2. 系统的一些代理方法和通知的名称也会刻意保持一致，</span><br><span class="line">   例如 `UIApplicationDelegate`协议中的 `applicationDidBecomeActive` 方法名</span><br><span class="line">   就和 `UIApplicationDidBecomeActiveNotification`通知的名称是一致的。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 禁止自我指涉：命名不要自我指涉(通知、掩码或常量等除外)。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">NSString</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">NSStringObject</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 禁止过度缩写和自创缩写，一些通用缩写名除外(例如ATM、GPS、max、min等)，具体请参考 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/APIAbbreviations.html#//apple_ref/doc/uid/20001285-BCIHCGAE">可接受的缩写词列表</a>。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">阅读者可能来自不同的地方接受不同的教育和不同的文化，</span><br><span class="line">他们不一定会明白你写的缩写的意思。</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line">setBackgroundColor</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">setBgColor</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 禁止使用无意义的拼音，国际通用名、地名、人名除外。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">Beijing、Alibaba</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">// 打折</span><br><span class="line">DaZhePromotion</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 代码和注释中避免使用任何语言的种族歧视性词语。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">secondary、main</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">slave、master</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 禁止以new、alloc、copy、mutableCopy等关键字作为名称的开始部分。</p></li><li><p><strong>[必须]</strong> 由于 <strong>OC</strong> 没有命名空间的概念，所以全局名称(<code>类名、协议名、全局常量名、全局变量名、函数名、typedef名称</code>)必须添加前缀，前缀由3个及以上字符组成且全部大写。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips: </span><br><span class="line">由于系统保留任意两个字符作为前缀的使用权(NS、UI、CG、CF、CA、WK、MK、CI、NC等等)，</span><br><span class="line">为了避免和系统命名冲突，所以前缀至少由3个字符组成。</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line">ZTYLoginViewController</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">ZTLoginViewController</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 如果某个全局名称(<code>例如函数名、通知名、协议方法名</code>)和某个类有所关联，那么请使用相关类名作为其前缀，否则请使用通用前缀。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">UIApplicationDidBecomeActiveNotification</span><br><span class="line">MAGUserLoginSuccessNotification</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 命名风格统一使用 <strong>驼峰命名方式</strong> ，局部变量名等特殊名称可以不遵守。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">totalRemain</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">total_remain</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 成员变量名称必须以_作为开始部分。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">_nameString</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">nameString</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 在给常量或变量命名时，请将表示类型的名词放在词尾，以提高辨识度。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">nameLabel、nameString</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">name</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 如果模块、接口、类、方法使用了某种模式，在命名时尽量体现出具体模式。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">OrderFactory、LoginProxy</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 建议给临时变量名称添加前缀，以提高辨识度(<code>特殊情况除外，例如for循环里面的i</code>)。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">// t表示temp</span><br><span class="line">t_label</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">label</span><br></pre></td></tr></table></figure></li></ul><h3 id="类名风格"><a href="#类名风格" class="headerlink" title="类名风格"></a>类名风格</h3><ul><li><p><strong>[必须]</strong> 一个完整的类名由 <strong>前缀+名称+类型</strong> 3个部分组成。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">MAGLoginViewControler</span><br><span class="line"></span><br><span class="line">前缀：MAG</span><br><span class="line">名称：Login</span><br><span class="line">类型：ViewControler</span><br></pre></td></tr></table></figure></li></ul><h3 id="分类命名风格"><a href="#分类命名风格" class="headerlink" title="分类命名风格"></a>分类命名风格</h3><ul><li><p><strong>[必须]</strong> 分类命名风格和类名类似，由 <strong>前缀+名称</strong> 2个部分组成。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">UIView (MAGAdd)</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">UIView (Add)</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 分类中的方法名必须要添加前缀，防止覆盖系统或3方库的私有方法，前缀需要保持唯一性(<code>例如mp_</code>)。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">mp_substringFromString</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">substringFromString</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 分类中建议不要声明属性，尽量挪到主类中声明。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips: </span><br><span class="line">尽管从技术上来讲可以在分类中声明属性，但是这么做需要格外小心，</span><br><span class="line">因为它很容易出现内存上或其他一些问题，而且出现问题很难排查。</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 如果一个类比较复杂，建议使用分类重新组织结构和代码(<code>可以参考系统的UIView</code>)。</p></li></ul><h3 id="枚举命名风格"><a href="#枚举命名风格" class="headerlink" title="枚举命名风格"></a>枚举命名风格</h3><ul><li><p><strong>[必须]</strong> 枚举名称的前缀应该和 <strong>typedef</strong> 的名称保持一致。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">typedef NS_ENUM(NSInteger, MGradientChangeDirection) &#123;</span><br><span class="line">    MGradientChangeDirectionLevel,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">typedef NS_ENUM(NSInteger, MGradientChangeDirection) &#123;</span><br><span class="line">    level,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法命名风格"><a href="#方法命名风格" class="headerlink" title="方法命名风格"></a>方法命名风格</h3><ul><li><p><strong>[必须]</strong> 方法名称的开头一般以小写字母开始，特殊单词除外(<code>例如HTTP、URL</code>)。</p></li><li><p><strong>[必须]</strong> 方法名称禁止直接使用_作为开始部分。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips: </span><br><span class="line">由于系统的私有方法通常以_作为开始部分，这么做可以避免不小心覆盖系统私有方法。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 私有方法必须添加前缀，前缀需要保持唯一性(<code>例如mp_</code>)。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips: </span><br><span class="line">给私有方法添加前缀有如下好处：</span><br><span class="line">1. 提高辨识度，提高代码可读性。</span><br><span class="line">2. 避免不小心覆盖系统或框架的私有方法。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 如果方法返回某个属性值，那么请直接使用属性名作为方法名。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">- (CGSize)cellSize;</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">- (CGSize)getCellSize;</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 方法的每个参数前必须添加有效关键字。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">- (void)sendAction:(SEL)aSelector </span><br><span class="line">          toObject:(id)anObject </span><br><span class="line">       forAllCells:(BOOL)flag;</span><br><span class="line">       </span><br><span class="line">反例：</span><br><span class="line">- (void)sendAction:(SEL)aSelector </span><br><span class="line">                  :(id)anObject </span><br><span class="line">                  :(BOOL)flag;</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 如果某个方法是由通知触发的，那么请使用 <code>Notification</code> 关键字作为名称后缀。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">appDidBecomeActiveNotification</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">appDidBecomeActive</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 尽量不要使用“and”连接接收者属性，尽管and读起来还算顺口，但随着你创建的方法参数的增加，这将会带来一系列的问题。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">- (int)runModalForDirectory:(NSString *)path </span><br><span class="line">                       file:(NSString *)name </span><br><span class="line">                      types:(NSArray *)fileTypes;</span><br><span class="line">                      </span><br><span class="line">反例：</span><br><span class="line">- (int)runModalForDirectory:(NSString *)path </span><br><span class="line">                    andFile:(NSString *)name </span><br><span class="line">                   andTypes:(NSArray *)fileTypes;</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 如果方法描述了两个独立的动作，则可以使用 <code>and</code> 连接。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">- (BOOL)openFile:(NSString *)fullPath </span><br><span class="line"> withApplication:(NSString *)appName </span><br><span class="line">   andDeactivate:(BOOL)flag;</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 尽量不要使用 <code>get</code> 作为方法名称的开始部分，除非这个方法间接返回对象或值。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">- (UIColor *)backgroundColor;</span><br><span class="line">- (void)getLineDash:(float *)pattern count:(int *)count phase:(float *)phase;</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">- (UIColor *)getBackgroundColor;</span><br></pre></td></tr></table></figure></li></ul><h3 id="协议命名风格"><a href="#协议命名风格" class="headerlink" title="协议命名风格"></a>协议命名风格</h3><ul><li><p><strong>[必须]</strong> 协议中的方法名以触发消息的对象名开头，省略类名前缀并首字母小写，如果它没有关联任何类则可以忽略这个规则。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">- (BOOL)tableView:(NSTableView *)tableView </span><br><span class="line">  shouldSelectRow:(int)row;</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 除非协议方法只有一个参数，否则冒号需紧跟在类名后面。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">1. - (BOOL)tableView:(NSTableView *)tableView </span><br><span class="line">     shouldSelectRow:(int)row;</span><br><span class="line">  </span><br><span class="line">2. - (BOOL)applicationOpenUntitledFile:(NSApplication *)sender;</span><br></pre></td></tr></table></figure></li></ul><h3 id="通知命名风格"><a href="#通知命名风格" class="headerlink" title="通知命名风格"></a>通知命名风格</h3><ul><li><p><strong>[必须]</strong> 一个完整的通知名称由 <strong>关联的类名&#x2F;通用前缀+名称+Notification</strong> 3个部分组成。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">UIApplicationDidBecomeActiveNotification</span><br><span class="line"></span><br><span class="line">关联的类：UIApplication</span><br><span class="line">通知名称：DidBecomeActive</span><br><span class="line">固定后缀：Notification</span><br></pre></td></tr></table></figure></li></ul><h3 id="常量命名风格"><a href="#常量命名风格" class="headerlink" title="常量命名风格"></a>常量命名风格</h3><ul><li><p><strong>[必须]</strong> 如果常量局限于某个 <strong>编译单元</strong>(<code>通常指某个类的实现文件内</code>) 之内，通常在前面加小写字母k作为前缀，若常量在全局可见，通常以类名作为前缀，然后采用首字母大写驼峰命名方式。</p>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">// 局部可见</span><br><span class="line">const CGFloat kAnimationDuration = 2.0;</span><br><span class="line">// 全局可见</span><br><span class="line">const CGFloat UIActivityIndicatorViewAnimationDuration = 2.0;</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> const如果修饰的是基本数据类型，则放在最左侧，如果修饰的是对象，则放在变量名前面。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">const NSInteger age</span><br><span class="line">NSString * const name</span><br></pre></td></tr></table></figure></li></ul><h3 id="异常类命名风格"><a href="#异常类命名风格" class="headerlink" title="异常类命名风格"></a>异常类命名风格</h3><ul><li><strong>[必须]</strong> 一个完整的异常类名称由 <strong>前缀+名称+Exception</strong> 3个部分组成。</li></ul><h3 id="文件命名风格"><a href="#文件命名风格" class="headerlink" title="文件命名风格"></a>文件命名风格</h3><ul><li><p><strong>[必须]</strong> 文件名全部小写，使用_连接不同的模块，模块中的单词可以使用驼峰命名。</p></li><li><p><strong>[必须]</strong> 文件名称由 <strong>所属模块+描述</strong> 2个部分组成。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">public_back@2x.png</span><br></pre></td></tr></table></figure></li></ul><h3 id="注释风格"><a href="#注释风格" class="headerlink" title="注释风格"></a>注释风格</h3><ul><li><p><strong>[必须]</strong> 注释请遵守 <a href="https://www.doxygen.nl/index.html">Doxygen</a> 风格。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个好的例子：</span><br><span class="line">/**</span><br><span class="line"> * @brief 关于这个方法的一个简短说明。</span><br><span class="line"> * @discussion 一段详细的描述。</span><br><span class="line"> * @warning 一些警告信息。</span><br><span class="line"> * @note 描述一些需要注意的事情。</span><br><span class="line"> * @param obj1 参数1的说明。</span><br><span class="line"> * @return 返回值的说明。</span><br><span class="line"> * @code</span><br><span class="line"> * 示例代码：</span><br><span class="line"> * id temp = [self testFunction:@&quot;111&quot;];</span><br><span class="line"> * @endcode</span><br><span class="line"> *</span><br><span class="line"> * @par 分割线，上面是一些常用的注释语法，下面是不常用的注释语法。</span><br><span class="line"> *</span><br><span class="line"> * @todo 即将要做的事情。</span><br><span class="line"> * @bug 可能存在的BUG，或者对缺陷的说明。</span><br><span class="line"> * @since 说明从什么版本、什么时间加入此代码。</span><br><span class="line"> * @exception 对可能存在的异常的解释。</span><br><span class="line"> * @pre 用来说明执行方法所需要的前提条件。</span><br><span class="line"> * @post 用来说明执行方法之后的使用条件。</span><br><span class="line"> * @author 作者名称。</span><br><span class="line"> * @remark 一些评论信息。</span><br><span class="line"> * @copyright 版权信息。</span><br><span class="line"> * @version 当前的工程版本。</span><br><span class="line"> * @par 一个新的名称</span><br><span class="line"> *</span><br><span class="line"> * 开始一个新段落。</span><br><span class="line"> */</span><br><span class="line">- (id)testFunction:(NSString *)obj1 &#123;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  效果图<br>  <img src="f01e7d9511334d728efdf822fe013f79~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p></li><li><p><strong>[必须]</strong> 注释的作用是用于解释那些复杂不容易理解的逻辑，以及需要注意的地方，而不是告诉别人这个方法的作用，作用应该在名称中体现出来，提供一个合理的名称比使用晦涩的名称然后试图通过注释来解释它们要好的多。</p></li><li><p><strong>[必须]</strong> 如果修改了实现细节，请记得修改注释。</p></li><li><p><strong>[必须]</strong> 注释不要写的太冗长或太简短，这样都不利于别人快速理解。</p></li><li><p><strong>[必须]</strong> 注释的双斜线和内容之间有且仅有一个空格。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">// 这是示例注释，请注意在双斜线后有一个空格。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 注释中的语句也需要添加适量的标点符号和空格帮助别人理解。</p></li><li><p><strong>[必须]</strong> 对于代码注释需要谨慎，代码被注释一般有2种可能，1. 后续会恢复此段代码逻辑； 2. 永久不用；对于第1种情况需添加相应注释，如果没有注释信息难以知晓注释动机，后者建议直接删除。如果有需要可以通过代码仓库查阅历史代码。</p></li><li><p><strong>[必须]</strong> 如果某个方法是有问题的，可以使用特殊注释来提醒别人和自己。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">// MARK: - 方法集</span><br><span class="line">// TODO: 等待实现</span><br><span class="line">// FIXME: 有bug，需要修改</span><br><span class="line">// !!!: 逻辑混乱，需要完善</span><br><span class="line">// ???: 具体干什么用的？</span><br><span class="line">- (void)testFunction;</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 行尾注解和代码保持2个空格，如果后续行有多个注释，将它们排列起来通常会更具可读性。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例:</span><br><span class="line">[self doSomethingWithALongName];  // Two spaces before the comment.</span><br><span class="line">[self doSomethingShort];          // More spacing to align the comment.</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 别给糟糕的代码加注释，重构它。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips: </span><br><span class="line">注释不能美化糟糕的代码。当企图使用注释前，先考虑是否可以通过调整结构，命名等操作，消除写注释的必要。</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 如果一个类比较复杂或者有需要注意的地方，那么请在声明它的地方加上注释帮助别人快速理解，如果有必要可以使用 <a href="https://wwi.lanzout.com/iyHlYz0lxqf"><strong>Monodraw</strong></a> 工具绘制ASCII图形提高可读性，如下图所示。</p><p>  monodraw示例图(这张图很清楚的向别人表达这个类的作用)<br>  <img src="63b45029f3684dfba4de6f7b4a6e8a8a~tplv-k3u1fbpfcp-zoom-1.image" alt="monodraw示例图"></p></li></ul><h2 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h2><ul><li><p><strong>[必须]</strong> 不要增加多余空格来使上下代码的等号对齐。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">int a1 = 1;</span><br><span class="line">long a2 = 3;</span><br><span class="line">NSString *a3 = @&quot;&quot;;</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">int a1       = 1;</span><br><span class="line">long a2      = 3;</span><br><span class="line">NSString *a3 = @&quot;&quot;;</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 逗号(,)后面、二元运算符的左右应该添加1个空格，小括号左右不要有空格。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">kColorRGB(255, 255, 255);</span><br><span class="line">int a = 3 + 4;</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">kColorRGB(255,255,255)</span><br><span class="line">int a = 3+4;</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 尽量使用 if return 代替 if else，if 嵌套最好不超过5层。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">if (x == 1) &#123;</span><br><span class="line">……</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (x == 2) &#123;</span><br><span class="line">……</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">if (x == 1) &#123;</span><br><span class="line">……</span><br><span class="line">&#125; else if (x == 2) &#123;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 尽量避免采用取反逻辑运算符，因为取反逻辑不利于快速理解。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">if (array == nil) &#123;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br><span class="line">反例：</span><br><span class="line">if (!array) &#123;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="结构风格"><a href="#结构风格" class="headerlink" title="结构风格"></a>结构风格</h2><ul><li><p><strong>[必须]</strong> 文件内部使用的常量、静态变量在@interface之前声明，如果没有@interface就在@implementation前声明。</p></li><li><p><strong>[必须]</strong> 同一类型的属性声明放在一块显示，中间用一行空格区分，不同类型的声明用2行空格隔开，属性声明的开始和末尾都要添加一行空格。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">@interface MineViewController ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak) UIView *headView;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak) UITableView *tableView;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSArray *dataSourceArray;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 不同作用的方法按照顺序进行排序，生命周期相关的方法 &gt; 公开方法 &gt; 私有方法 &gt; 继承方法 &gt; 通知方法 &gt; 协议方法 &gt; getter&#x2F;setter方法，简单的说就是越重要越常用的方法越靠前。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma mark - LifeCycle(生命周期相关的代码放在最上面)</span><br><span class="line">- (void)dealloc &#123;&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewWillAppear:(BOOL)animated &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - Public(公开方法)</span><br><span class="line">// code...</span><br><span class="line">// 下空两行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - Private(私有方法)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - Override(需要覆盖父类的方法)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - Notification(通知方法)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - Delegate(Delegate需要实现的方法)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - Getter/Setter</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 方法的声明顺序应该为类方法 &gt; 初始化方法 &gt; 实例方法。</p></li><li><p><strong>[建议]</strong> 不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开以提升可读性。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例:</span><br><span class="line">[self createSubviews];</span><br><span class="line">[self createTableview];</span><br><span class="line"></span><br><span class="line">[self netRequest];</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 头文件包含顺序应该是系统头文件 &gt; SDK头文件 &gt; 其他依赖的头文件，用一个空行分隔逻辑上不同的头文件，在每个组中，包含的内容建议按首字母顺序排列。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例:</span><br><span class="line">#import &quot;ProjectX/BazViewController.h&quot;</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;base/basictypes.h&quot;</span><br><span class="line">#include &quot;base/integral_types.h&quot;</span><br><span class="line">#include &quot;util/math/mathutil.h&quot;</span><br><span class="line"></span><br><span class="line">#import &quot;ProjectX/BazModel.h&quot;</span><br><span class="line">#import &quot;Shared/Util/Foo.h&quot;</span><br></pre></td></tr></table></figure></li></ul><p>一个好的头文件例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">#import &quot;WXYZ_ADDefine.h&quot;</span><br><span class="line">    </span><br><span class="line">@class WXYZ_ADModel;</span><br><span class="line">    </span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line">    </span><br><span class="line">/// 提供给外部使用的广告实例对象，所有需要使用广告的地方都应该使用 WXYZ_ADView 创建。</span><br><span class="line">@interface WXYZ_ADView : UIView</span><br><span class="line">    </span><br><span class="line">/// 广告相关属性，key表示广告标题，value表示广告宽度。</span><br><span class="line">@property(nonatomic, copy) NSDictionary&lt;NSString *, NSNumber *&gt; *attributes;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">/// 根据广告类型和广告位置返回是否一个布尔值，表示是否需要展示广告。</span><br><span class="line">+ (BOOL)canLoadADWithADType:(WXYZ_ADViewType)adType adPosition:(WXYZ_ADViewPosition)adPosition;</span><br><span class="line">    </span><br><span class="line">/// 根据广告类型和广告位置创建并返回一个adView对象。</span><br><span class="line">/// @discussion 如果广告开关是关闭状态则返回nil。</span><br><span class="line">/// @param adType 广告类型</span><br><span class="line">/// @param adPosition 广告位置</span><br><span class="line">+ (nullable instancetype)createADViewWithType:(WXYZ_ADViewType)adType adPosition:(WXYZ_ADViewPosition)adPosition;</span><br><span class="line">    </span><br><span class="line">/// 设置adModel将会更新正在显示的广告内容。</span><br><span class="line">- (void)setAdModel:(WXYZ_ADModel *)adModel;</span><br><span class="line">    </span><br><span class="line">+ (instancetype)allocWithZone:(struct _NSZone *)zone UNAVAILABLE_ATTRIBUTE;</span><br><span class="line">    </span><br><span class="line">+ (instancetype)new UNAVAILABLE_ATTRIBUTE;</span><br><span class="line">    </span><br><span class="line">+ (instancetype)alloc UNAVAILABLE_ATTRIBUTE;</span><br><span class="line">    </span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame UNAVAILABLE_ATTRIBUTE;</span><br><span class="line">    </span><br><span class="line">- (instancetype)init UNAVAILABLE_ATTRIBUTE;</span><br><span class="line">    </span><br><span class="line">@end</span><br><span class="line">    </span><br><span class="line">NS_ASSUME_NONNULL_END</span><br></pre></td></tr></table></figure><ol><li>使用 <strong>@class</strong> 向前声明 <code>WXYZ_ADModel</code>而不是用 <code>#import</code>包含。</li><li>@interface 之前有关于类的说明注释，帮助别人在使用这个类时快速了解这个类的作用以及需要注意的地方。</li><li>字典使用了泛型声明字典包含的类型，并且在注释中详细的说明了字典包含的内容。</li><li>属性和第一个方法之间有2个空格来区分它们没有关联性。</li><li>每个属性和返回值都有是否为空的状态，例如 <code>+ createADViewWithType</code> 方法使用 <code>nullable</code> 表明了返回值可能为空的状态，并且在注释中说明了什么情况下会返回空对象。</li><li>遵守了类方法 &gt; 初始化方法 &gt; 实例方法的规则。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html">Cocoa编码规范</a></li><li><a href="https://github.com/alibaba/Alibaba-Java-Coding-Guidelines">阿里巴巴Java代码规范</a></li><li><a href="https://book.douban.com/subject/25829244/">Effective Objective-C 2.0  编写高质量iOS与OS X代码的52个有效方法</a></li><li><a href="https://google.github.io/styleguide/objcguide.html">Google的Objective-C风格指南</a></li><li><a href="https://www.bilibili.com/video/BV1gi421i7nz/?spm_id_from=333.999.0.0&vd_source=6327e0feef1a22aae76d47cc73e13ccd">给代码起名字的三要三不要准则</a></li></ol><!-- >命名规范把命名做到准确且详细，不仅仅是表面功夫，它能够极大的影响工作效率。好的名称能减少代码的歧义，提升团队的阅读效率。能降低维护的难度。三要：如果一个名字，需要在旁边写上注释，就说明这个名称不够好。把信息体现在名称里，例如 `reportCutOffDate` 比 `date` 好。例如 `if (orderCreatedDate < reportCutOffDate)` 比 `if (date2 < date1)` 好。- 要区分度    例如 `genenorReport` 就不够好，report 有可能有多种类型，例如 AReport, BReport. 应该在名称中体现这是什么  .- 要识别度- 要够详细三不要：很多人为的，为了规范而规范的行为，往往都没有好下场。因为他们都会低估了事物的复杂度和未来的不确定性。一个命名，只要客观上没有错误。不影响理解、不产生歧义、不增加维护成本。就应该被接受。我们更应该关心的是正确性和准确性，而不是统一规范。原子能的命名规则：正确性(correctness)、准确性(precision)、一致性(consistency)- 不要规范- 不要主观- 不要造字--> ]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 开发规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ObjC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法备忘录</title>
      <link href="/2021/03/08/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Markdown%E8%AF%AD%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95/"/>
      <url>/2021/03/08/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Markdown%E8%AF%AD%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由 布多(budo) 发布于 2021-03-08</p></blockquote><p>这不是一篇教你如何入门 Markdown 语法的文章，它存在的目的是记录我们平常不经常使用的语法，例如如何调整图片的宽度信息；由于这些语法我们不经常使用，所以到用时总是会忘记，此时就需要一篇文章来记录这些不常用的语法，需要用到但又忘记的时候打开来看一下即可。</p><p>基于这个原则，文章不会有如何声明标题这样的语法。</p><blockquote><p>注意：文章中用到了很多 HTML 语法，某些平台可能不支持这些语法。</p></blockquote><hr><h3 id="多行段落"><a href="#多行段落" class="headerlink" title="多行段落"></a>多行段落</h3><p>默认情况下多行空白内容只会显示一行；可以使用 <code>&lt;br&gt;&lt;/br&gt;</code> 实现多行效果。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一行</span><br><span class="line"></span><br><span class="line">&lt;br&gt;&lt;/br&gt;</span><br><span class="line">&lt;br&gt;&lt;/br&gt;</span><br><span class="line">第二行</span><br></pre></td></tr></table></figure><p>第一行</p><p><br></br><br><br></br><br>第二行</p><h3 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h3><p>由于是注释内容，所以你看不到实际内容，这是正常现象(<code>如果你看到了实际内容，说明该平台不支持该语法</code>)。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[//]: 这是一行注释</span><br></pre></td></tr></table></figure><h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">我是第一行注释，</span><br><span class="line">我是第二行注释。</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure><!--我是第一行注释，我是第二行注释。--><h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><p><span id="anchor1">默认情况下</span>多个空格只会显示为一个空格，可以使用 <code>&amp;nbsp;</code> 实现多个空格的效果。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文字1 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;文字2</span><br></pre></td></tr></table></figure><p>文字1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文字2</p><h3 id="链接的悬停文案"><a href="#链接的悬停文案" class="headerlink" title="链接的悬停文案"></a>链接的悬停文案</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[百度](https://www.baidu.com &quot;当鼠标悬停在文字上方时，你会看到它&quot;)</span><br></pre></td></tr></table></figure><p><a href="https://www.baidu.com/" title="当鼠标悬停在文字上方时，你会看到它">百度</a>(<code>ps: 把鼠标悬停在「百度」上，你能看到悬停文案</code>)</p><h3 id="图片的悬停文案"><a href="#图片的悬停文案" class="headerlink" title="图片的悬停文案"></a>图片的悬停文案</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![阿西河图片](https://p.upyun.com/docs/cloud/demo.jpg &quot;当鼠标悬停在文字上方时，你会看到它&quot;)</span><br></pre></td></tr></table></figure><p><img src="demo.jpg" alt="阿西河图片" title="当鼠标悬停在文字上方时，你会看到它"></p><h3 id="图片自定义对齐方式和尺寸等参数"><a href="#图片自定义对齐方式和尺寸等参数" class="headerlink" title="图片自定义对齐方式和尺寸等参数"></a>图片自定义对齐方式和尺寸等参数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div style=&quot;text-align: center;background-color: #b6ffc8;&quot;&gt;</span><br><span class="line">    &lt;img </span><br><span class="line">        src=&quot;https://p.upyun.com/docs/cloud/demo.jpg&quot; </span><br><span class="line">        alt=&quot;阿西河图片&quot; </span><br><span class="line">        title=&quot;阿西河图片Title&quot; </span><br><span class="line">        style=&quot;width:300px;height:300px;&quot;</span><br><span class="line">    &gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><div style="text-align: center;background-color: #b6ffc8;">    <img         src="demo.jpg"         alt="阿西河图片"         title="阿西河图片Title"         style="width:300px;height:300px;"    ></div><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```c</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    printf(&quot;Hello World!&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大部分语言的关键字都是其名称的小写形式，例如 JavaScript 对应的关键字是 javascript，故而我只记录了一些特殊的关键字：</p><table><thead><tr><th align="center">语言名</th><th align="center">关键字</th></tr></thead><tbody><tr><td align="center">C++</td><td align="center">cpp</td></tr><tr><td align="center">c#</td><td align="center">cs</td></tr><tr><td align="center">Objective-C</td><td align="center">objc</td></tr></tbody></table><h3 id="跳转到指定标题"><a href="#跳转到指定标题" class="headerlink" title="跳转到指定标题"></a>跳转到指定标题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[点击跳转到「多行段落」标题](#多行段落)</span><br></pre></td></tr></table></figure><p><a href="#%E5%A4%9A%E8%A1%8C%E6%AE%B5%E8%90%BD">点击跳转到「多行段落」标题</a></p><h3 id="跳转到指定文案"><a href="#跳转到指定文案" class="headerlink" title="跳转到指定文案"></a>跳转到指定文案</h3><p>要跳转处的文案必须这样写：<code>&lt;span id=&quot;anchor1&quot;&gt;默认情况下&lt;/span&gt;</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[点击跳转到指定位置「默认情况下」](#anchor1)</span><br></pre></td></tr></table></figure><p><a href="#anchor1">点击跳转到指定位置「默认情况下」</a></p><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">脚注1[^1]</span><br></pre></td></tr></table></figure><p>脚注1 <a href="%E8%84%9A%E6%B3%A81">^1</a></p><h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- [x] 已完成的任务</span><br><span class="line">- [ ] 未完成的任务</span><br></pre></td></tr></table></figure><ul><li><input checked="" disabled="" type="checkbox"> 已完成的任务</li><li><input disabled="" type="checkbox"> 未完成的任务</li></ul><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是 ~~删除线~~</span><br></pre></td></tr></table></figure><p>这是 <del>删除线</del></p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;font face=&quot;黑体&quot; size=5&gt;我是黑体字&lt;/font&gt;</span><br><span class="line">&lt;font face=&quot;微软雅黑&quot; size=5&gt;我是微软雅黑&lt;/font&gt;</span><br></pre></td></tr></table></figure><p><font face="黑体" size=5>我是黑体字</font><br><font face="微软雅黑" size=5>我是微软雅黑</font></p><h3 id="文字颜色"><a href="#文字颜色" class="headerlink" title="文字颜色"></a>文字颜色</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;font color=#0099ff&gt;我的文字颜色是蓝色&lt;/font&gt;</span><br></pre></td></tr></table></figure><p><font color=#0099ff>我的文字颜色是蓝色</font></p><h3 id="上标"><a href="#上标" class="headerlink" title="上标"></a>上标</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n&lt;sup&gt;2&lt;/sup&gt; = n * n</span><br></pre></td></tr></table></figure><p>n<sup>2</sup> &#x3D; n * n</p><h3 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">H&lt;sub&gt;2&lt;/sub&gt;O</span><br></pre></td></tr></table></figure><p>H<sub>2</sub>O</p><h3 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p style=&quot;background-color: #b6ffc8;&quot;&gt;&lt;font color=#000&gt;背景是绿色&lt;/font&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p style="background-color: #b6ffc8;"><font color=#000>背景是绿色</font></p><h3 id="文字对齐方式"><a href="#文字对齐方式" class="headerlink" title="文字对齐方式"></a>文字对齐方式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p style=&quot;text-align: left;background-color: #b6ffc8;&quot;&gt;&lt;font color=#000&gt;文字左对齐&lt;/font&gt;&lt;/p&gt;</span><br><span class="line">&lt;p style=&quot;text-align: center;background-color: #b6ffc8;&quot;&gt;&lt;font color=#000&gt;文字居中对齐&lt;/font&gt;&lt;/p&gt;</span><br><span class="line">&lt;p style=&quot;text-align: right;background-color: #b6ffc8;&quot;&gt;&lt;font color=#000&gt;文字右对齐&lt;/font&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p style="text-align: left;background-color: #b6ffc8;"><font color=#000>文字左对齐</font></p><p style="text-align: center;background-color: #b6ffc8;"><font color=#000>文字居中对齐</font></p><p style="text-align: right;background-color: #b6ffc8;"><font color=#000>文字右对齐</font></p><h3 id="插入音频"><a href="#插入音频" class="headerlink" title="插入音频"></a>插入音频</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;iframe </span><br><span class="line">    frameborder=&quot;no&quot; </span><br><span class="line">    border=&quot;0&quot; </span><br><span class="line">    marginwidth=&quot;0&quot; </span><br><span class="line">    marginheight=&quot;0&quot; </span><br><span class="line">    width=100% </span><br><span class="line">    height=auto </span><br><span class="line">    src=&quot;https://music.163.com/outchain/player?type=2&amp;id=528478901&amp;auto=1&amp;height=66&quot;&gt;</span><br><span class="line">&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><iframe     frameborder="no"     border="0"     marginwidth="0"     marginheight="0"     width=100%     height=auto     src="https://music.163.com/outchain/player?type=2&id=528478901&auto=1&height=66"></iframe><h3 id="插入视频"><a href="#插入视频" class="headerlink" title="插入视频"></a>插入视频</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;iframe </span><br><span class="line">    src=&quot;https://player.bilibili.com/player.html?aid=10631344&amp;cid=17548810&amp;page=1&quot; </span><br><span class="line">    scrolling=&quot;no&quot; </span><br><span class="line">    style=&quot;border:0;width:100%;height:auto;min-height:790px;&quot;</span><br><span class="line">    allowfullscreen=&quot;true&quot;&gt; </span><br><span class="line">&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><iframe     src="https://player.bilibili.com/player.html?aid=10631344&cid=17548810&page=1"     scrolling="no"     style="border:0;width:100%;height:auto;min-height:790px;"    allowfullscreen="true"> </iframe><h3 id="使用Mermaid画图"><a href="#使用Mermaid画图" class="headerlink" title="使用Mermaid画图"></a>使用Mermaid画图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```mermaid</span><br><span class="line">sequenceDiagram</span><br><span class="line">    participant Alice</span><br><span class="line">    participant Bob</span><br><span class="line">    Alice-&gt;John: Hello John, how are you?</span><br><span class="line">    loop Healthcheck</span><br><span class="line">        John-&gt;John: Fight against hypochondria</span><br><span class="line">    end</span><br><span class="line">    Note right of John: Rational thoughts &lt;br/&gt;prevail...</span><br><span class="line">    John--&gt;Alice: Great!</span><br><span class="line">    John-&gt;Bob: How about you?</span><br><span class="line">    Bob--&gt;John: Jolly good!</span><br><span class="line">```</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant Alice</span><br><span class="line">    participant Bob</span><br><span class="line">    Alice-&gt;John: Hello John, how are you?</span><br><span class="line">    loop Healthcheck</span><br><span class="line">        John-&gt;John: Fight against hypochondria</span><br><span class="line">    end</span><br><span class="line">    Note right of John: Rational thoughts &lt;br/&gt;prevail...</span><br><span class="line">    John--&gt;Alice: Great!</span><br><span class="line">    John-&gt;Bob: How about you?</span><br><span class="line">    Bob--&gt;John: Jolly good!</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LLDynamicLaunchScreen的设计思路</title>
      <link href="/2021/03/07/iOS/LLDynamicLaunchScreen%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/"/>
      <url>/2021/03/07/iOS/LLDynamicLaunchScreen%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由 布多(budo) 发布于 2021-03-07</p></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;动态修改iPhone上APP的启动图，将它修改为用户喜欢的图片，这样用户每次打开APP第一眼就可以看到自己喜欢的图片，这对于用户来说是不是挺爽呢。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;其实这个想法我很早之前就萌发了(大概是2019年上半年)，有一次我发现苹果提供了方法可以动态修改APP的Logo，就萌发了动态修改启动图的想法，当时查阅了一些资料，然后自己通过实践发现确实可以不更新APP动态修改启动图。不过因为当时公司的APP并不需要这个功能，而且大部分的软件厂商也并没有注意到这一块的用户体验，所有的APP也都不支持用户自定义启动图，所以当时也就没继续往下深究了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;时间眨眼就来到了2020年下半年，当时因为公司的APP要实现暗黑模式，但是这个APP已经更新迭代了3年多，在所有页面添加修改色值的代码工作量太大，而且我们的APP支持iOS10但是系统的暗黑API最低支持iOS13，然后自己就写了一个暗黑框架<a href="https://github.com/internetWei/llDark">LLDark</a>，当APP集成好这个暗黑框架后，发现APP强行切换成一个模式后，APP的启动图却没有跟随APP的模式变化，而是跟随系统模式，简单的说就是APP强行设置成了浅色模式，但是系统是深色模式，当用户打开APP时启动图会显示深色(系统)的启动图而不是浅色(APP)的启动图。对于大部分的人来说可能觉得这个问题可以跳过，因为大部分的APP也都这样，但是我是一个完美主义者，为了能让用户有一个完美的体验，然后我就写了<a href="https://github.com/internetWei/LLDynamicLaunchScreen">LLDynamicLaunchScreen</a>，它最初的目的只是为了配合<a href="https://github.com/internetWei/llDark">LLDark</a>实现完美的暗黑模式，后面考虑到可能有APP注意到了这一块的用户体验想要实现动态修改启动图，所以就把它抽离出来并开源了<a href="https://github.com/internetWei/LLDynamicLaunchScreen">LLDynamicLaunchScreen</a>。</p><h3 id="关于启动图的坑"><a href="#关于启动图的坑" class="headerlink" title="关于启动图的坑"></a>关于启动图的坑</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;启动图莫名其妙变成黑色的这个BUG已经有很多APP遇到了，我公司的APP也遇到了，我手机上的微信也遇到了，基本可以确定是苹果的BUG。如图1.1(这是我在手机上录制的，录制时间为2021年3月7号)，大家可以发现我在打开微信APP时屏幕是一片黑色的，我拿同事的手机测试了发现他的手机打开微信APP启动图依旧是原来的一个地球和一个人，所以确定不是微信把启动图换成了黑色(同事手机上的微信版本和我手机上的微信版本是一致的，而且我们的系统版本号也一致)。</p><table><thead><tr><th align="center"><img src="202103061844.gif"></th></tr></thead><tbody><tr><td align="center">图1.1</td></tr></tbody></table><p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/internetWei/LLDynamicLaunchScreen">LLDynamicLaunchScreen</a>支持修复如上问题，您只需要将它集成到您的工程中即可，什么事情都不用做，图2.1这样的情况将可能不会出现在您的APP中，最坏的情况是用户第一次打开APP时可能会出现。</p><table><thead><tr><th align="center"><img src="202102141921.jpg"></th></tr></thead><tbody><tr><td align="center">图2.1</td></tr></tbody></table><h3 id="LLDynamicLaunchScreen介绍"><a href="#LLDynamicLaunchScreen介绍" class="headerlink" title="LLDynamicLaunchScreen介绍"></a>LLDynamicLaunchScreen介绍</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<code>LLDynamicLaunchScreen</code>除了支持上述提到的自动修复启动图莫名其妙变成黑色的BUG，还支持运行时动态修改APP的任意启动图，仅需一行代码即可。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;目前市场上并没有和<code>LLDynamicLaunchScreen</code>类似的框架，github上有一个<code>DynamicLaunchImage</code>框架也实现了动态替换启动图的功能，但是我并不建议您使用它，具体原因我会在下面的对比中详细描述。</p><h3 id="关于LLDynamicLaunchScreen和DynamicLaunchImage"><a href="#关于LLDynamicLaunchScreen和DynamicLaunchImage" class="headerlink" title="关于LLDynamicLaunchScreen和DynamicLaunchImage"></a>关于LLDynamicLaunchScreen和DynamicLaunchImage</h3><ol><li><p><code>LLDynamicLaunchScreen</code>是我开发的一款用于修复iOS上APP启动图异常和动态修改启动图的框架，它实现了如下功能:</p><ol><li>集成后自动修复APP启动图异常显示。</li><li>集成者只需要一行代码即可修改启动图。</li><li>支持修改任意类型的启动图(暗黑竖屏启动图、暗黑横屏启动图、浅色竖屏启动图、浅色横屏启动图)。</li><li>当用户更新APP后自动恢复上一次设置的启动图。</li><li>支持获取当前显示的启动图和任意类型的启动图。</li></ol></li><li><p><code>DynamicLaunchImage</code>是百度团队开发的一款动态修改启动图的框架，它只实现了一个动态修改启动图的功能，而且当用户更新APP后，<code>DynamicLaunchImage</code>并没有记录用户上次的修改信息，它会导致用户更新版本后丢失之前设置的启动图，这是致命的；并且它也不支持单独修改暗黑系启动图或者单独修改浅色系启动图；最致命的是它的开发者并没有继续维护它，我提交了一个issues并没有人去跟进处理。所以建议您使用<a href="https://github.com/internetWei/LLDynamicLaunchScreen">LLDynamicLaunchScreen</a>。</p></li></ol><h3 id="LLDynamicLaunchScreen的具体思路"><a href="#LLDynamicLaunchScreen的具体思路" class="headerlink" title="LLDynamicLaunchScreen的具体思路"></a>LLDynamicLaunchScreen的具体思路</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<code>LLDynamicLaunchScreen</code>它的核心功能其实就是替换系统本地的启动图，但是替换的过程中有如下的问题(只列举了一些比较重要的问题):</p><ol><li>替换系统本地的启动图但不能修改原名称，否则系统会重新生成启动图，这就需要知道本地的启动图名称对应的是哪个具体的启动图(例如本地启动图a.png代表的是深色竖屏启动图还是浅色坚屏启动图还是…)。</li><li>为了实现自动修复启动图异常，需要在APP启动后根据storyboard文件生成一整套的启动图文件并且替换本地的启动图，开发过程中遇到一个问题不管在什么时候生成与系统相反模式的启动图总是失败(例如当前系统是浅色模式，那么在生成深色启动图时实际获取到的总是浅色启动图)，后面通过KVO的思想解决了这个难题，具体思路是利用运行时创建一个自定义的<code>UIViewControler</code>对象并将它与系统的<code>UIViewController</code>的isa指针进行互换，然后监听它的<code>viewDidAppear:</code>方法的实现，在这个方法里再去生成启动图就可以了，当监听完成后会自动释放创建的对象然后将isa指针还原回去。</li><li>在iOS13以下的真机中没有启动图文件夹的读取和修改权限，针对这个问题确实愁了很多天，就在我想放弃iOS13以下系统可以动态修改启动图的想法前，我看到了<code>DynamicLaunchImage</code>的一篇实现文章，文章中提到它也遇到了这个问题，并且通过<code>moveItemAtPath: toPath: error:</code>这个方法解决了。经过测试发现确实可以变相的达到获取启动图信息并且替换启动图的功能，在这里感谢<code>DynamicLaunchImage</code>提供的思路。</li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;具体的实现细节大家可以阅读<a href="https://github.com/internetWei/LLDynamicLaunchScreen">LLDynamicLaunchScreen</a>源码，例如它是怎么在用户更新版本后自动还原至之前的设置。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;如果您有更好的意见或者发现有任何BUG，欢迎您提交<a href="https://github.com/internetWei/LLDynamicLaunchScreen/issues">issues</a>或者联系我。</p><h3 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;由于iOS系统的限制，更新APP后第一次打开会显示默认启动图，之后才会显示自定义的启动图。另外它暂时对iPad的支持性不是很好，因为iPad有多达10种启动图样式，建议不要要iPad中使用它，后续我会升级它支持iPad。<code>LLDynamicLaunchScreen</code>它不支持非LaunchScreen配置的启动图(现在应该没有APP没有使用LaunchScreen适配启动图了吧)。</p><h3 id="LLDynamicLaunchScreen效果图"><a href="#LLDynamicLaunchScreen效果图" class="headerlink" title="LLDynamicLaunchScreen效果图"></a>LLDynamicLaunchScreen效果图</h3><table><thead><tr><th align="center"><img src="160c58e9014740029800c2ffc4752965~tplv-k3u1fbpfcp-zoom-1.image"></th></tr></thead><tbody><tr><td align="center"><a href="https://github.com/internetWei/LLDynamicLaunchScreen">LLDynamicLaunchScreen</a></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ObjC </tag>
            
            <tag> Framework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS适配深色模式最佳方法，绝对干货</title>
      <link href="/2020/12/05/iOS/iOS%E9%80%82%E9%85%8D%E6%B7%B1%E8%89%B2%E6%A8%A1%E5%BC%8F%E6%9C%80%E4%BD%B3%E6%96%B9%E6%B3%95%EF%BC%8C%E7%BB%9D%E5%AF%B9%E5%B9%B2%E8%B4%A7/"/>
      <url>/2020/12/05/iOS/iOS%E9%80%82%E9%85%8D%E6%B7%B1%E8%89%B2%E6%A8%A1%E5%BC%8F%E6%9C%80%E4%BD%B3%E6%96%B9%E6%B3%95%EF%BC%8C%E7%BB%9D%E5%AF%B9%E5%B9%B2%E8%B4%A7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由 布多(budo) 发布于 2020-12-05</p></blockquote><h1 id="LLDark"><a href="#LLDark" class="headerlink" title="LLDark"></a>LLDark</h1><p>适用于iOS的强大深色主题框架，快速适配深色模式。<br>国内用户可以访问<a href="https://gitee.com/internetWei/llDark">这个链接</a></p><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><ul><li>集成简单，只需改动少量代码即可完美适配。</li><li>高性能，仅在需要更新页面时更新指定页面，有相关缓存策略缩短刷新时长。</li><li>功能强大，所有使用UIColor、UIImage、CGColor的地方均可完美适配。</li><li>兼容iOS13以下机型。</li><li>支持从网络上获取深色主题配置。</li><li>自动适配启动图为APP当前主题模式。</li></ul><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p><img src="eb36809a0d784094abb1f173d36e0f5e~tplv-k3u1fbpfcp-zoom-1.image" alt="Manual.gif"> <img src="c62d05b8d9b14c1e9b5fc86d5c4e15fc~tplv-k3u1fbpfcp-zoom-1.image" alt="System.gif"> <img src="ea92ed26bf5e466392e0edf9dc9abe0b~tplv-k3u1fbpfcp-zoom-1.image" alt="Screen.gif"></p><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>配置深色资源：<br>在工程任意NSObject分类(建议单独新建一个主题分类)中创建<code>+ (NSDictionary&lt;id, id&gt; *)llDarkTheme</code>类方法，字典的key表示浅色主题下的颜色&#x2F;图片名称&#x2F;图片地址，字典的value表示深色主题下的颜色&#x2F;图片名称&#x2F;图片地址。可参考样例代码：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSDictionary</span>&lt;<span class="type">id</span>, <span class="type">id</span>&gt; *)llDarkTheme &#123;</span><br><span class="line">    <span class="keyword">return</span> @&#123;</span><br><span class="line">             <span class="built_in">UIColor</span>.whiteColor : kColorRGB(<span class="number">27</span>, <span class="number">27</span>, <span class="number">27</span>),</span><br><span class="line">             kColorRGB(<span class="number">240</span>, <span class="number">238</span>, <span class="number">245</span>) : kColorRGB(<span class="number">39</span>, <span class="number">39</span>, <span class="number">39</span>),</span><br><span class="line">             [<span class="built_in">UIColor</span> colorWithRed:<span class="number">14.0</span> / <span class="number">255.0</span> green:<span class="number">255.0</span> / <span class="number">255.0</span> blue:<span class="number">0.0</span> alpha:<span class="number">1.0</span>] : [<span class="built_in">UIColor</span> colorWithRed:<span class="number">0.0</span> green:<span class="number">14.0</span> / <span class="number">255.0</span> blue:<span class="number">255.0</span> / <span class="number">255.0</span> alpha:<span class="number">1.0</span>],</span><br><span class="line">             <span class="string">@&quot;background_light&quot;</span> : <span class="string">@&quot;background_dark&quot;</span>,</span><br><span class="line">             <span class="string">@&quot;~/path/background_light.png&quot;</span> : <span class="string">@&quot;~/path/background_dark.png&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tips:<br><code>1.不必把所有情况下的颜色/图片都填写进去，对于偶尔或少数使用到的深色颜色可以参考高级用法单独适配。 2.图片名称不用考虑倍图关系；如果填写的是图片路径一定要填写完整的图片路径(包含后缀)。</code></p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>UIColor和CGColor只需要追加.themeColor(nil)即可。<br>UIImage只需要将imageNamed或imageWithContentsOfFile替换为themeImage即可。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UIColor</span></span><br><span class="line"><span class="built_in">UIColor</span>.redColor; <span class="comment">// 之前的用法</span></span><br><span class="line"><span class="built_in">UIColor</span>.redColor.themeColor(<span class="literal">nil</span>); <span class="comment">// 现在的用法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CGColor</span></span><br><span class="line"><span class="built_in">UIColor</span>.redColor.CGColor; <span class="comment">// 之前的用法</span></span><br><span class="line"><span class="built_in">UIColor</span>.redColor.themeCGColor(<span class="literal">nil</span>); <span class="comment">// 现在的用法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// UIImage</span></span><br><span class="line">[<span class="built_in">UIImage</span> imageNamed:<span class="string">@&quot;lightImageName&quot;</span>]; <span class="comment">// 之前的用法</span></span><br><span class="line">[<span class="built_in">UIImage</span> themeImage:<span class="string">@&quot;lightImageName&quot;</span>]; <span class="comment">// 现在的用法</span></span><br></pre></td></tr></table></figure><p>Tips:<br><code>1.themeImage适配了imageNamed和imageWithContentsOfFile两个方法，可以传递图片名称，也可以传递图片路径。 2.只有适配过的Color和Image在主题切换时才会刷新。 </code></p><h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>themeColor()里面的参数如果是具体的Color对象，深色主题则会使用指定的Color对象刷新,</span><br><span class="line">如果是<span class="literal">nil</span>则会返回llDarkTheme中配置的深色颜色刷新，</span><br><span class="line">如果llDarkTheme未配置则会返回浅色主题下的颜色。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>themeCGColor()参数的作用和themeColor()参数作用一样。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>themeImage()有<span class="number">2</span>个参数，参数可以是图片名称，也可以是图片地址,</span><br><span class="line">第<span class="number">1</span>个参数表示浅色主题下使用的图片(必填)，</span><br><span class="line">第<span class="number">2</span>个参数表示深色主题下使用的图片(可以为空)，</span><br><span class="line">第<span class="number">2</span>个参数为空的话和themeColor()为空的处理方式一样。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>appearanceBindUpdater，所有继承自<span class="built_in">UIView</span>的对象都拥有这个属性，</span><br><span class="line">对象需要刷新时会调用它，可以在这里实现自己的刷新逻辑。</span><br><span class="line">仅在需要刷新时会调用，主题更改不一定需要刷新UI。</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>userInterfaceStyle，类似iOS13系统的overrideUserInterfaceStyle方法，</span><br><span class="line">但是功能比overrideUserInterfaceStyle更加强大，</span><br><span class="line">它支持所有的对象，例如<span class="built_in">CALayer</span>。</span><br><span class="line">它支持iOS13以下的系统使用。</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>themeDidChange，所有对象都拥有这个属性，作用和ThemeDidChangeNotification一样，</span><br><span class="line">themeDidChange会在对象释放时被释放掉，</span><br><span class="line">可以在多个地方使用，不保证回调顺序，</span><br><span class="line">不同于appearanceBindUpdater，只要主题发生改变就会调用themeDidChange。</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>systemThemeDidChange，所有对象都拥有这个属性，作用和SystemThemeDidChangeNotification一样，</span><br><span class="line">释放时机和themeDidChange一样，</span><br><span class="line">可以在多个地方使用，不保证回调顺序，</span><br><span class="line">只要系统主题发生改变就会调用systemThemeDidChange。</span><br><span class="line"></span><br><span class="line"><span class="number">8.</span>darkStyle，所有<span class="built_in">UIImageView</span>对象都拥有这个方法，用于适配没有深色图片的图片对象，例如网络图片。</span><br><span class="line">darkStyle有<span class="number">3</span>个参数，第<span class="number">1</span>个参数决定如何适配深色主题，目前有LLDarkStyleSaturation和LLDarkStyleMask两种，</span><br><span class="line">LLDarkStyleMask使用蒙层适配，LLDarkStyleSaturation通过降低原图饱合度适配。</span><br><span class="line">第<span class="number">2</span>个参数决定蒙层透明度/饱合度值，具体使用可看源码注释。</span><br><span class="line">第<span class="number">3</span>个参数可以为<span class="literal">nil</span>，使用LLDarkStyleSaturation时需要传递一个唯一字符串当做标识符，通常是图片的url。</span><br><span class="line">样例代码：</span><br><span class="line"><span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc] init];</span><br><span class="line"><span class="built_in">NSString</span> *url = <span class="string">@&quot;图片URL&quot;</span>;</span><br><span class="line">imageView.darkStyle(LLDarkStyleSaturation, <span class="number">0.2</span>, url);</span><br><span class="line"><span class="comment">// imageView.darkStyle(LLDarkStyleMask, 0.5, nil);</span></span><br><span class="line"></span><br><span class="line"><span class="number">9.</span>updateDarkTheme:，如果需要运行时修改深色主题配置信息，或者需要从网络上获取深色主题配置信息，可以使用updateDarkTheme:来达到目的。</span><br><span class="line">请确保在第<span class="number">1</span>个UI对象加载前配置好深色主题信息，否则会无效。</span><br><span class="line">样例代码:</span><br><span class="line"><span class="built_in">NSDictionary</span> *darkTheme = @&#123;</span><br><span class="line">    <span class="built_in">UIColor</span>.whiteColor : kColorRGB(<span class="number">27</span>, <span class="number">27</span>, <span class="number">27</span>),</span><br><span class="line">    kColorRGB(<span class="number">240</span>, <span class="number">238</span>, <span class="number">245</span>) : kColorRGB(<span class="number">39</span>, <span class="number">39</span>, <span class="number">39</span>),</span><br><span class="line">    [<span class="built_in">UIColor</span> colorWithRed:<span class="number">14.0</span> / <span class="number">255.0</span> green:<span class="number">255.0</span> / <span class="number">255.0</span> blue:<span class="number">0.0</span> alpha:<span class="number">1.0</span>] : [<span class="built_in">UIColor</span> colorWithRed:<span class="number">0.0</span> green:<span class="number">14.0</span> / <span class="number">255.0</span> blue:<span class="number">255.0</span> /  <span class="number">255.0</span> alpha:<span class="number">1.0</span>],</span><br><span class="line">    <span class="string">@&quot;background_light&quot;</span> : <span class="string">@&quot;background_dark&quot;</span>,</span><br><span class="line">    <span class="string">@&quot;~/path/background_light.png&quot;</span> : <span class="string">@&quot;~/path/background_dark.png&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">[LLDarkSource updateDarkTheme:darkTheme];</span><br><span class="line"></span><br><span class="line"><span class="number">10.</span>thirdControlClassName，如果需要支持第<span class="number">3</span>方控件的刷新方法，可以在appearanceBindUpdater中单独实现刷新逻辑，也可以按照如下方法实现刷新逻辑，更加推荐如下方法。</span><br><span class="line">首先需要实现thirdControlClassName这个类方法，并返回一个数组，数组包含第<span class="number">3</span>方控件的类名字符串。</span><br><span class="line">然后实现refresh+类名字符串的对象方法，在方法里实现第<span class="number">3</span>方控件的刷新逻辑，可以参考LLThird.m文件中已经实现的YYLabel的刷新逻辑。</span><br><span class="line">详情可以下载工程查看Demo了解具体实现。</span><br></pre></td></tr></table></figure><p>高级用法中第8条darkStyle方法的样例图(为了突出效果特意将饱合度和透明度调整的很低)：<br><img src="1241324201ce4deea2ab431d547b9a62~tplv-k3u1fbpfcp-zoom-1.image" alt="137a9000178656346577e"> </p><h1 id="快速适配"><a href="#快速适配" class="headerlink" title="快速适配"></a>快速适配</h1><p>仅需要3步即可快速完美适配深色主题模式，经测试大部分工程都能在0.5天内适配完成，<br>少量工程1天内适配完成，极少需要1天以上的工作量进行适配。</p><ol><li>配置深色主题资源，可参考<code>前提</code>，也可以参考<code>高级方法9</code>从网络中获取资源适配。</li><li>将需要适配的Color和Image适配为主题Color和主题Image，适配方法可参考<code>基础用法</code>和<code>高级用法</code>。</li><li>运行工程，检查完整性。</li></ol><p>Tips:<br>如果您还需要适配<code>WKWebView</code>，可以<a href="https://www.jianshu.com/p/be578117f84c">点击链接</a>参考文章进行适配。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h3 id="CocoaPods"><a href="#CocoaPods" class="headerlink" title="CocoaPods"></a>CocoaPods</h3><ol><li>将 cocoapods 更新至最新版本。</li><li>在 Podfile 中添加 pod ‘LLDark’。</li><li>执行 pod install 或 pod update。</li><li>导入 &lt;LLDark&#x2F;LLDark.h&gt;。</li></ol><h3 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h3><ol><li>下载 LLDark 文件夹内的所有内容。</li><li>将 LLDark 工程中的LLDark文件夹添加(拖放)到你的工程。</li><li>导入 “LLDark.h”。</li></ol><h1 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h1><p>该项目最低支持iOS9.0和Xcode10.0，如果想在更低系统上使用请联系作者。</p><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ol><li>需要自己监听主题模式修改状态栏颜色。</li></ol><h1 id="已知问题"><a href="#已知问题" class="headerlink" title="已知问题"></a>已知问题</h1><ul><li>需要适配深色主题的图片资源请不要放在Assets.xcassets中，否则可能会获取不到。</li><li>暂时不支持其他主题模式，后续会支持多种主题自由搭配。</li></ul><h1 id="联系作者"><a href="#联系作者" class="headerlink" title="联系作者"></a>联系作者</h1><p>如果你有更好的改进，please pull reqeust me</p><p>如果你有任何更好的意见，请创建一个<a href="https://github.com/internetWei/llDark/issues">Issue</a></p><p>可以通过此邮箱联系作者<code>internetwei@foxmail.com</code></p><h1 id="许可证"><a href="#许可证" class="headerlink" title="许可证"></a>许可证</h1><p>LLDark 使用 MIT 许可证，详情见 LICENSE 文件。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ObjC </tag>
            
            <tag> Framework </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
