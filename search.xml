<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2024 再探ObjC-Category：动态特性与运行时实现的极致之美</title>
      <link href="/2024/12/11/iOS/2024%20%E5%86%8D%E6%8E%A2ObjC-Category%EF%BC%9A%E5%8A%A8%E6%80%81%E7%89%B9%E6%80%A7%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%9E%81%E8%87%B4%E4%B9%8B%E7%BE%8E/"/>
      <url>/2024/12/11/iOS/2024%20%E5%86%8D%E6%8E%A2ObjC-Category%EF%BC%9A%E5%8A%A8%E6%80%81%E7%89%B9%E6%80%A7%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%9E%81%E8%87%B4%E4%B9%8B%E7%BE%8E/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由 布多(budo) 发布于 2024-12-11 • 最后更新于2025-02-26</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Category 是 ObjC 中一个基础且重要的概念。本文将从 Runtime 源码入手，向你介绍 Category 的概念以及底层的实现原理。</p><h2 id="Category-概念"><a href="#Category-概念" class="headerlink" title="Category 概念"></a>Category 概念</h2><p>Category 主要是用来给已存在的类动态添加方法实现，也可扩展协议和属性。基于此特性，我们可以用 Category 实现如下功能：</p><ul><li><p>将一个庞大的类分解成多个 Category，每个 Category 只完成少量的任务，从而提高模块化和代码解耦程度。</p></li><li><p>在不继承的情况下给已有类动态的添加新方法。</p></li><li><p>模拟多继承，比如让已有类支持新协议。</p></li></ul><h2 id="Category-之编译期实现细节"><a href="#Category-之编译期实现细节" class="headerlink" title="Category 之编译期实现细节"></a>Category 之编译期实现细节</h2><p>创建一个 ObjC 源代码文件并将其命名为 <code>test_category.m</code>，然后在文件内输入如下代码：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">WXLCategory</span>)&lt;<span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> () <span class="built_in">NSInteger</span> wxl_ist_prot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>) <span class="built_in">NSInteger</span> wxl_cls_prot;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)wxl_ist_func;</span><br><span class="line">+ (<span class="type">void</span>)wxl_cls_func;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">WXLExtension</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)wxl_ist_func &#123;&#125;</span><br><span class="line">+ (<span class="type">void</span>)wxl_cls_func &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><blockquote><p>这里我特意只写了方法的实现，而没有写属性和协议的实现，后面会解释为什么。</p></blockquote><p>使用 <code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc test_category.m</code> 命令可以将上述代码编译为 C++ 文件，代码精简后如下所示：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">category_t</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">class_t</span> *cls;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">method_list_t</span> *instance_methods;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">method_list_t</span> *class_methods;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">protocol_list_t</span> *protocols;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">prop_list_t</span> *instanceProperties;</span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">prop_list_t</span> *_classProperties;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">category_t</span> _OBJC_$_CATEGORY_NSObject_$_WXLCategory </span><br><span class="line">__attribute__ ((used, <span class="built_in">section</span> (<span class="string">&quot;__DATA, __objc_const&quot;</span>))) = </span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;NSObject&quot;</span>,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">(<span class="type">const</span> <span class="keyword">struct</span> <span class="type">method_list_t</span> *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_NSObject_$_WXLCategory,</span><br><span class="line">(<span class="type">const</span> <span class="keyword">struct</span> <span class="type">method_list_t</span> *)&amp;_OBJC_$_CATEGORY_CLASS_METHODS_NSObject_$_WXLCategory,</span><br><span class="line">(<span class="type">const</span> <span class="keyword">struct</span> <span class="type">protocol_list_t</span> *)&amp;_OBJC_CATEGORY_PROTOCOLS_$_NSObject_$_WXLCategory,</span><br><span class="line">(<span class="type">const</span> <span class="keyword">struct</span> <span class="type">prop_list_t</span> *)&amp;_OBJC_$_INSTANCE_PROP_LIST_NSObject_$_WXLCategory,</span><br><span class="line">(<span class="type">const</span> <span class="keyword">struct</span> <span class="type">prop_list_t</span> *)&amp;_OBJC_$_CLASS_PROP_LIST_NSObject_$_WXLCategory,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><code>_classProperties</code> 变量是我参考 Runtime 源码后手动加上的，你编译的代码可能会没有。</p></blockquote><p>从编译后的代码中不难看出，一个 Category 对象，其底层其实就是1个 <code>category_t</code> 的结构体对象，这个结构体中包含了实例属性、类属性、实例方法、类方法以及协议等变量用来保存分类中的相关数据。</p><p>最后，编译器会把 <code>category_t</code> 相关数据保存在 Mach-O 文件的 objc_const 数据段下，等待运行时解析。</p><h2 id="Category-之运行时实现细节：探索内部实现原理"><a href="#Category-之运行时实现细节：探索内部实现原理" class="headerlink" title="Category 之运行时实现细节：探索内部实现原理"></a>Category 之运行时实现细节：探索内部实现原理</h2><p>相关代码整理后如下所示（代码有点长，不想看可以跳过，后面有解释）：</p><blockquote><p>本文使用的 Runtime 版本是 <a href="https://github.com/apple-oss-distributions/objc4/tree/objc4-928.2">objc4-928.2</a>，为了方便阅读，我对代码样式和排版略作了修改以及删减了一些不影响主逻辑的冗余代码。</p><p>我在 <a href="https://github.com/internetWei/ObjCRuntimes">这里</a> 维护了一个可以直接运行调试的 Runtime 项目，方便大家直接调试源码。</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">load_images</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> _dyld_objc_notify_mapped_info* info)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查该模块是否有 +load 方法的实现。</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">hasLoadMethods</span>((<span class="type">const</span> headerType *)info-&gt;mh,</span><br><span class="line">                        info-&gt;sectionLocationMetadata)) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加载所有分类。</span></span><br><span class="line">    <span class="built_in">loadAllCategoriesIfNeeded</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> didInitialAttachCategories = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loadAllCategoriesIfNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 控制不要重复加载分类数据，每加载一个模块时都可能会来到这里。</span></span><br><span class="line">    <span class="keyword">if</span> (!didInitialAttachCategories) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         遍历所有模块并加载它们的分类数据。</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">         注意：在加载第1个模块时就会执行该函数，</span></span><br><span class="line"><span class="comment">         这意味着在加载第1个模块时就会把所有模块中的分类数据都加载，</span></span><br><span class="line"><span class="comment">         而不是只加载当前模块中的分类数据。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> *hi = FirstHeader; hi != <span class="literal">NULL</span>; hi = hi-&gt;<span class="built_in">getNext</span>()) &#123;</span><br><span class="line">            <span class="built_in">load_categories_nolock</span>(hi);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        didInitialAttachCategories = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">load_categories_nolock</span><span class="params">(header_info *hi)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前模块是否有分类类属性。</span></span><br><span class="line">    <span class="type">bool</span> hasClassProperties = hi-&gt;<span class="built_in">info</span>()-&gt;<span class="built_in">hasCategoryClassProperties</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="type">size_t</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历当前模块中的所有分类数据并进行处理。</span></span><br><span class="line">    <span class="keyword">auto</span> processCatlist = [&amp;](<span class="type">category_t</span> * <span class="type">const</span> *catlist) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="type">category_t</span> *cat = catlist[i];</span><br><span class="line">            Class cls = <span class="built_in">remapClass</span>(cat-&gt;cls);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 把 cat、cls、hi 包装一下，方便后面调用函数时传参。</span></span><br><span class="line">            <span class="type">locstamped_category_t</span> lc&#123;cat, cls, hi&#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 检查这个分类中是否有实例方法、协议、实例属性。</span></span><br><span class="line">            <span class="keyword">if</span> (cat-&gt;instanceMethods ||</span><br><span class="line">                cat-&gt;protocols ||</span><br><span class="line">                cat-&gt;instanceProperties) &#123;</span><br><span class="line">                <span class="comment">// 检查 cls 是否已实现，</span></span><br><span class="line">                <span class="keyword">if</span> (cls-&gt;<span class="built_in">isRealized</span>()) &#123;</span><br><span class="line">                    <span class="comment">// 将分类中的实例方法、协议、实例属性添加到 cls 上。</span></span><br><span class="line">                    <span class="built_in">attachCategories</span>(cls, &amp;lc, <span class="number">1</span>, cls, ATTACH_EXISTING);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 将分类数据和类对象保存起来，等类对象实现后再进行加载。</span></span><br><span class="line">                    objc::unattachedCategories.<span class="built_in">addForClass</span>(lc, cls);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             检查这个分类中是否有类方法、协议、类属性。</span></span><br><span class="line"><span class="comment">             </span></span><br><span class="line"><span class="comment">             注意 `(hasClassProperties &amp;&amp; cat-&gt;_classProperties)` 这段代码，</span></span><br><span class="line"><span class="comment">             可能是因为使用类属性的项目非常少，所以加入了这一个判断。</span></span><br><span class="line"><span class="comment">             </span></span><br><span class="line"><span class="comment">             这里是在给元类对象添加方法和属性，但是，元类对象是没有协议的。不清楚这</span></span><br><span class="line"><span class="comment">             里为什么要判断 `cat-&gt;protocols`。</span></span><br><span class="line"><span class="comment">             </span></span><br><span class="line"><span class="comment">             另外，在后面获取分类的协议列表时也有判断，如果是给元类添加的话就直接返回 </span></span><br><span class="line"><span class="comment">             NULL。感觉这段代码其实可以删掉，不知道是否有其它隐情？</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (cat-&gt;classMethods ||</span><br><span class="line">                cat-&gt;protocols ||</span><br><span class="line">                (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cls-&gt;<span class="built_in">ISA</span>()-&gt;<span class="built_in">isRealized</span>()) &#123;</span><br><span class="line">                    <span class="comment">// 将分类中的类方法、类属性加载到元类上。</span></span><br><span class="line">                    <span class="built_in">attachCategories</span>(cls-&gt;<span class="built_in">ISA</span>(), &amp;lc, <span class="number">1</span>, cls, </span><br><span class="line">                    ATTACH_EXISTING | ATTACH_METACLASS);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 将分类数据和元类对象保存起来，等元类对象实现后再进行加载。</span></span><br><span class="line">                    objc::unattachedCategories.<span class="built_in">addForClass</span>(</span><br><span class="line">                    lc.<span class="built_in">reSignedForMetaclass</span>(cls), </span><br><span class="line">                    cls-&gt;<span class="built_in">ISA</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">processCatlist</span>(hi-&gt;<span class="built_in">catlist</span>(&amp;count));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> cls: 需要把分类数据添加到哪个类上。</span></span><br><span class="line"><span class="comment"> 如果添加的是实例方法、实例属性、协议，这个参数就是类对象；</span></span><br><span class="line"><span class="comment"> 如果添加的是类方法、类属性，这个参数就是元类对象。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> cats_list: 需要被添加的分类数据，注意这是一个数组。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> catsListKey: 分类所属的类对象。</span></span><br><span class="line"><span class="comment"> 不管添加的是实例方法还是类方法，始终指向该分类所属的类对象，不会是元类对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">attachCategories</span><span class="params">(Class cls,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">const</span> <span class="type">locstamped_category_t</span> *cats_list,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">uint32_t</span> cats_count,</span></span></span><br><span class="line"><span class="params"><span class="function">                 Class catsListKey,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">uint32_t</span> ATTACH_BUFSIZ = <span class="number">64</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     一个临时的缓存结构。分类中的方法、属性、协议会被临时添加到这个缓存对象中去，</span></span><br><span class="line"><span class="comment">     当缓存容量满了，或者分类中的数据加载完了，再一次性添加到类中去。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Lists</span> &#123;</span><br><span class="line">        ReversedFixedSizeArray&lt;<span class="type">method_list_t</span> *, ATTACH_BUFSIZ&gt; methods;</span><br><span class="line">        ReversedFixedSizeArray&lt;<span class="type">property_list_t</span> *, ATTACH_BUFSIZ&gt; properties;</span><br><span class="line">        ReversedFixedSizeArray&lt;<span class="type">protocol_list_t</span> *, ATTACH_BUFSIZ&gt; protocols;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    Lists normalLists;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> isMeta = (flags &amp; ATTACH_METACLASS);</span><br><span class="line">    <span class="keyword">auto</span> rwe = cls-&gt;<span class="built_in">data</span>()-&gt;<span class="built_in">extAllocIfNeeded</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; cats_count; i++) &#123;</span><br><span class="line">        <span class="comment">// entry 的原型：locstamped_category_t &#123;cat, cls, hi&#125;</span></span><br><span class="line">        <span class="keyword">auto</span>&amp; entry = cats_list[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取分类中的方法列表。</span></span><br><span class="line">        <span class="type">method_list_t</span> *mlist = entry.<span class="built_in">getCategory</span>(catsListKey)-&gt;<span class="built_in">methodsForMeta</span>(isMeta);</span><br><span class="line">        Lists *lists = &amp;normalLists;</span><br><span class="line">        <span class="type">bool</span> isPreattached = </span><br><span class="line">        entry.hi-&gt;<span class="built_in">info</span>()-&gt;<span class="built_in">dyldCategoriesOptimized</span>() &amp;&amp; !DisablePreattachedCategories;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lists-&gt;methods.<span class="built_in">isFull</span>()) &#123;</span><br><span class="line">                <span class="comment">// 将缓存中的方法全部添加到类/元类中。</span></span><br><span class="line">                rwe-&gt;methods.<span class="built_in">attachLists</span>(lists-&gt;methods.array, </span><br><span class="line">                lists-&gt;methods.count, </span><br><span class="line">                isPreattached, </span><br><span class="line">                PrintPreopt ? <span class="string">&quot;methods&quot;</span> : <span class="literal">nullptr</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 清空缓存。</span></span><br><span class="line">                lists-&gt;methods.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将分类中的方法添加到缓存。</span></span><br><span class="line">            lists-&gt;methods.<span class="built_in">add</span>(mlist);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取分类中的属性列表。</span></span><br><span class="line">        <span class="type">property_list_t</span> *proplist =</span><br><span class="line">        entry.<span class="built_in">getCategory</span>(catsListKey)-&gt;<span class="built_in">propertiesForMeta</span>(isMeta, entry.hi);</span><br><span class="line">        <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lists-&gt;properties.<span class="built_in">isFull</span>()) &#123;</span><br><span class="line">                <span class="comment">// 将缓存中的属性全部添加到类/元类中。</span></span><br><span class="line">                rwe-&gt;properties.<span class="built_in">attachLists</span>(lists-&gt;properties.array, </span><br><span class="line">                lists-&gt;properties.count, </span><br><span class="line">                isPreattached, </span><br><span class="line">                PrintPreopt ? <span class="string">&quot;properties&quot;</span> : <span class="literal">nullptr</span>);</span><br><span class="line">                </span><br><span class="line">                lists-&gt;properties.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将分类中的属性添加到缓存。</span></span><br><span class="line">            lists-&gt;properties.<span class="built_in">add</span>(proplist);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取分类中的协议列表，内部会通过 isMeta 判断如果是元类就返回 NULL。</span></span><br><span class="line">        <span class="type">protocol_list_t</span> *protolist = </span><br><span class="line">        entry.<span class="built_in">getCategory</span>(catsListKey)-&gt;<span class="built_in">protocolsForMeta</span>(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lists-&gt;protocols.<span class="built_in">isFull</span>()) &#123;</span><br><span class="line">                <span class="comment">// 将缓存中的协议全部添加到类/元类中。</span></span><br><span class="line">                rwe-&gt;protocols.<span class="built_in">attachLists</span>(lists-&gt;protocols.array, </span><br><span class="line">                lists-&gt;protocols.count, </span><br><span class="line">                isPreattached, </span><br><span class="line">                PrintPreopt ? <span class="string">&quot;protocols&quot;</span> : <span class="literal">nullptr</span>);</span><br><span class="line">                </span><br><span class="line">                lists-&gt;protocols.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将分类中的协议添加到缓存。</span></span><br><span class="line">            lists-&gt;protocols.<span class="built_in">add</span>(protolist);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将缓存里的方法、属性、协议全部添加到类/元类中。</span></span><br><span class="line">    <span class="keyword">auto</span> attach = [&amp;](Lists *lists, <span class="type">bool</span> isPreattached) &#123;</span><br><span class="line">        <span class="comment">// 将缓存里的方法添加到类/元类中。</span></span><br><span class="line">        rwe-&gt;methods.<span class="built_in">attachLists</span>(lists-&gt;methods.<span class="built_in">begin</span>(), </span><br><span class="line">        lists-&gt;methods.count, </span><br><span class="line">        isPreattached, </span><br><span class="line">        PrintPreopt ? <span class="string">&quot;methods&quot;</span> : <span class="literal">nullptr</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将缓存里的属性添加到类/元类中。</span></span><br><span class="line">        rwe-&gt;properties.<span class="built_in">attachLists</span>(lists-&gt;properties.<span class="built_in">begin</span>(), </span><br><span class="line">        lists-&gt;properties.count, </span><br><span class="line">        isPreattached, </span><br><span class="line">        PrintPreopt ? <span class="string">&quot;properties&quot;</span> : <span class="literal">nullptr</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将缓存里的协议添加到类中。</span></span><br><span class="line">        rwe-&gt;protocols.<span class="built_in">attachLists</span>(lists-&gt;protocols.<span class="built_in">begin</span>(), </span><br><span class="line">        lists-&gt;protocols.count, </span><br><span class="line">        isPreattached, </span><br><span class="line">        PrintPreopt ? <span class="string">&quot;protocols&quot;</span> : <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">attach</span>(&amp;normalLists, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 这个函数的作用是把方法、属性、协议添加到类/元类中，</span></span><br><span class="line"><span class="comment"> 不一定是添加分类中的数据，也有可能是添加类自身的数据。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">attachLists</span><span class="params">(List* <span class="type">const</span> * addedLists,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">uint32_t</span> addedCount,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">bool</span> preoptimized,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">const</span> <span class="type">char</span> *logKind)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个分支通常是用来添加类自身的方法、属性、协议。</span></span><br><span class="line">    <span class="keyword">if</span> (storage.<span class="built_in">isNull</span>() &amp;&amp; addedCount == <span class="number">1</span>) &#123;</span><br><span class="line">        storage.<span class="built_in">set</span>(*addedLists);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这个分支通常是用来处理第1个分类的数据。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (storage.<span class="built_in">isNull</span>() || storage.<span class="keyword">template</span> <span class="built_in">is</span>&lt;List *&gt;()) &#123;</span><br><span class="line">        <span class="comment">// 0 or 1 list -&gt; many lists</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取旧数据。</span></span><br><span class="line">        List *oldList = storage.<span class="keyword">template</span> <span class="built_in">dyn_cast</span>&lt;List *&gt;();</span><br><span class="line">        <span class="type">uint32_t</span> oldCount = oldList ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="type">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 开辟一个新数组，足以容纳旧数据加上分类中的新数据。</span></span><br><span class="line">        <span class="type">array_t</span> *array = (<span class="type">array_t</span> *)<span class="built_in">malloc</span>(<span class="type">array_t</span>::<span class="built_in">byteSize</span>(newCount));</span><br><span class="line">        storage.<span class="built_in">set</span>(array);</span><br><span class="line">        array-&gt;count = newCount;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         将类中原来的数据（方法、属性、协议）放到数组最后面。</span></span><br><span class="line"><span class="comment">         这一步保证了类自身的数据永远处于列表的最后面。         </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (oldList) array-&gt;lists[addedCount] = oldList;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将分类中的数据插入到数组的前面。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; addedCount; i++)</span><br><span class="line">            array-&gt;lists[i] = addedLists[i];</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 这个分支通常是用来加载第2个及之后的分类数据。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="type">array_t</span> *array = storage.<span class="keyword">template</span> <span class="built_in">dyn_cast</span>&lt;<span class="type">array_t</span> *&gt;()) &#123;</span><br><span class="line">        <span class="comment">// many lists -&gt; many lists</span></span><br><span class="line">        <span class="type">uint32_t</span> oldCount = array-&gt;count;</span><br><span class="line">        <span class="type">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">        <span class="type">array_t</span> *newArray = (<span class="type">array_t</span> *)<span class="built_in">malloc</span>(<span class="type">array_t</span>::<span class="built_in">byteSize</span>(newCount));</span><br><span class="line">        newArray-&gt;count = newCount;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 把旧数据按照之前的顺序放到新数组的最后面。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = oldCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            newArray-&gt;lists[i + addedCount] = array-&gt;lists[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         将分类数据依次添加到数组的前面，</span></span><br><span class="line"><span class="comment">         这一步操作会导致最后编译的分类数据将会被添加在数组的最前面。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; addedCount; i++)</span><br><span class="line">            newArray-&gt;lists[i] = addedLists[i];</span><br><span class="line">            </span><br><span class="line">        <span class="built_in">free</span>(array);</span><br><span class="line">        storage.<span class="built_in">set</span>(newArray);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         一般情况下不会来到这个分支，</span></span><br><span class="line"><span class="comment">         在之前的函数 load_categories_nolock 中有这样一行代码：</span></span><br><span class="line"><span class="comment">         `objc::unattachedCategories.addForClass(lc, cls);`</span></span><br><span class="line"><span class="comment">         这个分支就是用来处理这种情况。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">auto</span> *listList = storage.<span class="keyword">template</span> dyn_cast&lt;<span class="type">relative_list_list_t</span>&lt;List&gt; *&gt;()) &#123;</span><br><span class="line">        <span class="comment">// list-of-lists -&gt; many lists</span></span><br><span class="line">        <span class="keyword">auto</span> listListBegin = listList-&gt;<span class="built_in">beginLists</span>();</span><br><span class="line">        <span class="type">uint32_t</span> oldCount = listList-&gt;<span class="built_in">countLists</span>();</span><br><span class="line">        <span class="type">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">        <span class="type">array_t</span> *newArray = (<span class="type">array_t</span> *)<span class="built_in">malloc</span>(<span class="type">array_t</span>::<span class="built_in">byteSize</span>(newCount));</span><br><span class="line">        newArray-&gt;count = newCount;</span><br><span class="line">        </span><br><span class="line">        <span class="type">uint32_t</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; addedCount; i++) &#123;</span><br><span class="line">            newArray-&gt;lists[i] = addedLists[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (; i &lt; newCount; i++) &#123;</span><br><span class="line">            newArray-&gt;lists[i] = *listListBegin;</span><br><span class="line">            ++listListBegin;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        storage.<span class="built_in">set</span>(newArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中不难发现，Category 中的数据（方法、属性、协议）都是在运行时通过 Runtime 动态添加到类中一个叫做 rwe 的对象中。</p><p>在 rwe 这个对象中拥有三个变量，分别是：方法列表、属性列表、协议列表，这个变量其实就是一个二维数组。以方法列表为例，类自身的所有方法是一个数组，每个 Category 中的所有方法是一个数组，它们都被放在这个二维数组中，注意，类自身的方法列表放在这个二维数组的最后面，最后编译的那个 Category 中的方法列表放在这个二维数组的最前面。</p><p>正是因为这个特点才导致了 Category 中的方法实现会覆盖与类本身同名的方法实现。所以，在开发过程中我们经常会看到很多框架都会给 Category 的方法和属性添加前缀，其目的就是为了降低重名的可能性。</p><p>有些人说 Category 不支持添加实例变量是因为 <code>category_t</code> 结构体中没有 <code>ivars</code> 字段。其实并不是添加一个字段的事，根本原因是因为开发者可能会用 Category 给已经编译好的类（例如系统类）添加数据，而这些类的内存布局与地址已经固定死了，如果要给它添加实例变量势必要修改其内存布局与地址。</p><p>另外，也不能给 Category 添加 weak 属性，如果一定要添加 weak 属性的话，可以采用中间者模式，即给 Category 添加一个中间者对象，然后给这个中间类声明一个 weak 属性。关于 weak 指针的更多细节请看我的另一篇文章 <a href="/2023/10/21/iOS/%E6%8F%AD%E5%BC%80%20iOS%20%E4%B8%AD%20weak%20%E6%8C%87%E9%92%88%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1%EF%BC%9A%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5/" title="揭开 iOS 中 weak 指针的神秘面纱：从原理到实践">揭开 iOS 中 weak 指针的神秘面纱：从原理到实践</a></p><p>我在网上看到有些人说为什么要把 Category 设计成使用 Runtime 运行时加载，直接设计成编译时加载不是更好吗？他们的想法是：“在给项目中某个类（这个类是在项目中创建的），例如 CustomClass 创建分类时，编译器其实能拿到 CustomClass 的实现文件，那么只要把分类中的方法和这个类自身的方法合并不就行了，这样还能实现在 Category 中给这个类添加实例变量。” 乍一看没啥问题。但是，Category 还支持给已经编译好的类（例如系统类）添加方法实现，而这些类的布局和地址已经固定死了，因而不能这么干。</p><p>在阅读源码的过程中，我还发现了一些其它问题：</p><ol><li><p>在前面的 <code>test_category.m</code> 文件中，我特意没有在实现中写上属性和协议的实现。因为经过我的调试发现，Runtime 在解析 Category 中的属性和协议时，只看声明并不看实现，只要有属性、协议声明，不管有没有实现都会被添加到类的属性列表和协议列表中。但是在解析方法的时候是反过来的，只会把有方法实现的那些方法添加到方法列表中。</p></li><li><p>在第1个函数 load_images 中有这么一个判断：如果该模块中没有 <code>+load</code> 方法实现就不添加 Category 数据。我查阅了许多资料，但是都没有找到可信的证据解释为什么要这样做？如果你知道为什么的话还请留言告知。</p></li><li><p>Runtime 会在 <code>loadAllCategoriesIfNeeded</code> 函数内一次性加载所有模块中的分类数据，而不是遍历一个模块加载一个模块中的分类数据。我想了一下，这么做有以下好处：降低程序的复杂度和提高性能。如果是遍历一个模块加载一个模块的数据，那就不能只使用一个全局变量 <code>didInitialAttachCategories</code> 来标记分类数据是否已加载？可能要维护一个字典，例如 key 是模块名称，value 表示该模块是否已加载分类。这么做显然比维护一个全局变量成本更高。</p></li></ol><h2 id="Category-与-Extension-的区别"><a href="#Category-与-Extension-的区别" class="headerlink" title="Category 与 Extension 的区别"></a>Category 与 Extension 的区别</h2><p>经常有人把 Category 和 Extension 拿到一起来说，可能是因为它们的声明方式有点像吧，以下是 Category 和 Extension 的声明代码：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Category 声明</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> (<span class="title">CategoryName</span>) @<span class="title">end</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Extension 声明</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> () @<span class="title">end</span></span></span><br></pre></td></tr></table></figure><p>从代码来看，Category 似乎只多了一个 name 而已。所以导致很多人以为它们的底层实现可能差不多，但其实它们的实现压根不一样。</p><h3 id="Extension-的特点"><a href="#Extension-的特点" class="headerlink" title="Extension 的特点"></a>Extension 的特点</h3><p>从功能和底层实现上来看，其实 Extension 和 Interface(类声明) 更像一些，Interface 能干的事，它基本上都能干，除了不能指定父类。</p><p>Interface 一般是用来对外提供接口数据，但有时候我们会想把一些属性、方法、实例变量隐藏起来。Extension 就是专门用来干这个的，因为 Interface 只能有一个，但 Extension 可以有多个。Extension 和类声明都是编译特性，你可以在 Extension 中声明实例变量、属性、方法、协议，这和在 Interface 中写本质上是一样的。</p><blockquote><p>需要注意一点，虽然在 Extension 中可以声明实例变量，但仅在拥有 implementation 实现的这个文件中这么做才可以，例如以下代码就可以，因为这个文件中拥有 Book 的实现：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Book</span> () </span>&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *_name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Book</span></span></span><br><span class="line">- (<span class="type">void</span>)testFun &#123;</span><br><span class="line">    _name = <span class="string">@&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, _name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>例如下面的代码就不行，因为这个文件中没有 Book 类的实现，此时你会得到一个编译错误：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Book</span> () </span>&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *_name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Book</span> (<span class="title">CategoryName</span>)</span></span><br><span class="line">- (<span class="type">void</span>)testFun &#123;</span><br><span class="line">    _name = <span class="string">@&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, _name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></blockquote><p>另外，虽然在任何地方都能使用 Extension，但是和上面的实例变量一样，如果需要编译器自动生成实现代码（例如属性），那就不能在 implementation 之外的文件使用，切记！！！</p><p>Extension 还有一个好用的功能就是声明私有方法，这样就能在后面的代码中直接调用这个方法了，而不是写成这样：<code>[self performSelector:@selector(testFun)]</code>，网上有很多人是使用 Category 干这个事，其实 Extension 也可以，个人感觉这样更优雅。</p><h3 id="Category-的特点"><a href="#Category-的特点" class="headerlink" title="Category 的特点"></a>Category 的特点</h3><p>与 Extension 相比，Category 是编译器加上 Runtime 共同完成的。编译器负责将 Category 编译成 <code>category_t</code> 对象，然后添加到 Mach-O 文件中。Runtime 负责在运行时将 <code>category_t</code> 中的数据解析并添加到对应的类中。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从苹果提供的源码中我们不难发现，其实 Category 的底层实现并不复杂，其本质就是将 Category 转化成一个结构体用来保存相关数据（属性、方法、协议），然后通过 Runtime 在运行时将这个结构体中的数据解析出来并且添加到类中。而这个类对象内部有一个二维数组来存储每个分类中的数据。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ObjC </tag>
            
            <tag> Runtime </tag>
            
            <tag> Category </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入解析 iOS-RunLoop：事件驱动的核心机制</title>
      <link href="/2024/04/28/iOS/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%20iOS-RunLoop%EF%BC%9A%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/"/>
      <url>/2024/04/28/iOS/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%20iOS-RunLoop%EF%BC%9A%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由 布多(budo) 发布于 2024-04-28 • 最后更新于 2025-03-21</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>RunLoop 是 iOS 开发中的一个基础概念，苹果有许多功能都依赖于 RunLoop，例如线程中的自动释放池、NSTimer、系统事件响应、屏幕刷新等。本文将深入剖析 iOS 中 RunLoop 的内部实现细节，帮助你更好地理解这一机制。</p><h2 id="什么是-Even-Loop"><a href="#什么是-Even-Loop" class="headerlink" title="什么是 Even Loop"></a>什么是 Even Loop</h2><p>在讨论 RunLoop 之前，先了解一下线程的基本概念。通常，线程执行完一个任务后就会退出，要重新执行任务只能再创建一个新线程。但如果我们希望线程在处理完任务后不退出，而是等待并处理新的任务，就需要一种机制来保持线程的活动状态，这就是 <a href="https://en.wikipedia.org/wiki/Event_loop">Even Loop</a>（事件循环）。</p><p>在 iOS 中，这个机制由 RunLoop 实现。它是一个持续运行的循环，负责管理线程中的事件和消息，确保线程在没有任务时进入休眠状态，在有任务时被唤醒并处理。</p><h2 id="RunLoop-的工作原理"><a href="#RunLoop-的工作原理" class="headerlink" title="RunLoop 的工作原理"></a>RunLoop 的工作原理</h2><p>RunLoop 本质上是一个对象，它管理需要处理的事件。线程启动 RunLoop 后，会一直处理「接受消息 -&gt; 处理消息 -&gt; 等待消息」的循环中，实现逻辑大致如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">startRunLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var message = <span class="built_in">get_next_message</span>();</span><br><span class="line">        <span class="built_in">process_message</span>(message);</span><br><span class="line">    &#125; <span class="keyword">while</span> (message != quit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RunLoop-的实现细节"><a href="#RunLoop-的实现细节" class="headerlink" title="RunLoop 的实现细节"></a>RunLoop 的实现细节</h2><p>在 iOS 中，RunLoop 通过两个对象提供：NSRunLoop 和 CFRunLoopRef。其中，NSRunLoop 是 CFRunLoopRef 的封装，提供了面向对象的 API。</p><p>RunLoop 被包含在开源项目 <a href="ttps://github.com/apple-oss-distributions/CF">Core Foundation</a> 中，你可以下载查看。</p><blockquote><p>本文使用的 Core Foundation 版本是 <a href="https://github.com/apple-oss-distributions/CF/releases/tag/CF-1153.18">CF-1153.18</a>，为了方便阅读，我对代码样式和排版略作了修改以及删减了一些不影响主逻辑的冗余代码。</p></blockquote><h3 id="RunLoop-入口"><a href="#RunLoop-入口" class="headerlink" title="RunLoop 入口"></a>RunLoop 入口</h3><p>首先看看 CFRunLoopRun 和 CFRunLoopRunInMode 的实现，这两个函数负责启动 RunLoop：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用默认 Mode 启动。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CFRunLoopRun</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int32_t</span> result;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        result = <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- modeName: 指定要使用的 Mode。</span></span><br><span class="line"><span class="comment">- seconds: 设置 RunLoop 的超时时间。</span></span><br><span class="line"><span class="comment">- returnAfterSourceHandled: 如果是YES，则运行完后立即返回。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">SInt32 <span class="title">CFRunLoopRunInMode</span><span class="params">(CFStringRef modeName,</span></span></span><br><span class="line"><span class="params"><span class="function">                          CFTimeInterval seconds,</span></span></span><br><span class="line"><span class="params"><span class="function">                          Boolean returnAfterSourceHandled)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(),</span><br><span class="line">                                modeName,</span><br><span class="line">                                seconds,</span><br><span class="line">                                returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用 <code>CFRunLoopRunSpecific</code>，RunLoop 会进入具体的模式进行运行，直到满足退出的条件。</p><p>接下来的关键函数是 CFRunLoopRunSpecific，它会获取指定的 Mode，然后进入 RunLoop，相关代码整理后如下所示：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">SInt32 <span class="title">CFRunLoopRunSpecific</span><span class="params">(CFRunLoopRef rl,</span></span></span><br><span class="line"><span class="params"><span class="function">                            CFStringRef modeName,</span></span></span><br><span class="line"><span class="params"><span class="function">                            CFTimeInterval seconds,</span></span></span><br><span class="line"><span class="params"><span class="function">                            Boolean returnAfterSourceHandled)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取对应 Mode。</span></span><br><span class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果当前 Mode 下没有任何事件，立即返回。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == currentMode ||</span><br><span class="line">        __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) &#123;</span><br><span class="line">        <span class="keyword">return</span> kCFRunLoopRunFinished;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把 Loop 当前的数据临时保存起来。</span></span><br><span class="line">    <span class="keyword">volatile</span> _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl);</span><br><span class="line">    CFRunLoopModeRef previousMode = rl-&gt;_currentMode;</span><br><span class="line">    rl-&gt;_currentMode = currentMode;</span><br><span class="line">    <span class="type">int32_t</span> result = kCFRunLoopRunFinished;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通知 Observer，即将进入 Loop。</span></span><br><span class="line">    <span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry) &#123;</span><br><span class="line">        __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进入 RunLoop。</span></span><br><span class="line">result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通知 Observer，即将退出 Loop。</span></span><br><span class="line">    <span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopExit) &#123;</span><br><span class="line">        __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复之前保存的临时数据。</span></span><br><span class="line">    __CFRunLoopPopPerRunData(rl, previousPerRun);</span><br><span class="line">    <span class="comment">// 把 Mode 恢复成之前的 Mode。</span></span><br><span class="line">    rl-&gt;_currentMode = previousMode;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RunLoop-核心"><a href="#RunLoop-核心" class="headerlink" title="RunLoop 核心"></a>RunLoop 核心</h3><p>在 <code>__CFRunLoopRun</code> 中，RunLoop 会进入 do while 循环，不断检查并处理事件，直到满足退出条件（超时、手动停止等）。核心的实现依赖于 <code>mach_msg</code> 函数，系统会调用这个函数将线程置于休眠状态，等待消息的到来，每当有事件（例如来自 <code>mach_port</code> 的消息或定时器触发）时，RunLoop 会被唤醒处理相关事件。相关代码整理后如下所示（函数有点长，不想看可以跳过，后面有解释）：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int32_t</span> __CFRunLoopRun(CFRunLoopRef rl,</span><br><span class="line">                              CFRunLoopModeRef rlm,</span><br><span class="line">                              CFTimeInterval seconds,</span><br><span class="line">                              Boolean stopAfterHandle,</span><br><span class="line">                              CFRunLoopModeRef previousMode) &#123;</span><br><span class="line">    <span class="type">uint64_t</span> startTSR = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line">    <span class="type">mach_port_name_t</span> dispatchPort = MACH_PORT_NULL;</span><br><span class="line">    </span><br><span class="line">    <span class="type">dispatch_source_t</span> timeout_timer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">__timeout_context</span> *timeout_context = (<span class="keyword">struct</span> __timeout_context *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(*timeout_context));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (seconds &lt;= <span class="number">0.0</span>) &#123;</span><br><span class="line">        timeout_context-&gt;termTSR = <span class="number">0ULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123;</span><br><span class="line">        <span class="comment">// ... 对 timeout_timer 和 timeout_context 的初始化及其它操作。</span></span><br><span class="line">        <span class="comment">// 感兴趣的同学可以自行阅读源码。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置 RunLoop 的目标超时时间，比如当前是第 10 秒，</span></span><br><span class="line">        <span class="comment">// 超时时间是 100 秒，那目标超时时间就是第 110 秒。</span></span><br><span class="line">        timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注册 RunLoop 超时回调。</span></span><br><span class="line">        <span class="built_in">dispatch_source_set_event_handler_f</span>(timeout_timer, __CFRunLoopTimeout);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        timeout_context-&gt;termTSR = UINT64_MAX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Boolean didDispatchPortLastTime = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int32_t</span> retVal = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进入 RunLoop</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">voucher_mach_msg_state_t</span> voucherState = VOUCHER_MACH_MSG_STATE_UNCHANGED;</span><br><span class="line">        <span class="type">voucher_t</span> voucherCopy = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">uint8_t</span> msg_buffer[<span class="number">3</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="type">mach_msg_header_t</span> *msg = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">mach_port_t</span> livePort = MACH_PORT_NULL;</span><br><span class="line">        __CFPortSet waitSet = rlm-&gt;_portSet;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知 Observer，即将处理 Timer。</span></span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) &#123;</span><br><span class="line">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知 Observer，即将处理 Source。</span></span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) &#123;</span><br><span class="line">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用户可能会在 observer 中添加 Block，</span></span><br><span class="line">        <span class="comment">// 这里需要处理它们。</span></span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行 Source0 事件。</span></span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 同理，用户可能在 Source 中添加 Block。</span></span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果有 Source1 事件，则处理它然后跳到 handle_msg 去处理消息。</span></span><br><span class="line">        <span class="keyword">if</span> (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;</span><br><span class="line">            msg = (<span class="type">mach_msg_header_t</span> *)msg_buffer;</span><br><span class="line">            <span class="keyword">if</span> (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, <span class="built_in">sizeof</span>(msg_buffer), &amp;livePort, <span class="number">0</span>, &amp;voucherState, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">                <span class="keyword">goto</span> handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        didDispatchPortLastTime = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知 Observer，即将进入休眠。</span></span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting) &#123;</span><br><span class="line">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        msg = (<span class="type">mach_msg_header_t</span> *)msg_buffer;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         线程进入休眠，并监听 mach port 消息。</span></span><br><span class="line"><span class="comment">         直到被下面的某个事件唤醒：</span></span><br><span class="line"><span class="comment">         1. 基于 port 的 Source 事件。</span></span><br><span class="line"><span class="comment">         2. Timer 事件。</span></span><br><span class="line"><span class="comment">         3. RunLoop 的超时时间到了。</span></span><br><span class="line"><span class="comment">         4. 被其它调用者手动唤醒。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="built_in">sizeof</span>(msg_buffer), &amp;livePort, TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知 Observer，从休眠中唤醒。</span></span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting) &#123;</span><br><span class="line">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理消息：</span></span><br><span class="line">        handle_msg:;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理通过 Timer 唤醒的事件。</span></span><br><span class="line">        <span class="keyword">if</span> (livePort == rlm-&gt;_timerPort) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!__CFRunLoopDoTimers(rl, rlm, <span class="built_in">mach_absolute_time</span>())) &#123;</span><br><span class="line">                <span class="comment">// Re-arm the next timer</span></span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理通过 GCD 唤醒的事件，例如 dispatch 到 main_queue 的 block。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (livePort == dispatchPort) &#123;</span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            sourceHandledThisLoop = <span class="literal">true</span>;</span><br><span class="line">            didDispatchPortLastTime = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理通过 Source1 唤醒的事件。</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</span><br><span class="line">            <span class="keyword">if</span> (rls) &#123;</span><br><span class="line">                <span class="type">mach_msg_header_t</span> *reply = <span class="literal">NULL</span>;</span><br><span class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">NULL</span> != reply) &#123;</span><br><span class="line">                    (<span class="type">void</span>)<span class="built_in">mach_msg</span>(reply, MACH_SEND_MSG, reply-&gt;msgh_size, <span class="number">0</span>, MACH_PORT_NULL, <span class="number">0</span>, MACH_PORT_NULL);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行添加到 Loop 中的 Block。</span></span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         进入 Loop 时设置了 stopAfterHandle 为 YES，</span></span><br><span class="line"><span class="comment">         意思是处理完事件就返回。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// RunLoop 运行超时了。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timeout_context-&gt;termTSR &lt; <span class="built_in">mach_absolute_time</span>()) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// RunLoop 被外部强行停止了。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunStopped;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前运行的 Mode 被停止了。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</span><br><span class="line">            rlm-&gt;_stopped = <span class="literal">false</span>;</span><br><span class="line">            retVal = kCFRunLoopRunStopped;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Mode 里没有要处理的事件了。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunFinished;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果参数没说运行完就结束、没超时、Loop 没被停止、Mode 没被停止、Mode 不为空；则继续。</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span> == retVal);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中不难发现，RunLoop 内部其实就是一个 <code>do while</code> 循环，当线程启动 RunLoop 后，就会一直处于这个循环里，有任务时就处理任务，每次处理完 Source1 任务后都会判断一下是否满足退出条件（超时、强行停止、任务列表为空等），如果不满足就进入下一轮。</p><p>RunLoop 的核心实现依赖于 <code>mach_msg()</code>，这个函数在 <code>__CFRunLoopServiceMachPort</code> 内部调用。RunLoop 调用 <code>mach_msg()</code> 之后，内核就会将线程置于休眠状态，直到有 port 发送消息或定时器触发。</p><p>你可以使用 Xcode 运行一个 iOS 项目，然后在 APP 静止时点击暂停，此时你会看到主线程调用栈停留在一个叫做 <code>mach_msg2_trap()</code> 的函数中。</p><p>我画了一个 RunLoop 运行流程图，请参考下图：</p><p><img src="runloop0.png" alt="RunLoop 运行流程图"></p><h2 id="RunLoop-与-RunLoopMode"><a href="#RunLoop-与-RunLoopMode" class="headerlink" title="RunLoop 与 RunLoopMode"></a>RunLoop 与 RunLoopMode</h2><p>一个 RunLoop 可能会包含多个 Mode，每个 Mode 又可能包含若干个 Source、Timer、Observer。相关代码整理后如下所示：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">__CFRunLoop</span> *CFRunLoopRef;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RunLoop 的底层结构。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__CFRunLoop</span> &#123;</span><br><span class="line">    CFMutableSetRef _commonModes;</span><br><span class="line">    CFMutableSetRef _commonModeItems;</span><br><span class="line">    CFRunLoopModeRef _currentMode;</span><br><span class="line">    CFMutableSetRef _modes;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">__CFRunLoopMode</span> *CFRunLoopModeRef;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RunLoopMode 的底层结构。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__CFRunLoopMode</span> &#123;</span><br><span class="line">    CFStringRef _name;<span class="comment">// Mode 的名称。</span></span><br><span class="line">    CFMutableSetRef _sources0;<span class="comment">// 包含所有 Source0，一个 Set。</span></span><br><span class="line">    CFMutableSetRef _sources1;<span class="comment">// 包含所有 Source1，一个 Set。</span></span><br><span class="line">    CFMutableArrayRef _observers;<span class="comment">// 包含所有 Observer，一个 Array。</span></span><br><span class="line">    CFMutableArrayRef _timers;<span class="comment">// 包含所有 Timer，一个 Array。</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>RunLoop 与 Mode 的关系如下图所示：</p><p><img src="runloop1.png" alt="RunLoop 与 Mode 的关系"></p><p>RunLoop 每次只能指定一个 Mode 运行，这个 Mode 被称为 currentMode。如果需要切换 Mode，只能退出 Loop，然后重新指定 Mode 运行。这样做的目的是为了将不同的 Source、Timer、Observer 分隔开，避免它们相互干扰。</p><p>Mode 内部有以下三种类型的事件：</p><p><strong>CFRunLoopSourceRef</strong> 表示所有 source0 和 source1 事件。</p><ul><li>source0 只包含一个函数指针回调，它不能主动触发事件，只能先调用 <code>CFRunLoopSourceSignal(source)</code> 将这个 Source 标记为待处理，然后调用 <code>CFRunLoopWakeUp(runloop)</code> 唤醒 RunLoop 去处理被标记的事件。</li><li>source1 是 mach port 发出的事件，被用于通过内核和其它进程相互发送消息，这种事件可以主动唤醒 RunLoop。</li></ul><p><strong>CFRunLoopTimerRef</strong> 是一个定时器事件，它和 NSTimer 是免费桥接的，当它被加入到 RunLoop 后，RunLoop 会在对应的时间点注册事件，当时间点到达时 Loop 会被唤醒并处理这个事件。</p><p><strong>CFRunLoopObserverRef</strong> 是一个观察者事件，当 RunLoop 的状态发生变化时，开发者可以通过注册 Observer 来响应这些变化，可以观察的状态有以下 6 个：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1UL</span> &lt;&lt; <span class="number">0</span>), <span class="comment">// 即将进入 Loop。</span></span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1UL</span> &lt;&lt; <span class="number">1</span>), <span class="comment">// 即将处理 Timer。</span></span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1UL</span> &lt;&lt; <span class="number">2</span>), <span class="comment">// 即将处理 Source。</span></span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">5</span>), <span class="comment">// 即将进入休眠。</span></span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">6</span>), <span class="comment">// 从休眠中唤醒。</span></span><br><span class="line">    kCFRunLoopExit = (<span class="number">1UL</span> &lt;&lt; <span class="number">7</span>), <span class="comment">// 即将退出 Loop。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上的 Source、Timer、Observer 统称为 mode item，一个 item 不能重复加入同一个 Mode，但是可以同时加入多个 mode 中，另外，如果 mode 里没有 item，则 RunLoop 会直接退出，不会进入到循环中。</p><h2 id="关于-CommonModes"><a href="#关于-CommonModes" class="headerlink" title="关于 CommonModes"></a>关于 CommonModes</h2><p>CommonModes 是一个特殊的概念，其允许一个事件同时在多个 Mode 中触发。通过 <code>CFRunLoopAddCommonMode</code> 函数，可以将某个 Mode 标记为 “Common” 模式，这样该模式下的事件就会自动同步到其它 Mode 中去。例如，我们可以在 <code>CFRunLoopAddCommonMode</code> 中添加一个定时器，这样它就能同时在多个模式下运行。</p><p>相关实现代码精简后如下所示（不想看可以跳过，后面有解释）：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CFRunLoopAddObserver</span><span class="params">(CFRunLoopRef rl, CFRunLoopObserverRef rlo, CFStringRef modeName)</span> </span>&#123;</span><br><span class="line">    CFRunLoopModeRef rlm;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (modeName == kCFRunLoopCommonModes) &#123;</span><br><span class="line">        CFSetRef set = rl-&gt;_commonModes ? <span class="built_in">CFSetCreateCopy</span>(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == rl-&gt;_commonModeItems) &#123;</span><br><span class="line">            rl-&gt;_commonModeItems = <span class="built_in">CFSetCreateMutable</span>(kCFAllocatorSystemDefault, <span class="number">0</span>, &amp;kCFTypeSetCallBacks);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">CFSetAddValue</span>(rl-&gt;_commonModeItems, rlo);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != set) &#123;</span><br><span class="line">            CFTypeRef context[<span class="number">2</span>] = &#123;rl, rlo&#125;;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             这里会遍历 rl-&gt;_commonModes 中的所有 Mode，</span></span><br><span class="line"><span class="comment">             然后执行 __CFRunLoopAddItemToCommonModes，</span></span><br><span class="line"><span class="comment">             把事件添加到每个具体的 Mode 中去。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">CFSetApplyFunction</span>(set, (__CFRunLoopAddItemToCommonModes), (<span class="type">void</span> *)context);</span><br><span class="line">            <span class="built_in">CFRelease</span>(set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 非 NSRunLoopCommonModes 的处理逻辑。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CFRunLoopAddCommonMode</span><span class="params">(CFRunLoopRef rl, CFStringRef modeName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">CFSetContainsValue</span>(rl-&gt;_commonModes, modeName)) &#123;</span><br><span class="line">        CFSetRef set = rl-&gt;_commonModeItems ? <span class="built_in">CFSetCreateCopy</span>(kCFAllocatorSystemDefault, rl-&gt;_commonModeItems) : <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">CFSetAddValue</span>(rl-&gt;_commonModes, modeName);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != set) &#123;</span><br><span class="line">            CFTypeRef context[<span class="number">2</span>] = &#123;rl, modeName&#125;;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             把 modeName 对应 Mode 中的所有事件，</span></span><br><span class="line"><span class="comment">             同步到 rl-&gt;_commonModeItems 的所有 Mode 中去。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">CFSetApplyFunction</span>(set, (__CFRunLoopAddItemsToCommonMode), (<span class="type">void</span> *)context);</span><br><span class="line">            <span class="built_in">CFRelease</span>(set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面提到的 CFRunLoopAddObserver 函数，还有两个函数和它类似：CFRunLoopAddTimer 和 CFRunLoopAddSource，它们的内部实现原理基本一致，所以我只介绍了 CFRunLoopAddObserver。</p><p>当你往 NSRunLoopCommonModes 中添加一个事件时，系统会拿到 _commonModes 并遍历其每个 Mode，然后为其添加这个事件。</p><p>当你调用 CFRunLoopAddCommonMode 将某个 Mode 标记为 “Common” 模式时，系统会取出这个 Mode 中的所有事件，然后遍历 _commonModes 并给每个 Mode 添加这些事件。</p><h2 id="RunLoop-与线程的关系"><a href="#RunLoop-与线程的关系" class="headerlink" title="RunLoop 与线程的关系"></a>RunLoop 与线程的关系</h2><p>每个线程都有自己独立的 RunLoop，iOS 不允许我们创建 RunLoop，但提供了两个函数来获取当前线程和主线程的 RunLoop：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取主线程中的 RunLoop。</span></span><br><span class="line"><span class="function">CFRunLoopRef <span class="title">CFRunLoopGetMain</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> CFRunLoopRef __main = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!__main) __main = _CFRunLoopGet0(<span class="built_in">pthread_main_thread_np</span>());</span><br><span class="line">    <span class="keyword">return</span> __main;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前线程的 RunLoop。</span></span><br><span class="line"><span class="function">CFRunLoopRef <span class="title">CFRunLoopGetCurrent</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从当前线程的局部存储中获取 RunLoop 对象。</span></span><br><span class="line">    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);</span><br><span class="line">    <span class="keyword">if</span> (rl) <span class="keyword">return</span> rl;</span><br><span class="line">    <span class="keyword">return</span> _CFRunLoopGet0(<span class="built_in">pthread_self</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局 Dict，key 是线程，value 是 RunLoop。</span></span><br><span class="line"><span class="type">static</span> CFMutableDictionaryRef __CFRunLoops = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(<span class="type">pthread_t</span> t) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     第 1 次获取 RunLoop 对象时，</span></span><br><span class="line"><span class="comment">     自动创建全局 Dict 和主线程的 RunLoop。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!__CFRunLoops) &#123;</span><br><span class="line">        CFMutableDictionaryRef dict = <span class="built_in">CFDictionaryCreateMutable</span>(kCFAllocatorSystemDefault, <span class="number">0</span>,</span><br><span class="line">                                      <span class="literal">NULL</span>, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">        CFRunLoopRef mainLoop = __CFRunLoopCreate(<span class="built_in">pthread_main_thread_np</span>());</span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(dict, <span class="built_in">pthreadPointer</span>(<span class="built_in">pthread_main_thread_np</span>()), mainLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    CFRunLoopRef loop = (CFRunLoopRef)<span class="built_in">CFDictionaryGetValue</span>(__CFRunLoops, <span class="built_in">pthreadPointer</span>(t));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">        <span class="comment">// 如果当前线程还没有 RunLoop，创建一个新的。</span></span><br><span class="line">        CFRunLoopRef newLoop = __CFRunLoopCreate(t);</span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(__CFRunLoops, <span class="built_in">pthreadPointer</span>(t), newLoop);</span><br><span class="line">        loop = newLoop;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_equal</span>(t, <span class="built_in">pthread_self</span>())) &#123;</span><br><span class="line">        _CFSetTSD(__CFTSDKeyRunLoop, (<span class="type">void</span> *)loop, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</span><br><span class="line">            <span class="comment">// 注册一个回调，当线程销毁时，顺便销毁其对应的 RunLoop。</span></span><br><span class="line">            _CFSetTSD(__CFTSDKeyRunLoopCntr, </span><br><span class="line">            (<span class="type">void</span> *)(PTHREAD_DESTRUCTOR_ITERATIONS<span class="number">-1</span>), </span><br><span class="line">            (<span class="built_in">void</span> (*)(<span class="type">void</span> *))__CFFinalizeRunLoop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中不难发现，线程和 RunLoop 的关系是一一对应的，其关系保存在一个全局字典中。另外，iOS 会为每个线程懒加载 RunLoop 对象，并在线程销毁时自动释放它。</p><p>我们只能获取当前线程的 RunLoop 对象（主线程的 RunLoop 除外）。</p><h2 id="苹果利用-RunLoop-实现的功能"><a href="#苹果利用-RunLoop-实现的功能" class="headerlink" title="苹果利用 RunLoop 实现的功能"></a>苹果利用 RunLoop 实现的功能</h2><h3 id="AutoreleasePool-与-RunLoop"><a href="#AutoreleasePool-与-RunLoop" class="headerlink" title="AutoreleasePool 与 RunLoop"></a>AutoreleasePool 与 RunLoop</h3><p>网络上有一些这方面相关的旧文章，他们会告诉你：iOS 在 APP 启动后会往主线程的 RunLoop 里注册多个 Observer，用来监听以下三种状态：</p><p>即将进入 RunLoop：创建 AutoreleasePool。</p><p>RunLoop 准备休眠：释放之前创建的 AutoreleasePool，然后创建一个新的 AutoreleasePool。</p><p>RunLoop 即将退出：释放之前创建的 AutoreleasePool。</p><p>但是，根据我的调试发现，新的 RunLoop 已经不是上述逻辑了。系统会在每个任务的执行前后自动插入相关代码来实现 AutoreleasePool 的创建和释放操作，而不是等到线程休眠前才释放。</p><!-- 关于 AutoreleasePool 的更多实现细节，请阅读我写的另一篇文章：\]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RunLoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>揭开 iOS 中 weak 指针的神秘面纱：从原理到实践</title>
      <link href="/2023/10/21/iOS/%E6%8F%AD%E5%BC%80%20iOS%20%E4%B8%AD%20weak%20%E6%8C%87%E9%92%88%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1%EF%BC%9A%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5/"/>
      <url>/2023/10/21/iOS/%E6%8F%AD%E5%BC%80%20iOS%20%E4%B8%AD%20weak%20%E6%8C%87%E9%92%88%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1%EF%BC%9A%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由 布多(budo) 发布于 2023-10-21 • 最后更新于 2025-02-26</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>weak 指针是 iOS 开发中一个非常基础的概念，在开发过程中我们经常使用它，它到底是怎么实现的？这篇文章将从 Runtime 源码入手，为你介绍 weak 指针的实现原理；让你知其然，更知其所以然。</p><h2 id="weak-指针之编译期实现"><a href="#weak-指针之编译期实现" class="headerlink" title="weak 指针之编译期实现"></a>weak 指针之编译期实现</h2><p>当我们初始化一个 weak 指针时： <code>__weak typeof(obj) weakObj = obj;</code>，编译器其实会把它们转换成类似这样的代码：<code>objc_initWeak((void *)&amp;weakObj, obj);</code></p><p><img src="entrance.png" alt="weak 指针的初始化入口"></p><p>从上图的断点中我们也可以发现，weak 指针调用了 <code>objc_initWeak</code> 函数来完成初始化。在 Runtime 源码中我们可以找到 <code>objc_initWeak</code> 相关的实现细节。</p><blockquote><p>本文使用的 Runtime 版本是 <a href="https://github.com/apple-oss-distributions/objc4/tree/objc4-906">objc4-906</a>，为了方便阅读，我对代码样式和排版略作了修改以及删减了一些不影响主逻辑的冗余代码。</p><p>我在 <a href="https://github.com/internetWei/ObjCRuntimes">这里</a> 维护了一个可以直接运行调试的 Runtime 项目，方便大家直接调试源码。</p></blockquote><h2 id="weak-指针之运行时实现"><a href="#weak-指针之运行时实现" class="headerlink" title="weak 指针之运行时实现"></a>weak 指针之运行时实现</h2><p>与 weak 指针初始化相关的函数有以下 4 个：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化一个全新的 weak 指针。</span></span><br><span class="line"><span class="function">id <span class="title">objc_initWeak</span><span class="params">(id *location, id newObj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!newObj) &#123;</span><br><span class="line">        *location = nil;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">storeWeak</span>&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;(location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和前面的 objc_initWeak 一样，</span></span><br><span class="line"><span class="comment">// 但是，如果指向的对象（即 newObj）正在释放的话不要报错而是返回 nil。</span></span><br><span class="line"><span class="function">id <span class="title">objc_initWeakOrNil</span><span class="params">(id *location, id newObj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!newObj) &#123;</span><br><span class="line">        *location = nil;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">storeWeak</span>&lt;DontHaveOld, DoHaveNew, DontCrashIfDeallocating&gt;(location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放 weak 指针当前指向的对象，并将它指向新对象（即 newObj）。</span></span><br><span class="line"><span class="function">id <span class="title">objc_storeWeak</span><span class="params">(id *location, id newObj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">storeWeak</span>&lt;DoHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;(location, (objc_object *)newObj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和 objc_storeWeak 一样。</span></span><br><span class="line"><span class="comment">// 但是，如果指向的对象（即 newObj）正在释放的话不要报错而是返回 nil。</span></span><br><span class="line"><span class="function">id <span class="title">objc_initWeakOrNil</span><span class="params">(id *location, id newObj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!newObj) &#123;</span><br><span class="line">        *location = nil;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">storeWeak</span>&lt;DontHaveOld, DoHaveNew, DontCrashIfDeallocating&gt;(location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于函数 objc_initWeak 和 objc_storeWeak 的区别：</p><ul><li><p><code>objc_initWeak</code>：用来初始化一个全新的 weak 指针。例如以下场景：</p>  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *obj = ...;</span><br><span class="line">__<span class="keyword">weak</span> <span class="type">id</span> weakPtr = obj;<span class="comment">// 在初始化的时候就指向了对象。</span></span><br></pre></td></tr></table></figure></li><li><p><code>objc_storeWeak</code>：当 weak 指针被赋值的时候调用。例如以下场景：</p>  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *obj = ...;</span><br><span class="line">__<span class="keyword">weak</span> <span class="type">id</span> weakPtr;</span><br><span class="line">weakPtr = obj;<span class="comment">// 先初始化，后赋值。</span></span><br></pre></td></tr></table></figure></li></ul><p>从以上 4 个初始化函数不难发现，它们最终都调用了同一个函数 <code>storeWeak</code>，区别就是传递给函数的模板参数略有不同。</p><h3 id="weak-指针的初始化细节：storeWeak"><a href="#weak-指针的初始化细节：storeWeak" class="headerlink" title="weak 指针的初始化细节：storeWeak"></a>weak 指针的初始化细节：storeWeak</h3><p><code>storeWeak</code> 函数的相关代码整理后如下所示：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">HaveOld</span> &#123; DontHaveOld = <span class="literal">false</span>, DoHaveOld = <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">HaveNew</span> &#123; DontHaveNew = <span class="literal">false</span>, DoHaveNew = <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CrashIfDeallocating</span> &#123;</span><br><span class="line">    DontCrashIfDeallocating = <span class="literal">false</span>, DoCrashIfDeallocating = <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">location: weak 指针的内存地址，即 `__weak id weakPtr;` 中的 &amp;weakPtr。</span></span><br><span class="line"><span class="comment">newObj: weak 指针要指向的对象，即 `__weak id weakPtr = obj;` 中的 obj。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;HaveOld haveOld, HaveNew haveNew, </span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CrashIfDeallocating</span> crashIfDeallocating&gt;</span><br><span class="line"><span class="function"><span class="type">static</span> id <span class="title">storeWeak</span><span class="params">(id *location, objc_object *newObj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当 newObj 的类型还未初始化的时候会用到。</span></span><br><span class="line">    Class previouslyInitializedClass = nil;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存 weak 指针当前指向的对象。</span></span><br><span class="line">    id oldObj;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// SideTable 是用来存储弱引用关联的 1 个数据结构，后面会单独讲。</span></span><br><span class="line">    SideTable *oldTable;</span><br><span class="line">    SideTable *newTable;</span><br><span class="line"></span><br><span class="line"> retry:</span><br><span class="line">    <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">        oldObj = *location;</span><br><span class="line">        <span class="comment">// 调用全局函数 SideTables 获取 oldObj 对应的 SideTable 对象。</span></span><br><span class="line">        oldTable = &amp;<span class="built_in">SideTables</span>()[oldObj];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        oldTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        newTable = &amp;<span class="built_in">SideTables</span>()[newObj];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该函数不是线程安全的，所以执行到这里的时候，</span></span><br><span class="line">    <span class="comment">// weak 指针的值有可能被其它线程修改了，</span></span><br><span class="line">    <span class="comment">// 如果是的话就跳转到 retry 重新获取数据。</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld &amp;&amp; *location != oldObj) &#123;</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (haveNew &amp;&amp; newObj) &#123;</span><br><span class="line">        Class cls = newObj-&gt;<span class="built_in">getIsa</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        检查 newObj 的类型是否已经完成初始化。</span></span><br><span class="line"><span class="comment">        一般都不会发生这种情况，除非你在 +initialize 中对该对象进行弱引用，</span></span><br><span class="line"><span class="comment">        例如以下场景：</span></span><br><span class="line"><span class="comment">        @implementation Person</span></span><br><span class="line"><span class="comment">        + (void)initialize &#123;</span></span><br><span class="line"><span class="comment">           Person *obj = [[self alloc] init];</span></span><br><span class="line"><span class="comment">           // 此时 Person 类还未完成初始化操作。</span></span><br><span class="line"><span class="comment">           __weak typeof(obj) weakObj = obj;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        @end</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (cls != previouslyInitializedClass &amp;&amp;  </span><br><span class="line">            !cls-&gt;<span class="built_in">isInitialized</span>()) &#123;  </span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 对 newObj 类型进行初始化操作，然后跳转 retry 重新获取数据。</span></span><br><span class="line">            <span class="built_in">class_initialize</span>(cls, newObj);</span><br><span class="line">            previouslyInitializedClass = cls;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">        <span class="comment">// 如果 weak 指针当前持有了一个对象，先解除与这个对象的弱引用关联。</span></span><br><span class="line">        <span class="built_in">weak_unregister_no_lock</span>(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        <span class="comment">// 将 weak 指针与新对象建立弱引用关联。</span></span><br><span class="line">        newObj = <span class="built_in">weak_register_no_lock</span>(&amp;newTable-&gt;weak_table,</span><br><span class="line">        (id)newObj,</span><br><span class="line">        location,</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        之前在初始化函数那里提到过带 OrNil 后缀和不带后缀的区别，</span></span><br><span class="line"><span class="comment">        重点就在这里，带后缀的函数这里会传递 ReturnNilIfDeallocating，</span></span><br><span class="line"><span class="comment">        不带后缀的会传递 CrashIfDeallocating。</span></span><br><span class="line"><span class="comment">        函数内部会检查 newObj 是否正在释放过程中，</span></span><br><span class="line"><span class="comment">        如果是的话就会使用这个参数来决定怎么处理。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        crashIfDeallocating ? CrashIfDeallocating : ReturnNilIfDeallocating);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修改 newObj 对象的 isa 中关于是否有弱引用的标记。</span></span><br><span class="line">        <span class="keyword">if</span> (!_objc_isTaggedPointerOrNil(newObj)) &#123;</span><br><span class="line">            newObj-&gt;<span class="built_in">setWeaklyReferenced_nolock</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 weak 指针指向 newObj。</span></span><br><span class="line">        *location = (id)newObj;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    这个函数我翻了往年的 runtime 源码，发现是从 objc4-818.2 开始引入的。</span></span><br><span class="line"><span class="comment">    它的内部逻辑大致如下：</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    1. 检查对象是否实现了手动引用计数。</span></span><br><span class="line"><span class="comment">    2. 如果支持的话，再判断对象是否有实例方法 _setWeaklyReferenced 的实现，如果有的话就调用。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">callSetWeaklyReferenced</span>((id)newObj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (id)newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数就是 weak 指针初始化的最终函数。从函数中不难发现，它主要就干了 2 件事：</p><ol><li>调用 <code>weak_unregister_no_lock</code>：将 weak 指针与当前对象解除弱引用关联。</li><li>调用 <code>weak_register_no_lock</code>：将 weak 指针与新对象建立弱引用关联。</li></ol><h3 id="weak-指针解除关联的细节：weak-unregister-no-lock"><a href="#weak-指针解除关联的细节：weak-unregister-no-lock" class="headerlink" title="weak 指针解除关联的细节：weak_unregister_no_lock"></a>weak 指针解除关联的细节：weak_unregister_no_lock</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">weak_unregister_no_lock</span><span class="params">(<span class="type">weak_table_t</span> *weak_table,</span></span></span><br><span class="line"><span class="params"><span class="function">                        id referent_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                        id *referrer_id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// weak 指针当前指向的对象，即 `__weak id weakPtr = obj;` 中的 obj。</span></span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    <span class="comment">// weak 指针的内存地址，即 `__weak id weakPtr;` 中的 &amp;weakPtr。</span></span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// referent 对象的弱引用表。</span></span><br><span class="line">    <span class="type">weak_entry_t</span> *entry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!referent) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 weak_table 中取出 referent 对应的弱引用表。</span></span><br><span class="line">    <span class="keyword">if</span> ((entry = <span class="built_in">weak_entry_for_referent</span>(weak_table, referent))) &#123;</span><br><span class="line">        <span class="comment">// 从弱引用表中移除 weak 指针的地址，即移除 referrer。</span></span><br><span class="line">        <span class="built_in">remove_referrer</span>(entry, referrer);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 移除后检查一下表是否为空，</span></span><br><span class="line">        <span class="comment">// 如果是的话就删除这个表。</span></span><br><span class="line">        <span class="type">bool</span> empty = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;<span class="built_in">out_of_line</span>() &amp;&amp;</span><br><span class="line">            entry-&gt;num_refs != <span class="number">0</span>) &#123;</span><br><span class="line">            empty = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry-&gt;inline_referrers[i]) &#123;</span><br><span class="line">                    empty = <span class="literal">false</span>; </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">            <span class="built_in">weak_entry_remove</span>(weak_table, entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从弱引用表中获取某个对象对应的那张表数据。</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">weak_entry_t</span> *</span></span><br><span class="line"><span class="function"><span class="title">weak_entry_for_referent</span><span class="params">(<span class="type">weak_table_t</span> *weak_table, objc_object *referent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下面的逻辑是一段典型的哈希表实现细节，关于哈希表的实现原理请自行了解。</span></span><br><span class="line">    <span class="type">weak_entry_t</span> *weak_entries = weak_table-&gt;weak_entries;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!weak_entries) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> begin = <span class="built_in">hash_pointer</span>(referent) &amp; weak_table-&gt;mask;</span><br><span class="line">    <span class="type">size_t</span> index = begin;</span><br><span class="line">    <span class="type">size_t</span> hash_displacement = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (weak_table-&gt;weak_entries[index].referent != referent) &#123;</span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; weak_table-&gt;mask;</span><br><span class="line">        <span class="keyword">if</span> (index == begin) <span class="built_in">bad_weak_table</span>(weak_table-&gt;weak_entries);</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        <span class="keyword">if</span> (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123;</span><br><span class="line">            <span class="keyword">return</span> nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &amp;weak_table-&gt;weak_entries[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从弱引用表中移除指定的 weak 指针。</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">remove_referrer</span><span class="params">(<span class="type">weak_entry_t</span> *entry, objc_object **old_referrer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 系统在存储弱指针数据的时候会采用 2 套方案。</span></span><br><span class="line">    <span class="comment">// 如果数据量比较小就会使用静态数组存放。</span></span><br><span class="line">    <span class="comment">// 这里的逻辑就是判断，如果是静态数组方案就执行这段逻辑。</span></span><br><span class="line">    <span class="keyword">if</span> (!entry-&gt;<span class="built_in">out_of_line</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;inline_referrers[i] == old_referrer) &#123;</span><br><span class="line">                entry-&gt;inline_referrers[i] = nil;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是动态数组存储的话，就执行这段逻辑。</span></span><br><span class="line">    <span class="type">size_t</span> begin = <span class="built_in">w_hash_pointer</span>(old_referrer) &amp; (entry-&gt;mask);</span><br><span class="line">    <span class="type">size_t</span> index = begin;</span><br><span class="line">    <span class="type">size_t</span> hash_displacement = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (entry-&gt;referrers[index] != old_referrer) &#123;</span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; entry-&gt;mask;</span><br><span class="line">        <span class="keyword">if</span> (index == begin) <span class="built_in">bad_weak_table</span>(entry);</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        <span class="keyword">if</span> (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123;</span><br><span class="line">            <span class="comment">// 弱引用表中没有这个弱指针数据，不需要移除。</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    entry-&gt;referrers[index] = nil;</span><br><span class="line">    entry-&gt;num_refs--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从弱引用表中移除某张表。</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">weak_entry_remove</span><span class="params">(<span class="type">weak_table_t</span> *weak_table, <span class="type">weak_entry_t</span> *entry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果是动态数组方案的话，释放创建的动态数组。</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;<span class="built_in">out_of_line</span>()) <span class="built_in">free</span>(entry-&gt;referrers);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(entry, <span class="number">0</span>, <span class="built_in">sizeof</span>(*entry));</span><br><span class="line"></span><br><span class="line">    weak_table-&gt;num_entries--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要的话，对弱引用表进行缩容。</span></span><br><span class="line">    <span class="built_in">weak_compact_maybe</span>(weak_table);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码稍微有点多，但整体的逻辑比较清晰。<code>weak_unregister_no_lock</code> 函数中主要做了 3 件事：</p><ol><li>调用 <code>weak_entry_for_referent</code> 从弱引用表中获取指定的那张表数据。</li><li>调用 <code>remove_referrer</code> 从表中移除弱指针（即 referrer）。</li><li>检查表是否为空，是的话就调用 <code>weak_entry_remove</code> 从 weak_table 中移除这张表。</li></ol><p>移除弱引用关联，本质上就是从 weak_table 中找到对象对应的弱引用数组，然后从数组中找到需要移除的 weak 指针并将其置空。weak_table 其实就是一个哈希表，关于哈希表的实现原理请自行了解。</p><h3 id="weak-指针建立关联的细节：weak-register-no-lock"><a href="#weak-指针建立关联的细节：weak-register-no-lock" class="headerlink" title="weak 指针建立关联的细节：weak_register_no_lock"></a>weak 指针建立关联的细节：weak_register_no_lock</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">id </span></span><br><span class="line"><span class="function"><span class="title">weak_register_no_lock</span><span class="params">(<span class="type">weak_table_t</span> *weak_table,</span></span></span><br><span class="line"><span class="params"><span class="function">                      id referent_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                      id *referrer_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                      WeakRegisterDeallocatingOptions deallocatingOptions)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// weak 指针当前指向的对象，即 `__weak id weakPtr = obj;` 中的 obj。</span></span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    <span class="comment">// weak 指针的内存地址，即 `__weak id weakPtr;` 中的 &amp;weakPtr。</span></span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里是确保 weak 指针要指向的那个对象是有效的（即没有正在释放）。</span></span><br><span class="line">    <span class="keyword">if</span> (deallocatingOptions == ReturnNilIfDeallocating ||</span><br><span class="line">        deallocatingOptions == CrashIfDeallocating) &#123;</span><br><span class="line">        <span class="type">bool</span> deallocating;</span><br><span class="line">        <span class="keyword">if</span> (!referent-&gt;<span class="built_in">ISA</span>()-&gt;<span class="built_in">hasCustomRR</span>()) &#123;</span><br><span class="line">            deallocating = referent-&gt;<span class="built_in">rootIsDeallocating</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> allowsWeakReference = (<span class="built_in">BOOL</span>(*)(objc_object *, SEL))</span><br><span class="line">            <span class="built_in">lookUpImpOrForwardTryCache</span>((id)referent, @<span class="built_in">selector</span>(allowsWeakReference),</span><br><span class="line">                                       referent-&gt;<span class="built_in">getIsa</span>());</span><br><span class="line">            <span class="keyword">if</span> ((IMP)allowsWeakReference == _objc_msgForward) &#123;</span><br><span class="line">                <span class="keyword">return</span> nil;</span><br><span class="line">            &#125;</span><br><span class="line">            deallocating =</span><br><span class="line">            ! (*allowsWeakReference)(referent, @<span class="built_in">selector</span>(allowsWeakReference));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果正在释放的话，根据参数 deallocatingOptions 来决定执行什么操作。</span></span><br><span class="line">        <span class="keyword">if</span> (deallocating) &#123;</span><br><span class="line">            <span class="keyword">if</span> (deallocatingOptions == CrashIfDeallocating) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">&quot;Cannot form weak reference to instance (%p) of &quot;</span></span><br><span class="line">                            <span class="string">&quot;class %s. It is possible that this object was &quot;</span></span><br><span class="line">                            <span class="string">&quot;over-released, or is in the process of deallocation.&quot;</span>,</span><br><span class="line">                            (<span class="type">void</span>*)referent, <span class="built_in">object_getClassName</span>((id)referent));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nil;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">weak_entry_t</span> *entry;</span><br><span class="line">    <span class="comment">// weak_entry_for_referent 函数在前面的 weak_unregister_no_lock 中已解释过。</span></span><br><span class="line">    <span class="keyword">if</span> ((entry = <span class="built_in">weak_entry_for_referent</span>(weak_table, referent))) &#123;</span><br><span class="line">        <span class="built_in">append_referrer</span>(entry, referrer);</span><br><span class="line">    &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 找不到对应的表，创建一个新表。</span></span><br><span class="line">        <span class="type">weak_entry_t</span> <span class="built_in">new_entry</span>(referent, referrer);</span><br><span class="line">        <span class="comment">// 如果需要的话，对 weak_table 进行扩容。</span></span><br><span class="line">        <span class="built_in">weak_grow_maybe</span>(weak_table);</span><br><span class="line">        <span class="comment">// 将新表插入到 weak_table 中。</span></span><br><span class="line">        <span class="built_in">weak_entry_insert</span>(weak_table, &amp;new_entry);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> referent_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向弱引用表中添加一个 weak 指针。</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">append_referrer</span><span class="params">(<span class="type">weak_entry_t</span> *entry, objc_object **new_referrer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前采用的是静态数组方案就执行这段逻辑。</span></span><br><span class="line">    <span class="keyword">if</span> (!entry-&gt;<span class="built_in">out_of_line</span>()) &#123;</span><br><span class="line">        <span class="comment">// 尝试在静态数组中插入数据。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;inline_referrers[i] == nil) &#123;</span><br><span class="line">                entry-&gt;inline_referrers[i] = new_referrer;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 来到这里说明静态数组已经存满了，后面的逻辑是把静态数组转为动态数组存储。</span></span><br><span class="line">        <span class="type">weak_referrer_t</span> *new_referrers = (<span class="type">weak_referrer_t</span> *)</span><br><span class="line">            <span class="built_in">calloc</span>(<span class="number">4</span>, <span class="built_in">sizeof</span>(<span class="type">weak_referrer_t</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            new_referrers[i] = entry-&gt;inline_referrers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        entry-&gt;referrers = new_referrers;</span><br><span class="line">        entry-&gt;num_refs = <span class="number">4</span>;</span><br><span class="line">        entry-&gt;out_of_line_ness = <span class="number">2</span>;</span><br><span class="line">        entry-&gt;mask = <span class="number">4</span> - <span class="number">1</span>;</span><br><span class="line">        entry-&gt;max_hash_displacement = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果数组的元素数量大于等于总容量的 3/4，则对数组进行扩容并插入新数据。</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;num_refs &gt;= (entry-&gt;mask + <span class="number">1</span>) * <span class="number">3</span>/<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">grow_refs_and_insert</span>(entry, new_referrer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">size_t</span> begin = <span class="built_in">w_hash_pointer</span>(new_referrer) &amp; (entry-&gt;mask);</span><br><span class="line">    <span class="type">size_t</span> index = begin;</span><br><span class="line">    <span class="type">size_t</span> hash_displacement = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (entry-&gt;referrers[index] != nil) &#123;</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; entry-&gt;mask;</span><br><span class="line">        <span class="keyword">if</span> (index == begin) <span class="built_in">bad_weak_table</span>(entry);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// hash_displacement 保存的是此次遇到的哈希冲突次数，</span></span><br><span class="line">    <span class="comment">// 之所以要保存这个值，是因为取值的时候也会遇到哈希冲突，</span></span><br><span class="line">    <span class="comment">// 此时需要和这个值进行比较，如果大于这个值的话就说明哈希表中没有要找的数据。</span></span><br><span class="line">    <span class="keyword">if</span> (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123;</span><br><span class="line">        entry-&gt;max_hash_displacement = hash_displacement;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">weak_referrer_t</span> &amp;ref = entry-&gt;referrers[index];</span><br><span class="line">    ref = new_referrer;</span><br><span class="line">    entry-&gt;num_refs++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立关联和解除关联的逻辑相似，本质都是通过 <code>weak_entry_for_referent</code> 获取对应的表。然后在通过 weak 指针进行一系列哈希运算，从而拿到要添加&#x2F;要删除的数组索引，最终对数组元素进行添加&#x2F;删除操作。</p><p>截止到这里，关于 weak 指针的整个初始化过程已经全部讲完了。如果你还想了解更多细节的话可以继续阅读后面的内容。</p><h2 id="深入剖析-SideTable-类型"><a href="#深入剖析-SideTable-类型" class="headerlink" title="深入剖析 SideTable 类型"></a>深入剖析 SideTable 类型</h2><p>SideTable 是用来存储弱引用数据和引用计数的一个数据结构，由于这篇文章只涉及弱引用相关问题，所以在后面的源码中我会特意去掉与文章不相关的内容，如果你想了解全部细节的话请阅读源码。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SideTable</span> &#123;</span><br><span class="line"> <span class="comment">// 你可以把它理解成一个哈希表，</span></span><br><span class="line">    <span class="comment">// key 是对象；value 是对象对应的弱引用表数据。</span></span><br><span class="line">    <span class="type">weak_table_t</span> weak_table;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">weak_table_t</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这是一个数组，数组中的每个元素是一个 weak_entry_t 对象。</span></span><br><span class="line"><span class="comment">    weak_entry_t 里存储了弱引用的相关数据。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">weak_entry_t</span> *weak_entries;</span><br><span class="line">    <span class="comment">// 数组 weak_entries 的元素数量。</span></span><br><span class="line">    <span class="type">size_t</span>    num_entries;</span><br><span class="line">    <span class="comment">// 数组 weak_entries 的长度减一，求数组索引时需要用到。</span></span><br><span class="line">    <span class="type">uintptr_t</span> mask;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    记录在存储元素时遇到的最大的哈希冲突次数。</span></span><br><span class="line"><span class="comment">    在查找元素的时候会被用到，</span></span><br><span class="line"><span class="comment">    如果查找过程中哈希冲突次数大于这个值就说明哈希表中没有要找的数据。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uintptr_t</span> max_hash_displacement;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正用来存储弱引用数据的结构。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">weak_entry_t</span> &#123;</span><br><span class="line">    <span class="comment">// weak 指针所指向的那个对象（类似哈希表中的 key）。</span></span><br><span class="line">    id referent;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    从以下代码可以发现：系统内部在存储弱引用数据的时候有 2 套方案，</span></span><br><span class="line"><span class="comment">    如果数据比较少就使用静态数组 inline_referrers 存储；</span></span><br><span class="line"><span class="comment">    如果数据比较多就使用动态数组 referrers 存储。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="comment">// 用来存储弱引用的动态数组。</span></span><br><span class="line">            id *referrers;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            一个标记位，如果这个值是 2 的话就表示使用的是动态数组。</span></span><br><span class="line"><span class="comment">            因为 objc 对象的内存地址的最后一位只会是 0x8 或 0x0，</span></span><br><span class="line"><span class="comment">            即：如果采用的是静态数组方案的话，这个位置的数据绝对是 0。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="type">uintptr_t</span>        out_of_line_ness : <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 数组 referrers 的元素数量。</span></span><br><span class="line">            <span class="type">uintptr_t</span>        num_refs : <span class="number">62</span>;</span><br><span class="line">            <span class="comment">// 数组 referrers 的长度减一，和 weak_table_t 中的 mask 功能一样。</span></span><br><span class="line">            <span class="type">uintptr_t</span>        mask;</span><br><span class="line">            <span class="comment">// 和 weak_table_t 中的 max_hash_displacement 功能一样。</span></span><br><span class="line">            <span class="type">uintptr_t</span>        max_hash_displacement;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="comment">// 用来存储弱引用的静态数组。</span></span><br><span class="line">            id inline_referrers[<span class="number">4</span>];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>你可以把 SideTable 理解成一个获取弱引用表的入口，weak_table 类似一个大哈希表，这个哈希表的 key 是 objc 对象，value 是对应的弱引用数组。关于 weak 指针的操作，例如解除关联和建立关联，其实就是从 weak_table 中获取其对应的弱引用数组，然后从这个数组中移除或添加对应的弱指针地址。</p><h2 id="weak-指针自动赋值-nil-的实现细节：weak-clear-no-lock"><a href="#weak-指针自动赋值-nil-的实现细节：weak-clear-no-lock" class="headerlink" title="weak 指针自动赋值 nil 的实现细节：weak_clear_no_lock"></a>weak 指针自动赋值 nil 的实现细节：weak_clear_no_lock</h2><p>众所周知，weak 指针在对象被释放之后会自动指向 nil，那么它到底是如何实现的呢？</p><p>关于释放流程的函数调用顺序这里就不具体展开了，在 <a href="https://github.com/apple-oss-distributions/objc4/tree/objc4-906">objc4-906</a> 版本中，其函数调用顺序如下：dealloc &#x3D;&gt; _objc_rootDealloc &#x3D;&gt; rootDealloc &#x3D;&gt; object_dispose &#x3D;&gt; objc_destructInstance &#x3D;&gt; clearDeallocating &#x3D;&gt; clearDeallocating_slow &#x3D;&gt; weak_clear_no_lock，我们重点看一下最后一个函数 <code>weak_clear_no_lock</code> 的实现细节。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">weak_clear_no_lock</span><span class="params">(<span class="type">weak_table_t</span> *weak_table, id referent_id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 正在释放的对象。</span></span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前对象对应的弱引用表。</span></span><br><span class="line">    <span class="type">weak_entry_t</span> *entry = <span class="built_in">weak_entry_for_referent</span>(weak_table, referent);</span><br><span class="line">    <span class="keyword">if</span> (entry == nil) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">weak_referrer_t</span> *referrers;</span><br><span class="line">    <span class="type">size_t</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取弱指针数组和数组容量。</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;<span class="built_in">out_of_line</span>()) &#123;</span><br><span class="line">        referrers = entry-&gt;referrers;</span><br><span class="line">        count = (entry-&gt;mask ? entry-&gt;mask + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        referrers = entry-&gt;inline_referrers;</span><br><span class="line">        count = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重点：系统会遍历弱指针数组中的每个地址，并将它们赋值为 nil。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        objc_object **referrer = referrers[i];</span><br><span class="line">        <span class="keyword">if</span> (referrer) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*referrer == referent) &#123;<span class="comment">// 等价于 weakSelf == self(self 表示当前正在释放的对象)</span></span><br><span class="line">                *referrer = nil;<span class="comment">// 等价于 weakSelf = nil;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*referrer) &#123;</span><br><span class="line">                <span class="built_in">REPORT_WEAK_ERROR</span>(<span class="string">&quot;__weak variable at %p holds %p instead of %p. &quot;</span></span><br><span class="line">                                  <span class="string">&quot;This is probably incorrect use of &quot;</span></span><br><span class="line">                                  <span class="string">&quot;objc_storeWeak() and objc_loadWeak().&quot;</span>,</span><br><span class="line">                                  referrer, (<span class="type">void</span>*)*referrer, (<span class="type">void</span>*)referent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从弱引用表中移除这张表。</span></span><br><span class="line">    <span class="built_in">weak_entry_remove</span>(weak_table, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中不难发现，系统会在对象释放的时候，获取其对应的弱引用表，然后遍历这个表中的 weak 指针并将其赋值为 nil。</p><p>到此为止，关于 weak 指针的所有内容就讲完了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 runtime 初始化的时候，会调用一个全局函数 <code>side_tables_init</code> 初始化一个全局数组，数组的元素是 SideTable 对象，可以通过全局函数 <code>SideTables</code> 拿到这个数组以及对象对应的 SideTable 对象。</p><p>SideTable 中有一个变量 weak_table，你可以将它理解成一个哈希表，哈希表的 key 是对象，value 是一个数组，数组中的元素就是指向这个 key 的 weak 指针地址。</p><p>weak 指针的初始化操作就是拿到这个对象对应的弱指针数组，然后往数组里面把 weak 指针的内存地址添加进去。</p><p>如果 weak 指针需要指向别的对象，需要拿到旧对象对应的弱指针数组并将数组中存放 weak 指针的那个位置置空，然后拿到新对象对应的弱指针数组并将 weak 指针添加进去。</p><p>如果对象释放了，就拿到这个对象对应的弱指针数组并挨个将里面的 weak 指针赋值为 nil。</p><p>为了加深自己的理解，我模仿系统的实现写了一个示例项目 <a href="https://github.com/internetWei/WeakPointer">WeakPointer</a>，我在这个项目里还给分类属性也支持了 weak 特性，感兴趣的同学可以参考一下。</p><h2 id="关于-weak-指针的一些疑问与解答"><a href="#关于-weak-指针的一些疑问与解答" class="headerlink" title="关于 weak 指针的一些疑问与解答"></a>关于 weak 指针的一些疑问与解答</h2><h3 id="为什么不能给-Category-添加-weak-属性？"><a href="#为什么不能给-Category-添加-weak-属性？" class="headerlink" title="为什么不能给 Category 添加 weak 属性？"></a>为什么不能给 Category 添加 weak 属性？</h3><p>我们一般是这样初始化一个 weak 指针：<code>__weak id weakPtr = obj;</code>，从源码中我们知道编译器会把代码转换成这样：<code>objc_storeWeak((void *)&amp;weakPtr, obj);</code>。</p><p>从这里可以发现，要实现 weak 特性，你必须能拿到 obj 对象和 weak 指针的内存地址，而 Category 中的属性是依靠 runtime 中的 <code>objc_setAssociatedObject</code> 和 <code>objc_getAssociatedObject</code> 这 2 个函数来实现的，我们拿不到 weak 指针的内存地址，故而无法给 Category 的属性支持 weak 特性。</p><p>类的属性之所以支持 weak 特性，是因为编译器能拿到这个属性的成员变量的地址（即 weak 指针的内存地址）。</p><p>如果你一定要给 Category 添加 weak 属性的话，有以下 2 个思路（建议选择第 2 个）：</p><ol><li><p>参考我的这个项目 <a href="https://github.com/internetWei/WeakPointer">WeakPointer</a> 模仿系统的实现手动维护一个弱引用表来支持 Category 的 weak 属性。</p></li><li><p>创建一个中间类，给中间类声明一个 weak 属性，Category 的属性强引用这个中间类，中间类的 weak 属性指向真正的对象。</p><p> 示例代码：</p> <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WeakTarget</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="type">id</span> weakObj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span>(<span class="title">Category</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="type">id</span> weakObj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span> (<span class="title">Category</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setWeakObj:(<span class="built_in">NSObject</span> *)obj &#123;</span><br><span class="line">    WeakTarget *target = [[WeakTarget alloc] init];</span><br><span class="line">    target.weakObj = obj;</span><br><span class="line"></span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(weakObj), target, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)weakObj &#123;</span><br><span class="line">    WeakTarget *target = objc_getAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(weakObj));</span><br><span class="line">    <span class="keyword">return</span> target.weakObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">WeakTarget</span> @<span class="title">end</span></span></span><br></pre></td></tr></table></figure></li></ol><h3 id="为什么在-block-中不能使用-weak-指针访问其成员变量。"><a href="#为什么在-block-中不能使用-weak-指针访问其成员变量。" class="headerlink" title="为什么在 block 中不能使用 weak 指针访问其成员变量。"></a>为什么在 block 中不能使用 weak 指针访问其成员变量。</h3><p>这是我在项目中实际遇到的一个问题，伪代码如下：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    weakSelf-&gt;_propertyName;<span class="comment">// 使用 weak 指针直接访问成员变量。</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码无法通过编译，如果改成这样就没问题了：<code>weakSelf.propertyName;</code>。</p><p>众所周知，在 objc 里访问属性最终还是会访问成员变量。那为什么访问属性就正常，访问成员变量就会报错呢？</p><p>之所以会这样，是因为现在的编译器比较智能，考虑的比较多。weakSelf 在运行时有可能为 nil 从而导致崩溃，编译器认为这样的代码不安全所以报错。但是使用 weakSelf 访问属性是安全的，因为访问属性实际上是调用了属性的 get&#x2F;set 方法，在 objc 里对 nil 调用方法是不会导致异常。</p><p>上面的报错代码可以改成以下代码来解决编译报错：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="keyword">if</span> (weakSelf) &#123;<span class="comment">// 这一步很重要，因为这里的 weak 指针有可能已经是 nil 了。</span></span><br><span class="line">        __<span class="keyword">strong</span> <span class="keyword">typeof</span>(weakSelf) strongSelf = weakSelf;</span><br><span class="line">        strongSelf-&gt;_propertyName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="为什么在对象没有弱引用时也会执行-weak-clear-no-lock"><a href="#为什么在对象没有弱引用时也会执行-weak-clear-no-lock" class="headerlink" title="为什么在对象没有弱引用时也会执行 weak_clear_no_lock"></a>为什么在对象没有弱引用时也会执行 weak_clear_no_lock</h3><p>在研究 weak 指针自动赋值 nil 的过程中，我发现，对象只要曾经被 weak 指针指向过，在对象释放的时候即使没有指向它的 weak 指针，也会执行到 weak_clear_no_lock 函数。</p><p>在 storeWeak 函数中会调用这行代码设置对象被 weak 指针指向的标记：<code>newObj-&gt;setWeaklyReferenced_nolock();</code>。</p><p>但是，当对象没有任何 weak 指针指向时，weak_unregister_no_lock 函数中并没有调用相关函数将标记设置为 false。</p><p>这会导致在对象释放的时候，即调用到 rootDealloc 函数时无法执行快速释放逻辑。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">objc_object::rootDealloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isTaggedPointer</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(<span class="built_in">isa</span>().nonpointer                     &amp;&amp;</span><br><span class="line">    <span class="comment">// 如果对象曾经被 weak 指针指向过，即使现在没有了，weakly_referenced 也是 true。</span></span><br><span class="line">                 !<span class="built_in">isa</span>().weakly_referenced             &amp;&amp;</span><br><span class="line">                 !<span class="built_in">isa</span>().has_assoc                     &amp;&amp;</span><br><span class="line">                 !<span class="built_in">isa</span>().<span class="built_in">getClass</span>(<span class="literal">false</span>)-&gt;<span class="built_in">hasCxxDtor</span>() &amp;&amp;</span><br><span class="line">                 !<span class="built_in">isa</span>().has_sidetable_rc)) &#123;</span><br><span class="line">        <span class="built_in">free</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">object_dispose</span>((id)<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我也不太清楚为什么这么做？如果你知道其中的具体细节的话，还请留言告知。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ObjC </tag>
            
            <tag> Runtime </tag>
            
            <tag> ARC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>慎用unsigned类型</title>
      <link href="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%85%8E%E7%94%A8unsigned%E7%B1%BB%E5%9E%8B/"/>
      <url>/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%85%8E%E7%94%A8unsigned%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由 布多(budo) 发布于 2022-07-22</p></blockquote><p>这篇文章我会从计算机基础的角度向大家解释 unsigned 类型 和 signed 类型在内存中到底是如何存储的，以及为什么要慎用 unsigned 类型。</p><blockquote><p>我是站在 iOS 开发角度写的这篇文章，所以会出现一些OC代码，如果你看不懂的话可以跳过这些部分。</p></blockquote><p>在OC中我们一般会使用 <strong>NSUInteger</strong> 而非 <strong>unsigned</strong> 表示无符号整数，但其实它们是一样的，NSUInteger 只是 unsigned 的类型别名而已；NSObjCRuntime.h 文件中有关于 NSUInteger 的详细定义。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __LP64__ || TARGET_OS_WIN32 || NS_BUILD_32_LIKE_64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="built_in">NSUInteger</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">NSUInteger</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)reversePrintObjectWithArray:(<span class="built_in">NSArray</span> *)array &#123;</span><br><span class="line">    <span class="keyword">if</span> (![array isKindOfClass:<span class="built_in">NSArray</span>.class]) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = array.count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;第%lu个元素: %@&quot;</span>, i, array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个方法只是简单的倒序打印数组中的每个元素，而且在打印前也做了类型检查和判空操作。但是它还是有问题，你能看出来吗？</p><p>当你传递的参数是 nil、非 NSArray 类型，或者非空数组时，一切都正常；但如果你不小心传递了一个空数组，将会导致崩溃，崩溃原因是数组访问越界，越界的索引是 18446744073709551615(<code>如果在32位环境下，会是4294967295</code>)。你也可以把这段代码粘贴到你的项目中，测试一下看看结果是否和我说的一样。</p><p>？？？是不是觉得条件都不符合，循环应该一次都没执行，还有 18446744073709551615 是哪来的？</p><p>其实造成这一切的根源在于 __计算机对于正数和负数的读写方式不一样__。</p><hr><p>下面我将用C代码来帮助大家理解 _计算机是如何读写正数和负数_。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">short</span> a = <span class="number">-18</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> b = <span class="number">65518</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a: %hd, %hu\n&quot;</span>, a, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b: %hd, %hu\n&quot;</span>, b, b);</span><br></pre></td></tr></table></figure><p><img src="2022_07_20_16.37.50.png" alt="运行结果"></p><p>计算机规定整数必须以补码形式进行存储，如果你想弄明白为什么，请阅读<a href="#jump1">题外话(为什么要使用补码)</a>。</p><blockquote><p>注意：只有负数需要计算补码，正数的反码、补码其实和原码一样。</p></blockquote><p>变量a的补码计算过程如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-18</span><br><span class="line">= 10010(18的二进制)</span><br><span class="line">= 0000 0000 0001 0010(short 类型占用 2 * 8 = 16 个比特位，所以前面需要补0)</span><br><span class="line">= 1000 0000 0001 0010(计算机规定，有符号数的第1个比特位用于存储符号位，1表示负</span><br><span class="line">数，0表示正数；这就是-18的原码)</span><br><span class="line">= 1111 1111 1110 1101(这是-18的反码，反码就是把除符号位之外的所有数据取反)</span><br><span class="line">= 1111 1111 1110 1110(这是-18的补码，补码是在反码的基础上加1)</span><br></pre></td></tr></table></figure><p>变量a实际存储在内存中的数据不是原码 <code>1000 0000 0001 0010</code> 而是补码 <code>1111 1111 1110 1110</code>；在使用 <code>%hd</code> 打印的时候，计算机会把内存中的数据当作补码处理，所以需要先将它还原成原码 <code>1000 0000 0001 0010</code>，然后把原码转为十进制，所以输出的是 -18。</p><p>当你使用 <code>%hu</code> 去打印变量a的时候，计算机会把这块内存的数据解释为正数，还记得之前提到的正数的补码和原码一样吗，计算机会把内存中的数据直接当作原码处理， <code>1111 1111 1110 1110</code> 转为十进制正好就是 65518 。</p><p>看完变量a的讲解后，你是否能手动验证变量b的结果呢？</p><p>变量b的原码是 <code>1111 1111 1110 1110</code>，由于它是正数，所以补码就等于原码；在使用 <code>%hu</code> 打印的时候，计算机会把内存中的数据直接当成原码处理，所以会输出 65518。</p><p>如果使用 <code>%hd</code> 打印的话，计算机会把内存中的数据当做补码，补码转为原码是 <code>1000 0000 0001 0010</code>，发现了吗，这不就是 -18 的原码吗。</p><blockquote><p>发现了吗，65518 的补码&#x2F;原码正好和 -18 的补码一样(<code>简单的说，在内存中 65518 和 -18 的数据是一样的</code>)；有时候现实中2个完全不同的数可能在内存中的表现会一模一样，这也是为什么大部分情况下二进制无法还原回高级语言的原因。</p></blockquote><blockquote><p>以变量a为例，不管它的类型是 <code>short</code> 还是 <code>unsigned short</code>，都不会影响 -18 这个值在内存中的存储方式，在读取变量a的值时，计算机首先找到变量a的地址，然后根据类型得到它的长度，short 的长度是 2 * 8 &#x3D; 16 个比特位，从变量a的地址开始，往后16个比特位就是变量a在内存中存储的数据，使用不同的符号打印(%hu、%hd)会影响计算机对这块内存的解释，但不会影响内存中的数据。</p></blockquote><hr><p>回到开头那个数组越界的问题，18446744073709551615 其实就是把 -1 当作无符号数读取而来的。</p><p>由于 <code>NSUInteger</code> 实际是 long 类型，占用 <code>8 * 8 = 64</code> 个比特位，-1 的原码是 <code>1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0001</code>，补码是 <code>1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111</code>，由于 <code>NSUInteger</code> 是无符号数，所以计算机会把补码当成原码使用，转为十进制正好就是 18446744073709551615 。</p><p>解决起来也很简单，把 <code>NSUInteger</code> 用 <code>NSInteger</code> 代替就行了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在项目开发过程中，除了返回值、参数等特殊地方，建议统一使用有符号数(<code>NSInteger</code>)代替无符号数(<code>NSUInteger</code>)，这有如下好处：</p><ol><li>提高代码的统一性和兼容性。</li><li>避免不同数字类型之间的转换问题，减少代码复杂度，降低代码BUG率。</li></ol><p>如果必须要使用无符号数，例如返回值、参数等，切记一定要在使用前检查数据正确性，例如使用强转判断值是否正确。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无符号数作为方法参数</span></span><br><span class="line">- (<span class="type">void</span>)fun:(<span class="built_in">NSUInteger</span>)index &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">NSInteger</span>)index &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无符号数作为返回值</span></span><br><span class="line"><span class="built_in">NSInteger</span> _count;</span><br><span class="line">- (<span class="built_in">NSUInteger</span>)count &#123;</span><br><span class="line">    <span class="keyword">return</span> _count &lt; <span class="number">0</span> ? <span class="number">0</span> : (<span class="built_in">NSUInteger</span>)_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像文章中的这种问题属于数据异常，大部分情况下数据异常远比崩溃还要严重。</p><p>数据异常可能会给用户或公司带来巨大损失；假设你开发一个计算器软件，把值算错了大概率会导致非常严重的后果和损失，如果让程序崩溃或死机，至少客户会选择其他计算器或计算方式而不会造成后面更严重的损失。</p><p>另外数据异常这种问题通常很难发现，很容易成为线上BUG导致糟糕的用户体验(<code>建议大家平常使用单元测试来对代码进行定期体检，这样能大大降低类似的这种错误</code>)。</p><p>在Swift中，如果你对一个无符号类型(<code>UInt</code>)变量不小心赋值了负数的话，将会得到一个运行时崩溃，说明数据异常确实比APP崩溃更严重。</p><h2 id="题外话-为什么要使用补码"><a href="#题外话-为什么要使用补码" class="headerlink" title="题外话(为什么要使用补码)"></a><span id = "jump1">题外话(为什么要使用补码)</span></h2><p>由于加法和减法这种操作非常频繁，为了提高运算效率，所以它们一般都由硬件直接支持；如果直接使用原码存储的话，在计算类似 <code>6 - 18</code> 这样的表达式时将会得到错误的结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 - 18 = 6 + (-18)</span><br><span class="line">= 0000 0000 0000 0110(原) + 1000 0000 0001 0010(原)</span><br><span class="line">= 1000 0000 0001 1000(原)</span><br><span class="line">= -24</span><br></pre></td></tr></table></figure><p>很明显计算结果是不对的，于是有些人设计出了反码，用反码计算确实解决了 <code>6 - 18</code> 的问题，但是类似 <code>18 - 6</code> 这样的计算又出错了：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">18 - 6 = 18 + (-6)</span><br><span class="line">= 0000 0000 0001 0010(原) + 0000 0000 0000 0110(原)</span><br><span class="line">= 0000 0000 0001 0010(反) + 1111 1111 1111 1001(反)</span><br><span class="line">= 1 0000 0000 0000 1011(反) </span><br><span class="line">= 0000 0000 0000 1011(反) // 最左边的1内存容纳不了，所以直接截掉。</span><br><span class="line">= 0000 0000 0000 1011(原)</span><br><span class="line">= 11</span><br></pre></td></tr></table></figure><p>计算结果离正确值还差1，__如果按照反码计算的话，小数减去大数会正确，但大数减去小数就始终会相差1__，还是那群人，又绞尽脑汁的设计出了补码(<code>该设计者因此获得了图灵奖</code>)。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">18 - 6 = 18 + (-6)</span><br><span class="line">= 0000 0000 0001 0010(原) + 0000 0000 0000 0110(原)</span><br><span class="line">= 0000 0000 0001 0010(反) + 1111 1111 1111 1001(反)</span><br><span class="line">= 0000 0000 0001 0010(补) + 1111 1111 1111 1010(补)</span><br><span class="line">= 1 0000 0000 0000 1100(补)</span><br><span class="line">= 0000 0000 0000 1100(补) // 最左边的1内存容纳不了，所以直接截掉。</span><br><span class="line">= 0000 0000 0000 1100(反)</span><br><span class="line">= 0000 0000 0000 1100(原)</span><br><span class="line">= 12</span><br></pre></td></tr></table></figure><p>结果终于正确了，如果大家感兴趣的话可以手动计算一下 <code>13 - 5</code>、<code>5 - 13</code> 等等来巩固你学到的知识。</p><blockquote><p>计算机的设计是一门艺术，很多实用的技术都是权衡和妥协的结果。</p></blockquote><p>如果你还是不理解的话，建议你看看 <a href="http://c.biancheng.net/view/vip_1761.html">整数在内存中是如何存储的，为什么它堪称天才般的设计</a>(<code>这是一篇付费文章，如果你不想付费的话请自行百度搜索关键字</code>)。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>不要把无符号数、有符号数和正数、负数搞混，无符号数肯定是正数，但有符号数未必是负数。</p><p>计算机是对正数和负数的读写规则不一样，不是对无符号数和有符号数的读写规则不一样。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Code Review规范</title>
      <link href="/2022/01/20/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/Code%20Reivew%E8%A7%84%E8%8C%83/"/>
      <url>/2022/01/20/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/Code%20Reivew%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由 布多(budo) 发布于 2022-01-20</p></blockquote><blockquote><p>本文的名词解释：</p><ul><li>CR：code review</li><li>CL：change list(指这次改动)</li></ul></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章是站在公司的角度基于 Google的代码审查指南 和笔者实际经验的个人总结，所以相对原文(Google的代码审查指南)有适当的删减，想看完整版的请阅读<a href="https://google.github.io/eng-practices/review/reviewer/">Google的代码审查指南</a>。</p><p>该规范的目的旨在提高公司内部项目的代码库质量。</p><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><ol><li><p>技术事实和数据应该凌驾于意见和个人偏好之上；在代码风格方面，风格指南是绝对权威，任何不在指南中的点(如空格等)都是个人偏好的问题，这些点原则上应该与现有的风格保持一致，但是如果这些点现在还没有形成一定的风格，那么应该接受作者的风格。</p></li><li><p>软件设计的各个方面几乎从来不是纯粹的风格问题，也不只是个人偏好，它们是建立在基本原则的基础上的，应该在这些原则的基础上加以衡量，而不仅仅是只考虑个人意见。有时，如果作者能够证明(通过数据或基于可靠的工程原理)它的方法是同样有效的，那么审查者应该接受作者的偏好。否则，审查者的选择应该取决于软件设计的标准原则。</p></li></ol><h3 id="CR的标准"><a href="#CR的标准" class="headerlink" title="CR的标准"></a>CR的标准</h3><ol><li><p>Code Reivew的主要目的是确保代码库的 <strong>整体代码</strong> 运行状况随着 <strong>时间的推移</strong> 而 <strong>得到改善</strong>，Code Review的所有工具和流程都为此而设计。</p></li><li><p>为了实现这个目标，必须 <strong>综合考虑许多因素</strong>，并且做出 <strong>取舍和平衡</strong>。</p></li><li><p>审查者有责任确保每个CL都具有这样的质量：即随着时间的推移，代码库的整体代码健康状况不会降低。这可能会很棘手，特别是当团队的交付受到严重的时间限制并且他们觉得必须采取捷径才能实现目标时。</p></li><li><p>没有 <strong>完美</strong> 的代码，只有 <strong>更好的代码</strong>，审查者应该权衡发展的需要和别人的建议；不应该追求完美，而应追求持续改进，作为一个整体，如果CL能提高整个系统的可维护性、可读性、可理解性，那么不应该因为它不 “完美” 而拒绝。</p></li><li><p>如果开发人员有些地方做的很好，应该告诉并鼓励开发人员，但是如果这个改进不是很重要，可以告诉作者这种改进只是一种锦上添花的效果，作者可以选择忽略避免重复工作。</p></li></ol><h3 id="CR关注点"><a href="#CR关注点" class="headerlink" title="CR关注点"></a>CR关注点</h3><ol><li><p>在CR中最重要的是看CL的整体设计与结构。CL中不同代码段的交互是否有意义？它与系统的其他部分是否集成良好？现在是添加此功能的合适时机吗？</p></li><li><p>审查者应该按照 <a href="https://juejin.cn/post/7018484631057989663"><strong>风格指南</strong></a>、<a href="https://juejin.cn/post/7055164422662127647"><strong>开发规范</strong></a> 进行检查。</p></li><li><p>审查者应该考虑一些边缘状况，寻找并发性问题，尝试像用户一样思考，并确保不会看到仅通过阅读代码就能发现的错误。</p></li><li><p>审查者应该严查使用了设计模式的地方(例如使用了单例，那么就检查是否一定需要使用)。</p></li><li><p>如果有必要的话可以自己去验证CL。有些时候在阅读代码时，很难理解某些更改会对用户产生怎样的影响，例如UI更改。对于这样的更改，如果不方便自己测试，可以让开发人员演示该功能。</p></li><li><p>在CR期间另一个特别重要的事情是查看代码中是否存在某种 <strong>并发编程</strong>，理论上可能导致死锁或竞争条件，这些类型的问题很难通过运行代码来检测，通常需要有人(开发人员或审查者)仔细考虑它们以确保不会引入问题。</p></li></ol><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ol><li><p>代码的复杂度是否超过预期？有没有更简单的实现方式？单行代码是否过于复杂？函数或方法是否过于复杂？类是否过于复杂？“复杂” 通常意味着该代码很难阅读，也意味着 “当开发人员试图调用或修改这段代码时，他们很可能会引入BUG”。</p></li><li><p>有一种复杂性是过度设计造成的，开发者让那段代码过度通用化，超过了原本所需要的，或者是增加了系统目前不需要的功能；审查者应特别注意一下过度设计，鼓励开发者解决他们现在需要解决的问题，而不是推测将来可能需要解决的问题，当那些问题出现的时候再去解决它们，因为那个时候你可以更清晰的看见问题的样子。</p></li></ol><h3 id="如何浏览CL"><a href="#如何浏览CL" class="headerlink" title="如何浏览CL"></a>如何浏览CL</h3><ol><li><p>用宏观的角度来看待改动，查看CL描述以及它做了什么。</p></li><li><p>找到CL最核心的部分文件，首先查看这些主要部分。这有助于为CL的其他较小部分提供逻辑，而且这样可以提高CR速度。如果CL太大导致无法确定哪里是主要部分时，请向开发者询问重要的部分，或者要求他们将CL拆分为多个CL。如果在主要部分发现存在主要的设计问题，应该立即告诉开发者修改。因为如果设计问题足够严重的话，继续CR其他部分的代码可能只是浪费时间。</p></li></ol><h3 id="浏览每一行代码"><a href="#浏览每一行代码" class="headerlink" title="浏览每一行代码"></a>浏览每一行代码</h3><ol><li><p>仔细审查每一行代码。有些东西，例如资料文件、生成的代码、大型数据结构，你可以稍微扫过，但是不要扫过开发者写的类、函数、方法、代码区块，更不能假设它内部是没问题的。</p></li><li><p>如果代码过于复杂并且需要减慢审查速度时，那么请你告诉开发者这件事，让他们为这段代码做出解释。你要求开发者去说清楚这段代码时，同时也在帮助未来的开发人员理解这些代码。</p></li></ol><h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><ol><li>请结合上下文查看CL，该CL是否改善了整体系统的代码质量，会不会让整个系统更加复杂？是否缺少测试？千万不要授受会降低整体系统代码质量的CL。因为大多数系统是由于许多小改动的累积而变得复杂的。</li></ol><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ol><li><p>一般来说，测试应该添加到与生产代码相同的CL中，除非CL正在处理紧急情况。</p></li><li><p>审查者有必要确保测试是正确、合理、有用的。当代码真的有问题，测试是否会失败？如果被测试的程序发生改动时，测试是否会产生误报？每一个测试是否做出了简单而有用的断言？不同的测试方法之间是否适当分开？</p></li><li><p>请记住，测试代码也是需要维护的代码。不要因为测试不是主分支的一部分就接受测试中的复杂性。</p></li></ol><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><ol><li><p>在CR中遇到任何冲突，首先应该是开发人员和审查者通过本文档的内容和代码规范尝试达成共识。</p></li><li><p>当达成共识比较困难时，审查者可以和作者进行面对面沟通。如果还不能解决问题，可以让更多的人(例如项目管理者)参与进来一起讨论解决冲突。</p></li></ol><h3 id="紧急状况"><a href="#紧急状况" class="headerlink" title="紧急状况"></a>紧急状况</h3><ol><li><p>紧急提交历史只能是一个小的更改：修复严重影响生产中用户的错误，处理紧迫的法律问题，关闭主要的安全漏洞等。</p></li><li><p>在紧急情况下，我们更关心整个代码审查过程的速度，仅在这种情况下，审查者应该更关心审查的速度和代码的正确性(它是否真的解决了紧急情况？)而不是其他任何事情。此外这种审核应该优先于所有其他代码审查。</p></li><li><p>但是，在紧急情况解决后，您应该再次查看紧急情况提交历史并对其进行更彻底的审查。</p></li></ol><h3 id="什么不是紧急情况？"><a href="#什么不是紧急情况？" class="headerlink" title="什么不是紧急情况？"></a>什么不是紧急情况？</h3><ol><li>以下情况不是紧急情况：<ul><li>想要在本周而不是下周发布(除非有一些实际的硬性发布期限，例如合同协议)。</li><li>开发人员已经在一个功能上工作了很长时间，他们很想审查通过。</li><li>今天是星期五，在开发人员开始周末之前审查通过会很棒。</li><li>……</li></ul></li></ol><h3 id="什么是硬期限？"><a href="#什么是硬期限？" class="headerlink" title="什么是硬期限？"></a>什么是硬期限？</h3><ol><li><p>硬期限指的是严格的截止日期，如果您错过它就 <strong>会发生灾难性事情</strong> 的截止日期。例如：</p><ul><li>为了履行合同义务，必须在某个日期之前完成。</li><li>如果未在特定日期之前发布，您的产品将在市场上完全失败。</li><li>一些硬件制造商每年只发货一次新硬件，如果您错过了向他们提交代码的截止日期，那可能是灾难性的。</li><li>……</li></ul></li><li><p>大多数截止日期都是软截止日期，而不是硬截止日期；它们代表了在某个时间完成某项功能的愿望，它们很重要，但不应该牺牲代码质量来达到目的。</p></li></ol><h3 id="CR太严格被抱怨怎么办？"><a href="#CR太严格被抱怨怎么办？" class="headerlink" title="CR太严格被抱怨怎么办？"></a>CR太严格被抱怨怎么办？</h3><ol><li><p>提高CR的速度通常会让这些抱怨逐渐消失。可能需要数个月，但最终开发人员会看到严格的CR所带来的价值，因为严格的CR会帮助他们产生更优秀的代码。</p></li><li><p>如果你遵循这些准则，并且如果CR非常严格的话，后面你会发现整个CR流程会越来越快。因为开发者会知道什么是质量好的代码，并且在开始就提交一个很棒的CL。但不要为提高想象中的速度，而对CR标准和代码质量做出妥协，毕竟从长远来看它实际上并不会让任何事情发生的更快。</p></li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><ol><li>可以转载，但是请注明来源。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://google.github.io/eng-practices/review/reviewer/">Google的代码审查指南</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 开发规范 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ObjC 开发规范</title>
      <link href="/2022/01/20/iOS/ObjC%20%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
      <url>/2022/01/20/iOS/ObjC%20%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由 布多(budo) 发布于 2022-01-20 • 最后更新于 2025-02-13</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章是基于笔者个人经验以及一些开发规范总结而成，目的是提高公司内部项目的稳定性与效率。<br>文章的前半部分是一些通用开发规范，适用于所有编程语言甚至是生活中遇到的问题；<br>后半部分是关于OC的开发规范以及开发中容易犯的错误，如果不想看可以跳过。</p><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><p>我们无法写出完全没有BUG的代码，但是我们可以尽量写出容易阅读和逻辑简单清楚的代码，容易阅读和逻辑简单清楚的代码从某种程度上会减少BUG以及BUG的修复难度。</p><h2 id="通用规范"><a href="#通用规范" class="headerlink" title="通用规范"></a>通用规范</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">虽然BUG无法完全避免，但是我们可以遵循一些规范和规则让BUG尽早暴露，或者让它便于排查。</span><br></pre></td></tr></table></figure><ul><li><p><strong>[必须]</strong> 开发完一个模块(<code>功能、页面等等</code>)时，自测一遍，确认没有问题后再开发下一个模块，如果一个模块很大，可以完成一个小功能时自测一遍，不要把所有问题都放到最后测试，更不要依赖测试人员。</p></li><li><p><strong>[必须]</strong> 禁止实现未来可能需要的功能，如果这个功能现在不需要就不要实现它，等未来需要的时候再去实现它，因为那个时候你可以更清晰的看到那个功能完整的模样(<code>如果必须要实现它，必须要考虑所有可能发生的情况以及细节，并且加上注释说明</code>)。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">实现一个未来可能需要的功能在大部分情况下都是得不偿失的，有以下缺点：</span><br><span class="line">1. 未来可能不需要这个功能。</span><br><span class="line">2. 增加垃圾代码，当别人看见这段代码时不理解为什么要这么写。</span><br><span class="line">3. 增加维护成本和开发时间(即使某段代码不使用也是需要维护的)。</span><br><span class="line">4. 后期真正要用的时候可能会发现当初实现的时候考虑不全面，最后还是要重新写一遍。</span><br><span class="line">5. ……</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 不要尝试去推测并解决未来可能发生的问题，等问题出现的时候再去解决它，因为那个时候你可以更清晰的看见问题的真实样子。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">这个规则不是说要你发现问题了不去解决等到被别人发现提出后再解决；</span><br><span class="line">现实生活中有一些完美主义者想让自己写的代码非常完美没有任何问题，所以他们会尽</span><br><span class="line">量假设各种各样的情况，甚至很多极端情况，有时候会为了一个发生概率很小并且</span><br><span class="line">影响不是很重要的问题而大改特改，直到满意为止，这么做很可能会影响别人甚至导致项目延迟上线。</span><br><span class="line">在修改过程中如果改动的范围特别大还可能会引进新的问题，而且由于这个问题是未来</span><br><span class="line">可能会发生的问题，所以可能还会有你没考虑到的地方，最后既引进了新的问题还可能没解决问题。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 对于服务端返回的值，永远不要假设它是正确的类型和值(<code>即使服务端的人保证</code>)，使用之前必须检查它的真实类型和值是否符合预期。</p></li><li><p><strong>[必须]</strong> 不要让代码脱离开发者的掌控。当我们开发一个功能时，总是希望让使用者调用更少的API或者自动调用，但是有些步骤让使用者主动调用会更好一些，这样使用者知道他干了什么，而不是出了问题时一头雾水，当你把某个步骤设置成自动调用时想一下这是否有必要？如果不是请让使用者主动调用它并在文档中加以说明。</p></li><li><p><strong>[必须]</strong> 所见即所得，例如页面上2个控件的间距是10，那么代码中的间距设置也应该是10，而不应该是一个控件很高，有很多的空白区域，然后用-xx(负间距)去填充。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">UILabel *label1 = [[UILabel alloc] init];</span><br><span class="line">label1.frame = CGRectMake(0, 0, 100, 30);</span><br><span class="line"></span><br><span class="line">UILabel *label2 = [[UILabel alloc] init];</span><br><span class="line">label2.frame = CGRectMake(0, 30 + 10, 100, 30);</span><br><span class="line">上述代码明显的告诉你 label2 的顶部和 label1 的底部间距为10。</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">UILabel *label1 = [[UILabel alloc] init];</span><br><span class="line">label1.frame = CGRectMake(0, 0, 100, 30);</span><br><span class="line"></span><br><span class="line">UILabel *label2 = [[UILabel alloc] init];</span><br><span class="line">label2.frame = CGRectMake(0, -20, 100, 90);</span><br><span class="line">假设文字实际展示需要 30 高度，上述代码和正例中的代码给用户的感觉是一样的，</span><br><span class="line">但是阅读性却非常差。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 一般情况下禁止使用过时的方法或类，应该及时去了解和使用新方法或类。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">对于过时的方法或类，大都是因为其自身有缺陷或BUG，</span><br><span class="line">使用新方法前建议了解一下旧方法/类废弃的原因。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 尽量不要使用runtime去交换方法，可以使用中间者模式或者其他方法代替，如果一定要这么做，那么请留下注释说明交换方法后做了什么，以及为什么要这么做？</p></li><li><p><strong>[必须]</strong> 尽量不要直接使用成员变量，而是使用属性替代它。</p></li><li><p><strong>[必须]</strong> 在dealloc方法内禁止将self传递出去，如果self被retain，到下个runloop周期再释放则会多次释放导致crash。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反例：</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [self unsafeMethod:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 对剪切板的读取操作必须放在子线程中进行，因为用户可能在Mac上复制大量数据然后通过接力同步到iPhone上。</p></li><li><p><strong>[必须]</strong> 当方法可能会提前return时，需要注意对象的释放问题，避免内存泄漏。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反例：</span><br><span class="line">CFArrayRef arrayRef = (__bridge CFArrayRef)array;</span><br><span class="line"></span><br><span class="line">if (x == YES) return;</span><br><span class="line"> </span><br><span class="line">CFRelease(arrayRef);</span><br><span class="line"></span><br><span class="line">如果if条件成立那么arrayRef对象就会内存泄漏。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 使用@try处理异常时，需要注意对象的释放问题，避免内存泄漏。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反例：</span><br><span class="line">@try &#123;</span><br><span class="line">CFArrayRef arrayRef = (__bridge CFArrayRef)array;</span><br><span class="line">    </span><br><span class="line">do some thing……</span><br><span class="line"></span><br><span class="line">CFRelease(arrayRef);</span><br><span class="line">        </span><br><span class="line">&#125; @catch (NSException *exception) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果do some thing……出现异常的话那么arrayRef就会出现内存泄漏。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 如果使用到的值和另一个值有所关联，在代码中体现出这种关联性，这能增加代码可读性，也能增加代码稳定性。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">例如有1个头像控件需要显示为圆形，我们经常会这样设置：</span><br><span class="line">1. 给头像控件设置圆角：layer.cornerRadius = 15.0;</span><br><span class="line">2. 给头像控件设置宽高：.frame = CGRectMake(0, 0, 30.0, 30.0);</span><br><span class="line">// 上述代码中的15.0 和 30.0 就没有任何关联性，如果它们之间相隔了很多代码，</span><br><span class="line">   修改宽高的时候可能会忘记修改cornerRadius。</span><br><span class="line">   </span><br><span class="line">正例：</span><br><span class="line">1. 给头像控件设置圆角：layer.cornerRadius = 15.0;</span><br><span class="line">2. 给头像控件设置宽高：.frame = CGRectMake(0, 0, layer.cornerRadius * 2.0, layer.cornerRadius * 2.0);</span><br><span class="line">// 这样后面阅读代码的人一眼就能明白宽高和 layer.cornerRadius 的关系，既增加了可读性，又增加了稳定性。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 如果一个值需要特别多个变量计算出来，请把它们提取成一个变量并且加上注释说明这个变量是怎么组成的。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">// 屏幕宽度 - label左边距 - label右边距 - 开关按钮宽度 - 按钮右边距</span><br><span class="line">    CGFloat titleMaxWidth = kScreenWidth - labelLeftSpacing - labelRightSpacing - buttonWidth - buttonRightSpacing;</span><br><span class="line"></span><br><span class="line">// 这样写的好处在于以后如果需要修改某个控件的布局信息，只需要修改一处即可，降低了后续维护难度。</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 声明常量尽量使用const类型，不要使用#define。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips: </span><br><span class="line">宏定义声明常量的缺点：</span><br><span class="line">1. 宏定义只是简单的替换，缺少编译检查，运行期可能会出现溢出或数据错误等问题。</span><br><span class="line">2. 宏定义缺少类型，不方便编写文档用例。</span><br><span class="line">3. 宏定义可能会被替换。</span><br><span class="line">4. 宏定义无法编写符合规范的注释信息。</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">#define kTime @&quot;10&quot;</span><br><span class="line">    </span><br><span class="line">if (NO) &#123;</span><br><span class="line">#define kTime @&quot;20&quot;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">NSLog(@&quot;time = %@&quot;, kTime);</span><br><span class="line"></span><br><span class="line">即使if永远不会执行，但是编译器也会将kTime替换为@&quot;20&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 工具类尽量在头文件的注释中写清楚该功能如何使用，以及需要注意的事项。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">1. 如果是一个UI工具，使用时是否需要提前设置frame，是否可以使用约束布局？</span><br><span class="line">2. 对于一些比较复杂的工具，最好在注释中给出一段示例代码。</span><br><span class="line">包括但不限于上述的注意事项，</span><br><span class="line">例如一个封装好的弹窗工具，应该说明如何弹出，是否需要提前设置frame或者约束</span><br><span class="line"></span><br><span class="line">以下是一个简单的示例伪代码:</span><br><span class="line">/**</span><br><span class="line">* @brief UIActivityIndicatorView的增强版，和UIActivityIndicatorView使用方式一致，但扩展了一些额外功能。</span><br><span class="line">* @discussion 1. 除了可以自定义颜色之外，还可以自定义指示器的详细大小(例如指示器宽度、高度、离心距离等)。</span><br><span class="line">* @discussion 2. 内部会自动计算控件所需要的最小宽高，可以不设置宽高约束或宽高Frame。</span><br><span class="line">* @discussion 3. 可以暂停/恢复指示器动画。</span><br><span class="line">* @code</span><br><span class="line">* LLActivityIndicatorView *activityIndicatorView = [LLActivityIndicatorView activityIndicatorWithStyle:LLActivityIndicatorViewStyleGrayMedium];</span><br><span class="line">* activityIndicatorView.backgroundColor = UIColor.redColor;</span><br><span class="line">* activityIndicatorView.frame = CGRectMake(0, 0, 50, 50);</span><br><span class="line">* activityIndicatorView.center = self.view.center;</span><br><span class="line">* [self.view addSubview:activityIndicatorView];</span><br><span class="line">* [activityIndicatorView startAnimating];</span><br><span class="line">* @encode</span><br><span class="line">*/</span><br><span class="line">@interface LLActivityIndicatorView : UIView</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 不要滥用懒加载，只在必要时刻使用它。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">只在以下三种情况下才使用懒加载：</span><br><span class="line">1. 对象的创建需要依赖其他对象</span><br><span class="line">2. 对象可能被使用，也可能不被使用</span><br><span class="line">3. 对象创建比较消耗性能</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 使用NSUserDefaults存储数据时禁止调用synchronize方法，因为系统会在合适的时机将数据保存到本地(即使程序闪退等极端情况)。</p></li><li><p><strong>[建议]</strong> 对于一些体积小并且不是特别重要的数据，不要频繁的进行写入操作，可以使用NSUserDefaults。它会在合适的时机将数据存储到本地，这避免了频繁的写入操作，而且在某些极端情况下它也能保证数据存储到本地(例如程序闪退等情况)。</p></li><li><p><strong>[必须]</strong> 添加到集合中的对象应该是不可变的，或者在加入之后其哈希值是不可变的。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反例：</span><br><span class="line">NSMutableSet *sets = [NSMutableSet set];</span><br><span class="line">NSMutableString *string1 = [NSMutableString stringWithString:@&quot;1&quot;];</span><br><span class="line">[sets addObject:string1];</span><br><span class="line">[sets addObject:@&quot;12&quot;];</span><br><span class="line">    </span><br><span class="line">[string1 appendString:@&quot;2&quot;];</span><br><span class="line"></span><br><span class="line">当 [string1 appendString:@&quot;2&quot;] 执行完以后sets对象内会包含2个@&quot;12&quot;。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 不可变对象请使用copy修饰，如果重写set方法，请注意调用copy方法。</p></li><li><p><strong>[必须]</strong> 请使用CGRectGet函数获取Frame的各种值，而不是通过frame.的方式获取。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">CGRect t_frame = CGRectMake(-10, -10, -10, -10);</span><br><span class="line">当一个view的frame设置成t_frame后，其坐标会隐式的转换为CGRectMake(-20, -20, 10, 10)，</span><br><span class="line">因为宽高不可能出现负值；</span><br><span class="line">这时通过t_frame.的方式获取的值都是错误的，而CGRectGet会自动帮您处理这些隐式转换。</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line">CGRectGetWidth(frame)、CGRectGetMinX(frame)、CGRectGetMaxX(frame)</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">frame.size.width、frame.origin.x、frame.size.width + frame.origin.x</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 代码中单行字符数不要超过150个，超过请换行(空格除外)，可以在 Xcode -&gt; Preferences… -&gt; Text Editing -&gt; Page guide at column 中设置为150方便排查。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">- (void)setImageWithURL:(nullable NSURL *)imageURL</span><br><span class="line">            placeholder:(nullable UIImage *)placeholder</span><br><span class="line">                options:(YYWebImageOptions)options</span><br><span class="line">               progress:(nullable YYWebImageProgressBlock)progress</span><br><span class="line">               ransform:(nullable YYWebImageTransformBlock)transform</span><br><span class="line">             completion:(nullable YYWebImageCompletionBlock)completion;</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 单个方法的行数建议不超过80行，注释、左右大括号、空行、回车等除外。</p></li><li><p><strong>[必须]</strong> 在多线程环境下谨慎使用可变集合，必要时候可以采用加锁或GCD的同步线程进行保护，或者在访问可变集合时先将其copy为不可变对象然后再对其访问。</p></li><li><p><strong>[必须]</strong> 属性和方法必须有 <strong>nullable</strong> 或 <strong>nonnull</strong> 限定符，由于OC是动态语言，所以即使使用 <code>nonnull</code> 声明对象不为空，使用前也必须判断是否为空。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">- (void)setName:(NSString * _Nonnull)name &#123;</span><br><span class="line">    if (name == nil) &#123;</span><br><span class="line">      ………</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 如果有使用到数组、字典等类型，尽量使用泛型声明其包含的类型，这样可以提高代码可读性。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">NSArray&lt;NSString *&gt; *array;</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">NSArray *array;</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 如果类中包含多个初始化方法，请使用 <code>NS_DESIGNATED_INITIALIZER</code> 和 <code>NS_UNAVAILABLE</code> 宏标记提高代码可读性。</p></li><li><p><strong>[必须]</strong> 避免使用无符号整数(除非匹配系统接口使用的类型)，在工程中全部使用一种类型可以提高代码安全与一致性，无符号整数在进行数学运算和倒数到零的时候会出现细微的错误。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">NSUInteger numberOfObjects = array.count;</span><br><span class="line">for (NSInteger counter = numberOfObjects - 1; counter &gt; 0; counter--)</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">for (NSUInteger counter = numberOfObjects - 1, counter &gt; 0; counter--)</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 在自动引用计数下，OC对象会自动初始化为nil，但是有些对象不会自动初始化为nil，例如CoreFoundation中的对象，所以在声明局部对象时需要手动初始化。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">NSObject *obj = nil;</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">NSObject *obj;</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 不要使用一个类去维护多个类的内容，例如使用一个常量类维护所有的常量，要按功能进行归类，分开维护。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips: </span><br><span class="line">大而全的类，杂乱无章，使用查找功能才能定位到具体位置，不利于理解也不利于维护。</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line">缓存相关常量类放在CacheConsts下，系统配置相关常量类放在SystemConfigConsts下。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 如果超类的某个初始化方法不适用于子类，那么子类一定要重写超类的这个方法解决问题或抛出异常。</p></li><li><p><strong>[必须]</strong> 把一些稳定的、公共的变量或者方法抽取到父类中。子类尽量只维持父类所不具备的特性和功能。</p></li><li><p><strong>[必须]</strong> 禁止将布尔对象直接和 YES 或者 NO进行判断，例如 &#x3D;&#x3D; YES， !&#x3D; YES，&#x3D;&#x3D; NO，!&#x3D; NO。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">在32位机器上YES被定义为1，NO定义为0；</span><br><span class="line">而64位机器上YES被定义为非0，NO定义为0；</span><br><span class="line"></span><br><span class="line">BOOL result = 4;</span><br><span class="line"></span><br><span class="line">if (result == YES) &#123;</span><br><span class="line">    NSLog(@&quot;YES&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    NSLog(@&quot;NO&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">以上代码在64位机器会输出YES，而上32位机器上则会输出NO。因为在32位机器上 </span><br><span class="line">(result == YES) 会被解释为 (4 == (signed int) 1)，</span><br><span class="line">所以会输出NO，而在64位机器上会认为result不等于0所以输出YES。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 删除代码时将内部用到的无用文件、无用类、无用函数等统一删除干净。</p></li><li><p><strong>[建议]</strong> 如果可以，尽量使用 #undef 限制宏的作用范围。</p></li><li><p><strong>[建议]</strong> 局部变量尽量定义在最靠近使用它的地方。</p></li><li><p><strong>[建议]</strong> 在写一些简单的类方法和宏方法时，尽量使用内联函数或全局函数代替它。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">函数不通过对象调用，所以不会走OC的消息转发流程，效率高于方法调用；</span><br><span class="line">而且函数会有返回值和参数类型以及参数检查，这些都是宏定义没有的。</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line">UIKIT_STATIC_INLINE NSString * kNSStringFromInteger(NSInteger a) &#123;</span><br><span class="line">    return [NSString stringWithFormat:@&quot;%zd&quot;, a];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">#define kNSStringFromInteger(a) [NSString stringWithFormat:@&quot;%zd&quot;, a]</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 如果用到了很多协议，必要时可以把协议封装到一个单独的头文件中，这样做不仅可以减少编译时间，还能避免循环引用。</p></li><li><p><strong>[建议]</strong> 使用switch枚举时尽量将所有枚举类型都case出来而不要使用default，这样的话以后增加或删除枚举类型时如果switch没有处理的话编译器会有警告提醒。</p></li><li><p><strong>[建议]</strong> 尽量使用字面量语法创建对象，少用与之等价的方法。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">OC中的NSArray、NSString、NSDictionary、NSNumber都有与之对应的字面量语法: @[]、@&quot;&quot;、@&#123;&#125;、@()；</span><br><span class="line">使用它们有以下优点：</span><br><span class="line">1. 简单易读，提高代码的可读性和维护性。</span><br><span class="line">2. 使用字面量创建数组、字典时如果元素里在nil则会抛出异常，</span><br><span class="line">   而使用arrayWithObjects:方法创建则会丢失nil后的数据，</span><br><span class="line">   抛出异常能让你知道这里有问题及时修改防止问题在线上发生。</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">1. 使用字面量创建的对象默认是不可变的，如果要创建可变对象需要进行mutableCopy操作。</span><br><span class="line">2. 不支持子类，如果你创建了一个NSString的子类，@&quot;&quot;并不会返回你想要的子类对象。</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> UI控件尽量使用weak修饰而不是strong修饰，这样对梳理对象引用会更清晰明了。</p></li><li><p><strong>[建议]</strong> 尽量不要使用+load方法，如果必须要使用那么不要在方法内实现复杂逻辑或堵塞线程。</p></li><li><p><strong>[建议]</strong> 尽量减少继承层级，类的继承建议不要超过3层，必要时刻可以考虑用分类、协议来代替继承。</p></li></ul><h2 id="头文件规范"><a href="#头文件规范" class="headerlink" title="头文件规范"></a>头文件规范</h2><ul><li><p><strong>[必须]</strong> 头文件中尽量不要直接引用其他头文件，而是使用@class向前声明，每次引入其他头文件时先问问自己是否必须要这样做。</p></li><li><p><strong>[建议]</strong> 头文件中暴露的方法和属性尽可能少，例如外部只需要覆值操作，那就不要提供getter方法或者属性。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">@interface BookView : NSObject</span><br><span class="line"></span><br><span class="line">- (void)setBookName:(NSString *)bookName;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">@interface BookView : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSString *bookName;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 头文件中的属性尽量声明为只读，可以在实现文件中再将属性声明为可读可写。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">@interface WXYZModel : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, readonly) NSString *name;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface WXYZModel ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSString *name;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation WXYZModel</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li></ul><h2 id="Block开发规范"><a href="#Block开发规范" class="headerlink" title="Block开发规范"></a>Block开发规范</h2><ul><li><p><strong>[必须]</strong> 在Block内部使用上下文的对象时要注意相互引用的问题(<code>不一定要在 block 内使用 self 才会相互引用</code>)。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips: </span><br><span class="line">1. 不一定在Block内使用self才会相互引用，如下情况也会造成循环引用:</span><br><span class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">    WXYZ_TitleTableViewCell *cell = ………</span><br><span class="line">    </span><br><span class="line">    cell.refreshTableViewBlock = ^&#123;</span><br><span class="line">        [tableView reloadData];</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    return cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2. Block内部是否要使用weak需要看Block本身和weak的这个对象是否存在直接或间接的相互引用，</span><br><span class="line">   若无相互引用则不需要使用weak。</span><br><span class="line"></span><br><span class="line">3. 如果Block内部使用了strong修饰了外部的weak变量，那么当使用strong指向成员变量时需要进行判空，否则会崩溃，参考以下代码:</span><br><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">    cell.refreshTableViewBlock = ^&#123;</span><br><span class="line">        __strong typeof(weakSelf) strongSelf = weakSelf;</span><br><span class="line">        if (strongSelf != nil) &#123;</span><br><span class="line">            strongSelf-&gt;_name = @&quot;name&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">如果把(strongSelf != nil)的判断去掉那么可能会崩溃。</span><br></pre></td></tr></table></figure></li></ul><h2 id="通知开发规范"><a href="#通知开发规范" class="headerlink" title="通知开发规范"></a>通知开发规范</h2><ul><li><p><strong>[必须]</strong> 在发送通知时，请使用<code>userInfo</code>对象进行传值，而不是<code>object</code>。</p></li><li><p><strong>[必须]</strong> 避免重复注册通知，这会导致重复执行通知方法。</p></li><li><p><strong>[必须]</strong> 在使用通知的<code>object</code>参数时，需要确保接收方和发送方的object对象类型是一致的。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反例：</span><br><span class="line">[NSNotificationCenter.defaultCenter addObserver:self selector:@selector(testFunction) name:@&quot;testNotificationName&quot; object:model.bookID];</span><br><span class="line">[NSNotificationCenter.defaultCenter postNotificationName:@&quot;testNotificationName&quot; object:@&quot;123&quot;];</span><br><span class="line"></span><br><span class="line">假设 model.bookID 的值就是字符串123，也可能无法收到通知，</span><br><span class="line">因为NSString有__NSCFConstantString， __NSCFString， NSTaggedPointerString等多个子类对象，</span><br><span class="line">如果 model.bookID 的真实对象类型是 NSTaggedPointerString 的话就会收不到通知。</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 在工程里能不用通知尽量不用通知，通知虽然灵活强大，但是如果滥用会导致工程质量下降并且增加维护难度。</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://book.douban.com/subject/25829244/">Effective Objective-C 2.0  编写高质量iOS与OS X代码的52个有效方法</a></li><li><a href="https://google.github.io/styleguide/objcguide.html">Google的Objective-C风格指南</a></li><li><a href="https://google.github.io/eng-practices/review/reviewer/">Google的代码审查指南</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 开发规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ObjC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git命令手册</title>
      <link href="/2021/08/11/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/"/>
      <url>/2021/08/11/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由 布多(budo) 发布于 2021-08-11</p></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr><p>&nbsp;&nbsp;&nbsp;&nbsp;该手册(以下简称它)不是Git入门教程，如果您想入门Git推荐<a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰的Git教程</a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;这只是一篇个人学习Git时顺带记录的命令手册以及对Git的一些理解心得，如有不正确的地方欢迎大家留言指正。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;它包含了Git几乎所有的高级命令和部分底层命令，每个命令都有详细的解释和示例告诉您如何使用，以及使用时需要注意的地方；内容按模块划分，比如和<code>add</code>相关的命令就都会集中在一个模块，大家可以选择自己感兴趣的模块自由阅读，由于某些命令的选项非常多但是并不常用，所以该手册可能没有记录，如果想查看某个命令的所有选项请查阅<a href="https://git-scm.com/docs">Git命令参考</a>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;有些比较简单的命令这里可能没有记录，文章中的()表示的是全称，例如{u(upstream)}，表示upstream是u的全称，实际使用的时候用@{u}或者@{upstream}都可以。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Git本身是一个内容寻址文件系统，Git的核心部分是一个简单的键值对数据库，你可以向Git仓库中插入任意类型的内容，它会返回一个唯一的键，通过该键可以在任意时刻再次取回该内容。</p><blockquote><p>Tips： </p><ol><li><p>Git里一些同名的选项在相似的地方也可以使用。例如<code>--abort</code>选项，和<code>git merge --abort</code>搭配可以撤销合并操作，和<code>git rebase --abort</code>搭配可以撤销rebase操作。</p></li><li><p>Git里的大部分选项都是可以搭配一起使用的，例如<code>git log --author=&#39;internetwei&#39; --after=&quot;2020-01-01&quot; --before=&quot;2020-06-01&quot; --no-merges -- WXReader/Book/BookRack/BookReader</code><br>这行命令搭配了多达5个选项(指定作者，指定开始时间，指定结束时间，非合并提交，指定路径)， 它的意思是：打印<code>internetwei</code>作者在2020年1月1号到2020年6月1号之间对<code>WXReader/Book/BookRack/BookReader</code>这个文件夹(包括文件夹下所有文件)进行修改的所有提交记录但不包括合并提交。</p></li><li><p>Git里需要使用哈希值的地方不需要复制整个哈希字符串，通常只需要复制前6~8个字符就够了，如果项目比较大可以扩大到前8~10个，即使是像<code>Linux</code>这样的项目也只需要前10~12个字符即可保证唯一性。</p></li></ol></blockquote><h3 id="Git的特点"><a href="#Git的特点" class="headerlink" title="Git的特点"></a>Git的特点</h3><hr><ol><li><p>Git和SVN(其他版本控制工具)对待文件的区别？</p><blockquote><p>Git保存的不是文件的差异或变化，而是文件快照(快照可以简单的理解为这个文件的副本)，如果一个文件在提交的时候没有任何变化那么Git只会保留一个链接指向之前存储的内容；而SVN保存的是这个文件提交时的差异变化。 </p></blockquote></li><li><p>Git如何保证完整性?</p><blockquote><p>Git所有的数据在存储前都会计算校验和，计算校验和的机制叫做SHA－1散列(hash、哈希)，这是一个由40个16进制字符(0<del>9,a</del>f)组成的字符串，基于文件的内容和目录结构计算出来的(由于相同的文件计算出来的哈希值是一样的，所以当你存储一个文件到Git仓库时，如果Git发现已经有了就只会创建一个链接指向之前存储的那个对象)，计算出来的哈希值就像这样：<code>a6b6695a3594cc79b3c3fa9ef5772df036ec8d8e</code>，校验和的前两个字符用于命名子目录，剩下的38个字符则用作文件名，Git数据库中保存的信息都是以哈希值来索引。</p></blockquote></li><li><p>Git暂存和提交时分别做了什么？</p><blockquote><p>当你进行暂存操作时，Git会对每个文件计算校验和，然后将这些校验和加入到暂存区等待提交。</p><p>当你进行提交操作时，Git会计算每个子目录的校验和以及对所有的文件创建快照并保存快照的索引，然后Git会在仓库中把这些校验和保存为一个树对象，然后Git会创建一个提交对象，它包含一个指向最上层树对象的指针和一个指向父对象的指针(如果是合并提交会有2个父对象，如图1)，还有作者的名称、邮箱地址、提交说明。</p></blockquote><p> <img src="50c7be27cd9a4bca9c4a75c2f7df54ea~tplv-k3u1fbpfcp-zoom-1.image"> 图1</p></li><li><p>Git暂存区的作用</p><blockquote><p>大部分的版本管理(SVN)都没有暂存区的概念，Git的add命令和其他类似工具的add命令也不太一样，其他工具的add命令是将文件加入到版本管理，而Git的add命令有3种作用：1. 将未跟踪的文件加入到版本管理；2. 将已修改的文件内容加入到暂存区；3. 将冲突文件标记为冲突已解决状态。由于Git暂存区的存在，你可以在完成提交前审查你的提交内容，还可以精确的控制每一行的提交内容。例如一个文件有20行是修改BUG，另外有100行是添加新功能，现在我只想提交这个文件的修改BUG的那20行代码，那么只需要把这20行代码加入到暂存区就行了。 </p></blockquote></li><li><p>Merge的逻辑</p><blockquote><p>如果Git发现可以快进合并的话那么Git会直接把当前分支指向合并分支的最新提交(快进合并有一个缺点就是当你删除合并分支后会无法知道这个分支以前是从哪个分支合并过来的，如果想禁用快进合并可以使用<code>--no-ff</code>选项，这样Git会创建一个合并提交)，如果不可以快进合并的话Git会使用这两个分支的末端提交对象以及这两个分支的首个公共祖先提交，做一个简单的三方合并。</p></blockquote></li><li><p>GPG签名</p><blockquote><p>GPG可以签名你的提交或标签，它能够有效的提高Git仓库的安全性，因为它可以证明这个提交或标签是通过你信任的电脑提交的而不是某个冒用你名号的黑客，这相当于赋予了提交对象一种不可更改性，即使黑客通过某种办法拿到了Git仓库的读写权，他也没有办法添加或使用–force修改任何带有你GPG签名的提交或标签。</p><p>由于Git的作者名称和邮箱地址是可以随意填写的，如果有人将他的作者名称和邮箱地址改成和你的一样，然后通过某种方式将代码推送到了你的仓库中……这可能会导致你或其他人遭受损失，使用GPG签名可以尽量避免这种情况的发生。使用GPG签名过的提交在Github上显示如图2，你可以点击标签查看具体的签名信息。<br> <img src="5e21c63b735445c6b17e2d4790a291a1~tplv-k3u1fbpfcp-zoom-1.image"> 图2 </p></blockquote></li><li><p>HEAD是什么？</p><blockquote><p>HEAD本质就是一个指针，也可以叫做符号指针，因为通常情况下它指向一个分支(符号)，通过它可以获取你仓库当前的状态，可以使用<code>git symbolic-ref HEAD</code>查看当前HEAD的状态。</p><p>当HEAD指向一个具体的提交对象而不是分支引用时，Git会提示您处于“游离状态”，“游离状态”表示你当前不处于任何分支，所以你不能进行提交，只能查看提交快照的内容，也可以进行修改运行，如果你想要进行提交则需要先创建一个分支，“游离状态”通常用于调试或回滚某次提交。 </p></blockquote></li><li><p>HEAD^和HEAD~的区别？</p><blockquote><p>当后面不跟数字的时候^和~表示的意思相同，都表示第1个父提交对象；如果后面跟上数字就有差别了，^后面只能跟数字1或者数字2，^1表示当前对象的第1父提交，^2表示当前对象的第2父提交，只有合并提交对象才有第2父提交，第1父提交就是合并时接受合并的分支，第2父提交就是合并时被合并的那个分支；~后面理论上可以跟任意大于0的数字，~1表示当前提交对象的第1个父提交对象，~2表示当前提交对象的第2个父提交对象，以此类推，~2和~~表达同一个意思，不过当你想表示第100个父提交时，显然用~100比写100个~更现实，~和^可以组合使用，例如<code>git show HEAD~2^2</code>这行命令表示查看当前提交的第2个父提交的第2父提交内容。 </p></blockquote></li><li><p>Git中危险的命令</p><blockquote><p>在Git中任何已提交的内容几乎都是可以恢复的(那些被覆盖的提交也可以恢复)，但是未提交的内容丢失后可能再也找不回了，任何可能会导致工作区内容丢失的命令都是危险的命令，在Git中危险的命令总共可以分为3类:</p><ol><li>所有带<code>-f</code>选项的命令，<code>-f</code>的全称是<code>--force</code>，它表示强制的意思，例如<code>git push -f</code>表示强行将本地仓库推送到远程仓库，<code>git switch -f dev</code>表示强行切换到dev分支，总之使用<code>-f</code>选项时请小心。</li><li><code>git reset</code>命令总共有3个选项，<code>--soft</code>、<code>--mixed</code>、<code>--hard</code>，其中只有<code>--hard</code>选项是危险的命令，其他两个都是安全的，当你使用<code>--hard</code>选项时Git会使用仓库中指定的快照内容覆盖工作区。</li><li><code>git checkout</code>命令的本质是操纵HEAD指针，它的后面可以是分支名表示切换分支，也可以是文件路径，如果后面是文件路径，那么它就是一个危险的命令，Git会使用仓库中指定的快照内容覆盖工作区的指定文件(建议使用switch命令来切换分支，防止误操作导致丢失文件内容)。</li></ol></blockquote></li><li><p>checkout和reset的区别</p><blockquote><p>很多人容易把<code>checkout</code>和<code>reset</code>弄混，因为它们都可以用来回滚历史提交，虽然最终效果是一样的，但是实现过程确不一样；简单的说checkout命令会直接修改HEAD指针的指向，而reset命令修改的是HEAD指针指向的对象。</p><p>假设master分支有一个提交对象(ab4adf)，你想回滚到这次提交，Git提供了2种方式：<code>git checkout ab4adf</code>和<code>git reset --hard ab4adf</code>都可以达到你的目的，但它们的实现机制略微不一样；<code>git checkout ab4adf</code>会把HEAD指针直接指向ab4adf这个提交对象，然后再使用ab4adf这个提交对象的快照内容覆盖工作区的内容来达到目的(如果你细心观察的话会发现Git会提示你当前进入了HEAD游离状态)，如图3所示；<code>git reset --hard ab4adf</code>的实现就稍微复杂一些，它会操纵HEAD指针指向的对象(这里是master分支)指向ab4adf这次提交，然后再使用ab4adf这次提交中的快照内容覆盖暂存区和工作区的内容，如图4所示。<br><img src="%E6%88%AA%E5%B1%8F2021-08-03%2015.49.02.png"> 图3<br><img src="%E6%88%AA%E5%B1%8F2021-08-03%2015.49.49.png"> 图4</p></blockquote></li><li><p>Git协议的区别</p><blockquote><p>HTTP协议</p><blockquote><p>HTTP协议有2个版本，一种是哑协议(只能通过GET方式读取仓库内容)，另一种是智能协议，哑协议由于自身问题已经基本退出舞台了；相比SSH协议，HTTP协议可以使用用户名、密码授权是一个优势，就算不知道用户名和密码也可以获取项目，这很适合开源项目的推广，另一个优势就是HTTPS协议被广泛使用，一般的企业防火墙都会允许这些端口的数据通过；唯一的缺点就是在一些服务器上，架设HTTPS协议的服务端稍微棘手一些</p><blockquote><p>在使用HTTPS协议时，可能要重复输入用户名和密码，这时可以执行<code>git config --global credential.helper cache</code>命令来将用户名和密码临时缓存到内存中，可以使用<code>--timeout &lt;seconds&gt;</code>选项控制保留时长，默认是900秒(15分钟)</p></blockquote></blockquote></blockquote><blockquote><p>SSH协议</p><blockquote><p>架设SSH协议相对简单，SSH守护进程很常见，多数管理员都会使用，多数操作系统都包含它及相关的管理工具，相对于HTTPS协议它不用输入用户名和密码也更加方便；它的缺点是不支持匿名访问Git仓库，即使只是读取数据，使用者也必须通过SSH访问你的主机，所以SSH不利于开源项目</p></blockquote></blockquote><blockquote><p>Git协议</p><blockquote><p>是所有协议里传输速度最快的，因为没有加密和授权的开销；它的缺点是由于没有加密和授权，要么谁都可以克隆这个仓库，要么谁也不能，它也是最难架设的协议，还要求防火墙开放9418端口，但是企业防火墙一般都不会开放这个非标准端口。Git协议一般和其他协议(例如HTTPS)搭配使用，使用Git协议进行拉取，使用HTTPS协议进行推送。</p></blockquote></blockquote><blockquote><p>Local协议</p><blockquote><p>一般不会用到，所有没有去了解这方面的知识，有兴趣的可以自行搜索</p></blockquote></blockquote></li></ol><h4 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h4><ul><li><p><code>git help &lt;verb&gt;</code> 获取指定Git命令的帮助文档</p><blockquote><p>示例：</p><p><code>git help add</code> 获取add命令的帮助文档</p><p><code>-a</code> 列出所有的Git命令</p><p><code>-c(--config)</code> 列出所有可用的配置变量</p><p><code>git add -h</code> 简易版的帮助文档</p><blockquote><p>等价命令：</p><p>git &lt;verb&gt; –help</p><p>man git-&lt;verb&gt;  </p></blockquote></blockquote></li><li><p><code>git rm &lt;path&gt;</code> 删除指定文件</p><blockquote><p><code>--cached(--staged)</code> 从暂存区删除指定文件</p><blockquote><p>如果不小心把要忽略的文件添加到了Git仓库中，后续即使在忽略文件中声明也还是会在每次提交时提示你该文件未暂存；这时可以使用该命令从暂存区删除指定文件，该操作不会影响工作区。</p></blockquote><p><code>-n(--try-run)</code> 列出需要删除的文件  </p></blockquote></li><li><p><code>git describe &lt;commit&gt;</code> 根据指定提交对象生成一个字符串构建号。它由提交对象最近的标签名、自该标签之后的提交数目和你所描述的提交的部分哈希值构成(可以为提交附上一个可读的名称)。</p></li><li><p><code>git reflog</code> 显示所有的引用日志</p><blockquote><p>reflog的本质只是记录HEAD指针发生变化的记录，它只存在于本地仓库，一般情况下Git只会保留最近几个月(默认是90天)的记录  </p></blockquote></li><li><p><code>git reflog --date=local --all | grep &lt;分支名&gt;</code> 获取指定分支的HEAD变更记录</p><blockquote><p>可以用来查看某个分支是基于哪个分支创建的，由于reflog所以只能在创建分支的那台电脑上才能生效并且时间太长也会失效。  </p></blockquote></li><li><p><code>git clean</code> 移除那些没有被Git跟踪的文件，该命令需要搭配以下选项执行</p><blockquote><p><code>-d</code> 递归删除子目录下的文件&#x2F;文件夹</p><p><code>-f</code>如果<code>clean.requireForce</code>没有被设置为false，则必须要使用<code>-f</code>告诉Git需要删除那些文件</p><p><code>-n(--dry-run)</code> 只显示那些会被移除的文件</p><p><code>-x</code> 默认情况下不会删除被忽略的文件，-x表示将移除那些被忽略的文件</p><p><code>-X</code> 仅删除被忽略的未跟踪文件  </p></blockquote></li><li><p><code>git gc</code> 手动对Git仓库进行打包优化</p><blockquote><p><code>--aggressive</code> 加上此选项Git将会花费更多时间优化仓库</p></blockquote></li><li><p><code>git fsck</code> 验证数据库中对象的有效性</p><blockquote><p><code>--unreachable</code> 打印那些存在但无法从任何节点访问的对象  </p></blockquote></li><li><p><code>git restore</code> 恢复工作区的文件</p><blockquote><p><code>--staged &lt;path&gt;</code> 将指定文件从暂存区移除</p><p><code>-s(--source) &lt;tree_id&gt; &lt;path&gt;</code> 使用指定树中的文件恢复工作区的指定文件</p></blockquote></li><li><p><code>git clone -d &lt;分支名&gt; &lt;path&gt; --depth=&lt;number&gt;</code> 克隆指定仓库下指定分支的number条提交历史</p><blockquote><p>示例：</p><p><code>git clone -b master &lt;path&gt; --depth=1</code> 只克隆远程仓库的master分支的最近一条提交</p></blockquote></li></ul><h4 id="Git-Config"><a href="#Git-Config" class="headerlink" title="Git Config"></a>Git Config</h4><ul><li><p><code>git config --list</code> 查看Git配置信息，配置信息可能会重复，如果存在重复Git会以最后一个值为准。</p><blockquote><p><code>--show-origin</code> 显示该配置的来源(路径)</p></blockquote></li><li><p><code>git config &lt;范围&gt; &lt;选项&gt; &lt;值&gt;</code> 在指定范围内设置指定配置信息。</p><blockquote><p>示例：</p><p><code>git config --global user.name &#39;author&#39;</code> 在全局范围内设置提交者的名称。<br>Git Config总共有3个范围，分别是system、global、local(默认值)，权重依次递增，system的影响范围是最大的，针对当前电脑下的所有Git仓库都生效；global针对当前用户下的所有Git仓库生效；local只对当前Git仓库生效。  </p></blockquote></li><li><p><code>git config --global merge.conflictstyle diff3</code> 修改合并冲突样式为diff3，这种样式下会额外显示base的内容，如图5。</p><p>  <img src="%E6%88%AA%E5%B1%8F2021-08-10%2010.03.08.png"> 图5</p></li><li><p><code>git config --global help.autocorrect 50</code> 设置该选项后，当Git匹配了相似的命令时会在倒计时结束后自动执行该命令</p></li><li><p><code>git config --global core.autocrlf true</code> 启用该功能的话当你提交时Git会自动把回车和换行转换成一个换行符，而在检出代码时把一个换行符转换成回车和换行。</p><blockquote><p>在Windows的某些编辑器中，换行符是由回车符和换行符2个命令组成的，而在macOS和Linux系统中换行符只有一个符号。如果同一个项目在Windows和其他平台上开发，可能会遇到空格冲突。</p><p><code>input</code> 设置为input告诉Git在提交时把回车和换行转换成换行，检出时不转换</p></blockquote></li><li><p><code>core.whitespace</code> 空格处理方案，Git提供了6种处理多余空白字符的主要选项，3项默认开启，3项默认关闭</p><blockquote><p>默认开启：blank-at-eol(查找行尾的空格)，blank-at-eof(盯住文件底部的空行)，space-before-tab(警惕行头tab前面的空格)</p><p>默认关闭：indent-with-non-tab(揪出以空格而非tab开头的行，你可以用tabwidth选项控制它)，tab-in-indent(监视在行头表示缩进的tab)，cr-at-eol(告诉Git忽略行尾的回车)</p></blockquote></li></ul><p>如果想关闭某个选项，可以在输入设置选项时不指定它或在它前面加个 －</p><ul><li><p><code>git config &lt;范围&gt; alias.&lt;别名&gt; &#39;&lt;全名&gt;&#39;</code> 在指定范围内设置一个Git别名。</p><blockquote><p>示例：</p><p><code>git config --global alias.st &#39;status&#39;</code> 在全局范围内给status设置一个别名st。</p><p>别名通常用来简化命令，如果想给非Git命令起别名，例如gitk，可以这样设置<code>git config --global alias.gitk &#39;!gitk&#39;</code>，当你调用”git gitk”时会执行”gitk”命令。</p><blockquote><p>一些常用的别名：</p><p><code>git config --global alias.co checkout</code></p><p><code>git config --global alias.br branch</code></p><p><code>git config --global alias.ci commit</code></p><p><code>git config --global alias.st status</code></p><p><code>git config --global alias.s &#39;status -s&#39;</code></p><p><code>git config --global alias.last &#39;log -1&#39;</code>  </p></blockquote></blockquote></li><li><p><code>git config &lt;范围&gt; --unset alias.&lt;name&gt;</code> 删除指定别名</p></li></ul><h4 id="Git-Diff"><a href="#Git-Diff" class="headerlink" title="Git Diff"></a>Git Diff</h4><ul><li><p><code>git diff</code> 显示工作区和暂存区之间的差异</p><blockquote><p><code>--cached(--staged)</code> 显示暂存区和最新提交之前的差异</p><p><code>--check</code> 打印所有可能的空格错误</p><p><code>--ours</code> 冲突时查看合并引入了什么</p><p><code>--theirs -b</code> 冲突时查看合并的结果与另一边有什么不同，-b表示去除空格</p><p><code>--base</code> 冲突时查看文件在两边是如何改动的</p></blockquote></li></ul><h4 id="Git-Log"><a href="#Git-Log" class="headerlink" title="Git Log"></a>Git Log</h4><ul><li><p><code>git log</code> 显示当前分支下的提交历史</p><blockquote><p><code>-n</code> 显示指定数量的提交记录，例如<code>git log -2</code>显示最近2条提交记录</p><p><code>--show-signature</code> 显示GPG签名信息</p><p><code>--stat</code> 显示提交时的简略信息</p><p><code>--abbrev-commit</code> 显示简短的哈希值</p><p><code>--relative-date</code> 显示一个相对时间(例如 9 hours ago)</p><p><code>--graph</code> 在日志旁以ASCII图形显示分支和合并历史</p><p><code>--oneline</code> –pretty&#x3D;oneline和–abbrev-commit的缩写</p><p><code>--pretty=</code>  使用其他格式显示提交历史</p><blockquote><p><code>oneline</code> 将每条提交放在一行显示</p><p><code>short</code> 不显示提交时间</p><p><code>full</code> 不显示提交时间但额外显示提交者信息</p><p><code>fuller</code> 显示提交者信息以及提交时间</p><p><code>format</code> 自定义显示风格(自定义风格可以不受Git版本影响)</p><blockquote><p>示例：</p><p><code>git log --pretty=format:&quot;%Cred%h%Creset - %C(yellow)%an%Creset, %C(green)%ar%Creset : %s&quot;</code> 一行显示简写的提交哈希值 - 作者名称, 提交相对时间 : 提交说明。</p><p>format可接受的选项如下：</p><p><code>%H</code> 提交的完整哈希值</p><p><code>%h</code> 提交的简写哈希值</p><p><code>%T</code> 树的完整哈希值</p><p><code>%t</code> 树的简写哈希值</p><p><code>%P</code> 父提交的完整哈希值</p><p><code>%p</code> 父提交的简写哈希值</p><p><code>%an</code> 作者的名称</p><p><code>%ae</code> 作者的电子邮件地址</p><p><code>%ad</code> 作者的修订日期</p><p><code>%ar</code> 作者的修订日期，按多久以前的方式显示，例如20 hours ago</p><p><code>%cn</code> 提交者的名称</p><p><code>%ce</code> 提交者的电子邮件地址</p><p><code>%cd</code> 提交日期</p><p><code>%cr</code> 提交日期，按多久以前的方式显示</p><p><code>%s</code> 提交说明</p><p>Git支持的颜色选项：</p><p>normal、black、red、green、yellow、blue、magenta、cyan、white</p><p>Git支持的字体属性</p><p>bold、dim、ul、blink、reverse</p></blockquote></blockquote><p><code>--author</code> 显示和指定作者的提交记录</p><p><code>--committer</code> 显示和指定提交者的提交记录</p><p><code>--grep</code> 显示提交说明中包含指定字符串的提交记录</p><p><code>-S</code> 显示对指定字符串进行了修改的提交记录(常用来查找某个函数的修改提交记录)</p><p><code>-G &lt;正则表达式&gt;</code> 使用正则查找相关的提交记录</p><p><code>-- &lt;path&gt;</code> 显示指定路径下的修改记录(常用来和其他选项搭配查找某个文件下某个函数的修改提交记录，一般写在最后)</p><p><code>-L</code> 显示指定文件中指定函数的相关修改提交记录</p><blockquote><p>示例：</p><p><code>git log -L :firstApplication:WXReader/AppDelegate.m</code> 显示AppDelegate.m文件下与firstApplication相关的修改提交</p></blockquote><p><code>--no-merges</code> 不显示合并提交</p><p><code>--after(--since)</code> 显示指定时间之后的提交记录</p><p><code>--before(--until)</code> 显示指定时间之前的提交记录</p><blockquote><p><code>--after</code>和<code>--before</code>可以搭配指定的时间值，例如”2008-08-08”，也可以是”2 years 1 day 3 minutes ago”、”2.weeaks”这样的相对日期</p><p>示例：</p><p><code>git log --author=&#39;internetwei&#39; --after=&quot;2020-01-01&quot; --before=&quot;2020-06-01&quot; --no-merges -- WXReader/Book/BookRack/BookReader</code> 显示作者internetwei在2020年1月1号到2020年6月1号之间对<code>WXReader/Book/BookRack/BookReader</code>这个文件夹(包括文件夹下所有的文件)有关的所有修改提交但不包括合并提交</p></blockquote><p><code>&lt;分支1&gt;..&lt;分支2&gt;</code> 显示分支2有但分支1没有的提交记录(常用来检查分支哪些提交未推送)</p><blockquote><p>和..语法等价的命令：</p><p><code>git log ^&lt;分支1&gt; &lt;分支2&gt;</code></p><p><code>git log &lt;分支2&gt; --not &lt;分支1&gt;</code></p><p>上面两种命令是..语法的扩展，除了查询2个引用，还支持查询超过2个引用，例如<code>git log refA refB ^refC</code>表示显示所有被<code>refA</code>或<code>refB</code>包含但不被<code>refC</code>包含的提交记录</p></blockquote><p><code>&lt;分支1&gt;...&lt;分支2&gt;</code> 显示分支1和分支2不共有的提交</p><blockquote><p><code>--left-right</code> 和…等类似语法搭配使用，可以用&lt;、&gt;表示左右分支  </p></blockquote></blockquote></li><li><p><code>git shortlog</code> 显示当前分支的修改日志文档</p><blockquote><p>示例：</p><p><code>git shortlog --no-merges master --not v1.0</code> 显示master分支从v1.0标签后的所有非合并提交提交日志</p></blockquote></li></ul><h4 id="Git-Rebase"><a href="#Git-Rebase" class="headerlink" title="Git Rebase"></a>Git Rebase</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Merge和Rebase的区别：</span><br><span class="line"></span><br><span class="line">在Git中用来整合不同分支的修改有两种办法，一种是merge，另一种是rebase，这两种方案最终的结果没有任何区别，只不过提交历史不一样罢了，Rebase是将一系列的提交按照原有次序依次应用到另一个分支上，这样做可以使提交历史更加整洁；而合并是把最终结果合在一起。</span><br><span class="line"></span><br><span class="line">提取某次提交中引入的补丁和修改，然后在当前分支的基础上应用一次，这种操作就叫做rebase。</span><br><span class="line"></span><br><span class="line">rebase后的提交历史如图6，merge提交历史如图7，同样的提交，使用merge和rebase的区别一目了然。</span><br><span class="line"></span><br><span class="line">你可以自由选择`rebase`或`merge`，不过如果你选择`rebase`的话，请记住只对尚未推送或分享给别人的提交进行`rebase`操作。</span><br></pre></td></tr></table></figure><p><img src="%E6%88%AA%E5%B1%8F2021-08-03%2010.45.35.png"> 图6</p><p><img src="%E6%88%AA%E5%B1%8F2021-08-03%2010.49.53.png"> 图7</p><ul><li><p><code>git rebase &lt;分支&gt;</code> 将当前分支上的提交依次变基到目标分支上</p></li><li><p><code>git rebase &lt;分支1&gt; &lt;分支2&gt;</code> 将分支2上的提交依次变基到分支1上</p><blockquote><p>示例：</p><p><code>git rebase master experiment</code> 将experiment分支上的提交内容依次变基到master分支上，如图8</p><p><img src="0b1bc478bd2f48d5a25d5b886ec99f8d~tplv-k3u1fbpfcp-zoom-1.image"> 图8</p><p>切换到master分支再合并experiment分支就不会有分叉的提交历史了，如图9</p><p><img src="6518e127a0e446b8b790c21f620f7c26~tplv-k3u1fbpfcp-zoom-1.image"> 图9</p><blockquote><p>rebase的原理：</p><ol><li><p>首先找到这2个分支的最近共同祖先C2</p></li><li><p>然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件</p></li><li><p>然后将当前分支指向目标基底C3</p></li><li><p>最后以此将之前保存的临时文件的修改依次应用</p></li></ol></blockquote></blockquote></li><li><p><code>git rebase --onto &lt;分支1&gt; &lt;分支2&gt; &lt;分支3&gt;</code> 找到分支3在分支2分歧后的提交，然后把这些提交在分支1上依次应用一遍</p><blockquote><p>示例：</p><p><code>git rebase --onto master server client</code> 找到client分支，找出它从server分支分歧之后的提交，然后把这些提交在master分支上重放一遍，如图10所示</p></blockquote><p>  <img src="567d0c68f2854ef08fa29313a8ecaee7~tplv-k3u1fbpfcp-zoom-1.image"> 图10</p></li><li><p><code>git rebase -i &lt;区间&gt;</code> 对指定区间内的提交进行交互式变基</p><blockquote><p>示例：</p><p><code>git rebase -i HEAD~2</code> 对最近3次提交进行交互式变基，交互式变基的功能非常强大，可以实现“将任意提交压缩成一个提交”、“将一个提交拆成多个提交”、“修改任意提交的提交说明”、“重新排序”、“移除提交”等功能</p></blockquote></li><li><p><code>git commit --amend</code> 修改最新的提交信息</p><blockquote><p>虽然它是commit开头的命令，不过它的本质就是rebase操作，所以把它放在rebase里</p><p>该命令有2个作用：</p><ol><li><p>修改最新的提交说明；确保当前暂存区是干净的，然后运行此命令，它会将你带到提交说明编辑框，重新编辑提交信息然后保存退出即可。</p></li><li><p>补充提交文件；例如上次提交时忘记添加一个文件，或者上次提交的文件又有修改了，而这次修改应该和上次提交是一起的；首先将需要补充提交的文件添加到暂存区，确保暂存区的文件是你要补充提交的，然后运行此命令，编辑提交信息保存退出即可。</p></li></ol></blockquote></li><li><p><code>git cherry-pick &lt;commit&gt;</code> 将指定提交的修改在当前分支的基础上重放一遍并提交</p></li></ul><h4 id="Git-Remote"><a href="#Git-Remote" class="headerlink" title="Git Remote"></a>Git Remote</h4><ul><li><p><code>git remote</code> 显示所有远程仓库的名称</p><blockquote><p><code>-v</code> 显示远程仓库的具体信息</p><p><code>show &lt;仓库名&gt;</code> 显示指定远程仓库的详细信息</p><p><code>ls-remote &lt;仓库名&gt;</code> 显示指定远程仓库的完整引用列表</p><p><code>prune &lt;仓库名&gt;</code> 删除本地镜像仓库存在但远程已删除的分支信息</p><p><code>git remote set-url &lt;仓库名&gt; &lt;url&gt;</code> 修改指定仓库的地址  </p></blockquote></li><li><p><code>git fetch &lt;仓库名&gt;</code> 拉取指定仓库的信息并更新本地的仓库信息(这只会更新本地的远程镜像仓库，不会修改本地分支和工作区内容)</p></li><li><p><code>git pull</code> 拉取上游分支的新提交并合并，它是<code>fetch</code>和<code>merge</code>2个命令的缩写</p><blockquote><p>pull 命令需要该分支拥有上游分支，如果没有上游分支会提示错误信息，它会运行<code>git fetch</code>将远程仓库的信息拉取下来，然后运行<code>git merge</code>合并远程的提交</p></blockquote></li><li><p><code>git branch -u(--set-upstream-to) &lt;远程分支引用&gt;</code> 设置&#x2F;修改当前分支的上游分支引用</p><blockquote><p><code>git branch -u origin/dev</code> 设置&#x2F;修改当前分支的上游分支为origin仓库的dev分支</p><p>当某个分支拥有上游分支后，可以使用{u(upstream)}代替上游分支</p></blockquote></li><li><p><code>git push</code> 将当前分支的新提交推送到上游分支</p><blockquote><p><code>git push origin refs/head/dev:refs/head/dev</code> 这是推送命令的全称，将本地dev分支推送到远程dev分支上</p><p><code>git push origin v1.0</code> 推送指定标签到远程仓库(默认推送并不会推送标签)</p><p><code>git push origin --tags</code> 推送所有标签到远程仓库</p><p><code>git push origin --delete dev</code> 删除远程仓库的dev分支</p><p><code>git push origin --delete v1.0</code> 删除远程仓库的v1.0分支</p><p><code>git push origin --delete</code>命令实际是<code>git push origin :refs/head/dev</code>，推送一个空对象覆盖远程仓库的dev分支(这么做只是从服务器上移除一个指针，Git通常会将数据保存一段时间直到垃圾回收机制运行。</p></blockquote></li></ul><h4 id="Git-Tag"><a href="#Git-Tag" class="headerlink" title="Git Tag"></a>Git Tag</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tag和Branch的区别：</span><br><span class="line"></span><br><span class="line">相同点：都是一个指向commit对象的指针</span><br><span class="line"></span><br><span class="line">不同点：Tag的位置是固定的，永远指向一个具体的commit对象。而Branch会随着分支的提交或回滚变化位置。</span><br><span class="line"></span><br><span class="line">轻量Tag和附注Tag的区别：</span><br><span class="line"></span><br><span class="line">轻量Tag就像一个不会改变的分支，它只是某个特定提交的引用；而附注Tag则是一个完整的Git对象，它包含打标签者的相关信息、打标签的时间、打标签的说明，还支持GPG签名和验证。</span><br></pre></td></tr></table></figure><ul><li><p><code>git tag &lt;标签名&gt;</code> 给当前提交创建一个轻量Tag</p><blockquote><p><code>-a</code> 创建一个附注Tag</p><p><code>&lt;hash&gt;</code> 尾随一个哈希值，可以给指定提交创建Tag</p><p><code>-s</code> 使用GPG对标签进行签名</p><p><code>-l(--list) &quot;v1.*&quot;</code> 显示所有以”v1.”开头的标签，支持正则匹配</p><p><code>-v</code> 使用GPG验证签名(前提是签名者的公钥需要在你的钥匙链中)</p></blockquote></li></ul><h4 id="Git-Branch"><a href="#Git-Branch" class="headerlink" title="Git Branch"></a>Git Branch</h4><ul><li><p><code>git branch</code> 显示所有本地分支</p><blockquote><p><code>-v</code> 显示分支对应的最新提交</p><p><code>-vv</code> 显示分支与上游分支的落后&#x2F;领先情况</p><p><code>-merged</code> 显示与当前分支已合并的分支</p><p><code>--no-merged</code> 显示与当前分支未合并的分支</p></blockquote></li></ul><h4 id="Git-Merge"><a href="#Git-Merge" class="headerlink" title="Git Merge"></a>Git Merge</h4><ul><li><p><code>git merge &lt;分支名&gt;</code> 合并指定分支</p><blockquote><p><code>--squash</code> 将合并产生的多个提交压缩成一个提交</p><p><code>--verify-signature</code> 拒绝合并那些GPG签名验证不通过的提交</p><p><code>-Xignore-space-change</code> 将一个空白符与多个连续的空白字符视作等价</p><p><code>-Xignore-all-space</code> 合并时完全忽略空白修改</p><p><code>-Xours</code> 遇到冲突时保留当前分支的修改内容</p><p><code>-Xtheirs</code> 遇到冲突时保留目标分支的修改内容  </p></blockquote></li><li><p><code>git merge-base &lt;分支1&gt; &lt;分支2&gt;</code> 获取2个分支最近的公共提交</p></li><li><p><code>git merge --verity-signature -S &lt;分支名&gt;</code> 生成一个签名的合并提交</p></li><li><p><code>git merge -s ours &lt;分支名&gt;</code> 做一次假的合并，记录一个以两边分支作为父结点的新合并提交，但是它甚至根本不关注你正合并入的分支，它只会简单地把当前分支的代码当作合并结果记录下来</p><blockquote><p>假如你有一个分叉的release分支并且在上面做了一些你想要在未来某个时候合并回master的工作，与此同时master分支上的某些bugfix需要向后移植回release分支，你可以合并bugfix分支进入release分支同时也merge -s ours 合并进入你的master分支(即使那个修复已经在那里了)这样当你之后再次合并release分支时，就不会有来自bugfix的冲突。</p></blockquote></li></ul><h4 id="Git-邮箱工作"><a href="#Git-邮箱工作" class="headerlink" title="Git 邮箱工作"></a>Git 邮箱工作</h4><ul><li><p><code>git format-patch -M &lt;分支名&gt;</code> 生成当前分支和指定分支之间不共有的提交补丁文件到根目录下(有几个提交就会生成几个补丁文件)</p><blockquote><p>示例：</p><p><code>git format-patch -M origin/master</code> 生成当前分支和origin&#x2F;master分支之间不共有的提交补丁文件到根目录下(这会生成一份可以邮寄的mbox格式的文件，它将每一个提交转换为一封电子邮件)。<code>-M</code>表示允许Git检查是否有对文件重命名的提交</p></blockquote></li><li><p><code>git apply --check &lt;path&gt;</code> 检查指定路径下的补丁内容是否可以被应用</p></li><li><p><code>git apply &lt;path&gt;</code> 应用指定路径下的补丁内容</p></li><li><p><code>git am &lt;path&gt;</code> 和<code>git apply</code>功能类似，不过比它更智能</p><blockquote><p><code>--resolved</code> 继续应用下一个补丁</p><p><code>-3</code> 表示当应用补丁发生冲突时Git会尝试进行三方合并，该选项默认是关闭的</p><p><code>am</code>的含义：应用(Apply)一系列来自邮箱(Mailbox)的补丁</p><p><code>git apply</code>用于应用<code>git diff</code>或<code>Unix diff</code>命令创建的补丁，它和<code>patch -p1</code>命令几乎是等效的，但是<code>git apply</code>更加严格，相对于<code>patch</code>来说它能够接受的模糊匹配更少，<code>git apply</code>采用了一种”要么全部应用，要么就全部撤销”的模型，即补丁只有全部内容都被应用和全部不被应用两种状态，如果补丁是用<code>git format-patch</code>来创建的，那么建议使用<code>git am</code>来应用补丁，只有对老式的补丁，你才必须使用<code>git apply</code></p></blockquote></li></ul><h4 id="Git-Rerere"><a href="#Git-Rerere" class="headerlink" title="Git Rerere"></a>Git Rerere</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Rerere是“重用已记录的冲突解决方案”的意思，它是一种简化冲突解决的方法，当启动rerere时，Git会维护一些成功合并之前和之后的镜像，当Git发现之前已经修复过类似的冲突时，便会使用之前的修复方案而不需要你的干预</span><br></pre></td></tr></table></figure><ul><li><p><code>git config --global rerere.enabled true</code> 启用Rerere功能</p><blockquote><p>对于已经创建的仓库如果想启动Rerere功能，需要手动在.git文件夹下创建一个rr-cache文件夹</p><p>开启Rerere后会增加本地仓库的体积，rr-cache文件夹只存在于本地仓库，不会推送到远程  </p></blockquote></li><li><p><code>git checkout --conflict=merge &lt;path&gt;</code> 将指定文件恢复到Rerere执行前的状态</p></li></ul><h4 id="Git-归档"><a href="#Git-归档" class="headerlink" title="Git 归档"></a>Git 归档</h4><ul><li><p><code>git archive &lt;commit&gt; --prefix=&#39;&lt;解压后的文件名&gt;/&#39; | gzip &gt; &lt;压缩包的名称&gt;.tar.gz</code> 基于指定提交对象创建一个当前所有快照内容的压缩文件</p><blockquote><p>示例：</p><p><code>git archive master --prefix=&#39;project/&#39; &gt; gzip &gt; master.tar.gz</code> 基于master最新提交的所有快照内容创建一个tar.gz压缩文件</p><p>git archive master –prefix&#x3D;’project&#x2F;‘ –format&#x3D;zip &gt; `git describe master`.zip 基于master最新提交的所有快照内容创建一个zip压缩文件  </p></blockquote></li><li><p><code>git bundle</code> 对分支进行打包</p><blockquote><p>示例：</p><p><code>git bundle create repo.bundle HEAD master</code> 对master分支的所有提交历史进行打包  </p></blockquote></li><li><p><code>git bundle verify &lt;path&gt;</code> 检查指定bundle包是否合法</p></li><li><p><code>git bundle list-heads &lt;path&gt;</code> 列出指定bundle包的引用</p></li></ul><h4 id="Git-Stash"><a href="#Git-Stash" class="headerlink" title="Git Stash"></a>Git Stash</h4><ul><li><p><code>git stash</code> 贮藏所有已跟踪的未提交文件，并还原暂存区和工作区的修改变化</p><blockquote><p><code>-u(--include-untracked)</code> 贮藏所有已跟踪和未跟踪的文件(不包括忽略文件)</p><p><code>-a(--all)</code> 贮藏所有文件(包括忽略文件)</p><p><code>--keep-index</code> 保存到贮藏的同时不清空暂存区的内容</p><p><code>list</code> 查看所有贮藏文件列表</p><p><code>apply</code> 恢复最新的贮藏文件但不删除，可以指定某个贮藏文件</p><p><code>pop</code> 和apply命令一样但是会自动删除贮藏文件(仅在恢复成功时自动删除)</p><p><code>--index</code> 如果在<code>pop</code>和<code>apply</code>时加上此选项会把贮藏前在暂存区的内容重新加到暂存区中，默认全部恢复在工作区  </p></blockquote></li><li><p><code>git stash &lt;贮藏文件&gt; &lt;分支名&gt;</code> 使用指定贮藏文件创建一个分支</p></li></ul><h4 id="Git-Add"><a href="#Git-Add" class="headerlink" title="Git Add"></a>Git Add</h4><ul><li><p><code>git add</code> 将文件加入到暂存区中</p><blockquote><p><code>-i(--interactive)</code> 使用交互式终端模式进行暂存</p><p><code>-p(--patch)</code> 自定义暂存补丁文件(该命令只是-i的一个子命令)</p></blockquote></li></ul><h4 id="Git-Commit"><a href="#Git-Commit" class="headerlink" title="Git Commit"></a>Git Commit</h4><ul><li><p><code>git commit</code> 将暂存区的文件提交到Git仓库</p><blockquote><p><code>-S</code> 使用GPG签名此次提交</p><p><code>-m &quot;注释&quot;</code> 使用指定注释作为提交内容</p><p><code>-a</code> 将已跟踪的所有文件加入到暂存区(未跟踪的文件不会加入到暂存区)</p><p><code>-am</code> -a和-m这2个命令的缩写</p></blockquote></li></ul><h4 id="Git-搜索"><a href="#Git-搜索" class="headerlink" title="Git 搜索"></a>Git 搜索</h4><ul><li><p><code>git grep &lt;字符串&gt;</code> 在工作区中搜索指定字符串出现的所有位置</p><blockquote><p>示例：</p><p><code>git grep --break --heading -n -e &#39;#define&#39; --and \( -e kEncryptionSecret -e kEncryptionKey \) v4.6.0</code> 查看在v4.6.0标签的Git代码库中定义了常量名包含”kEncryptionSecret”或”kEncryptionKey”这两个字符串的位置</p><p><code>-n(--line-number)</code> 显示在文件中的行数</p><p><code>-c(--count)</code> 显示在文件中匹配的数量</p><p><code>-p(--show-function)</code> 显示该字符串上下文内容</p></blockquote></li></ul><h4 id="Git-Subtree"><a href="#Git-Subtree" class="headerlink" title="Git Subtree"></a>Git Subtree</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这里没有提到 git submodule(子模块)，因为使用子模块相比Subtree更麻烦，例如在有子模块的仓库中切换分支需要重新初始化一下子模块，git subtree可以实现git submodule的功能，并且比git submodule更简单。</span><br></pre></td></tr></table></figure><ul><li><p><code>git subtree add --prefix=&lt;path&gt; &lt;link&gt; &lt;分支名&gt;</code> 添加指定仓库下的指定分支内容到指定路径下</p><blockquote><p>示例：</p><p><code>git subtree add --prefix=sub/libpng &lt;link&gt; master</code> 拉取指定仓库下master分支到sub&#x2F;libpng文件夹下  </p></blockquote></li><li><p><code>git subtree pull --prefix=&lt;path&gt; &lt;link&gt; &lt;分支名&gt;</code> 拉取子树的修改提交</p></li><li><p><code>git subtree push --prefix=&lt;path&gt; &lt;link&gt; &lt;分支名&gt;</code> 推送子树的修改提交</p></li></ul><h4 id="Git-Filter"><a href="#Git-Filter" class="headerlink" title="Git Filter"></a>Git Filter</h4><ul><li><p><code>git filter-branch</code> 重写提交历史</p><blockquote><p>示例：</p><p><code>git filter-branch --tree-filter &#39;rm -f password.txt&#39; HEAD</code> 从Git仓库中删除password.txt，–tree-filter表示检出项目的每一个提交后运行指定的命令然后重新提交结果，如果要让上述命令在所有分支上运行，可以加上–all</p><p><code>git filter-branch --subdirectory-filter trunk HEAD</code> 将trunk子目录设置为项目的根目录，Git会自动移除所有不影响子目录的提交</p></blockquote>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git filter-branch --commit-filter &#x27;</span><br><span class="line">if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;internetwei@foxmail.com&quot; ];</span><br><span class="line">then</span><br><span class="line">        GIT_AUTHOR_NAME=&quot;Scott Chacon&quot;;</span><br><span class="line">        GIT_AUTHOR_EMAIL=&quot;schacon@example.com&quot;;</span><br><span class="line">        git commit-tree &quot;$@&quot;;</span><br><span class="line">else</span><br><span class="line">        git commit-tree &quot;$@&quot;;</span><br><span class="line">fi&#x27; HEAD </span><br><span class="line"></span><br><span class="line">遍历所有提交，如果作者邮件地址是internetwei@foxmail.com则修改作者名称和邮件地址(即使某个提交不用修改但是它的哈希值也会更改)</span><br></pre></td></tr></table></figure></li><li><p><code>git filter-repo</code> 重写提交历史</p><blockquote><p>Git官方建议使用git filter-repo而不是git filter-branch，因为git filter-branch在重写提交历史时充满大量的陷阱，性能也很低，它的设计架构在接口的每一层都存在泄漏，这使得它几乎不可能在不向后兼容的情况下更改设计的任何内容。相比较而言git filter-repo的功能更多，而且性能也高出很多(有资料说用git filter-repo几个小时完成的任务用git filter-branch需要等待3个月)。</p><p><code>git filter-repo --path-rename &lt;old_name:new_name&gt;</code> 遍历提交历史，将作者名从old_name修改为new_name</p><p><code>--tag-rename &lt;old_tag:new_tag&gt;</code> 遍历提交历史，重命名以old开头的标签并以new开头，例如<code>--tag-rename foo:bar</code>会将foo-1.2改为bar-1.2</p><p>想学习git filter-repo请查看<a href="https://htmlpreview.github.io/?https://github.com/newren/git-filter-repo/blob/docs/html/git-filter-repo.html">git filter-repo命令手册</a></p></blockquote></li></ul><h4 id="Git-Show"><a href="#Git-Show" class="headerlink" title="Git Show"></a>Git Show</h4><ul><li><p><code>git show &lt;分支名&gt;@&#123;yesterday&#125;</code> 查看指定分支在昨天的最后一次提交对象</p><blockquote><p>yesterday可以是其他任意Git可以识别的时间  </p></blockquote></li><li><p><code>git show &lt;commit&gt;:&lt;path&gt;</code> 查看指定提交下指定文件的内容</p></li></ul><h4 id="Git-Reset"><a href="#Git-Reset" class="headerlink" title="Git Reset"></a>Git Reset</h4><ul><li><p><code>git reset --soft &lt;commit&gt;</code> 将当前分支移动到指定提交上(这样做会导致Git仓库和暂存区与工作区的内容不一致，而暂存区和工作区的内容一致，所以Git会提示你进行commit操作和Git仓库保持一致)，如图11。</p><p>   <img src="646fd8d8cf5941a1a2a3bbd2c140423c~tplv-k3u1fbpfcp-zoom-1.image"> 图11</p></li><li><p><code>git reset --mixed &lt;commit&gt;</code> 默认行为，将当前分支移动到指定提交上并且更新暂存区的内容(这样做会导致Git仓库和暂存区的内容一致，但是和工作区的内容不一致，这时Git会提交你进行add操作将需要提交的文件添加到暂存区)，如图12</p><p>   <img src="aefb6b8501144712b39ccb51ad152e54~tplv-k3u1fbpfcp-zoom-1.image"> 图12</p></li><li><p><code>git reset --hard &lt;commit&gt;</code> 将当前分支移动到指定提交上并且更新暂存区和工作区的内容，这也是reset唯一危险的命令(这样做Git会使用版本库中的内容更新(覆盖)暂存区和工作区的内容)，如图13</p><p>   <img src="63c1aeeafb13499885b805f05815048a~tplv-k3u1fbpfcp-zoom-1.image"> 图13</p></li><li><p><code>git reset &lt;path&gt;</code> 将指定文件从暂存区中删除</p><blockquote><p>它本质上调用的是<code>git reset --mixed HEAD &lt;path&gt;</code>命令，使用版本库中的指定文件覆盖暂存区的文件，所以它可以将文件从暂存区中移除</p></blockquote></li></ul><h4 id="Git-Checkout"><a href="#Git-Checkout" class="headerlink" title="Git Checkout"></a>Git Checkout</h4><ul><li><p><code>git checkout -b &lt;分支名&gt;</code> 创建并切换到指定分支</p><blockquote><p>该命令其实是<code>git branch &lt;分支名&gt;</code>和<code>git checkout &lt;分支名&gt;</code>的缩写</p><p>切换分支建议使用<code>git switch &lt;分支名&gt;</code>，一是因为switch比checkout更容易理解，二是因为switch命令比checkout命令更安全(例如本地有一个文件名和某一个分支同名，当你使用git checkout &lt;文件&#x2F;分支名&gt; 时可能会不小心覆盖工作区的内容)</p></blockquote></li><li><p><code>git checkout -- &lt;path&gt;</code> 撤销工作区指定文件的修改</p><blockquote><p>该命令会使用当前版本库中的指定文件覆盖工作区的指定文件，如果工作区的文件有任何修改将会丢失</p></blockquote></li></ul><h4 id="Git-Revert"><a href="#Git-Revert" class="headerlink" title="Git Revert"></a>Git Revert</h4><ul><li><p><code>git revert &lt;commit&gt;</code> 还原指定提交的内容</p><blockquote><p>该命令用于将某次提交的内容重置并生成一次新提交</p></blockquote></li></ul><h4 id="Git-Blame"><a href="#Git-Blame" class="headerlink" title="Git Blame"></a>Git Blame</h4><ul><li><p><code>git blame -L &lt;range&gt; &lt;path&gt;</code> 查看指定文件中指定范围内的修改提交记录</p><blockquote><p>示例：</p><p><code>git blame -L 68,100 WXYZ_BookReaderViewController.m</code> 查看WXYZ_BookReaderViewController.m文件有关第68到100行的修改提交记录</p><p><code>-C</code> 该选项表示Git会分析你正在标注的文件，并且尝试找出文件中代码片段的原始出处</p></blockquote></li></ul><h4 id="Git-Bisect"><a href="#Git-Bisect" class="headerlink" title="Git Bisect"></a>Git Bisect</h4><ul><li><p><code>git bisect</code> 使用二分搜索查找引入错误的提交</p><blockquote><p>使用流程：</p><p><code>git bisect start</code> 启动二分查找</p><p><code>git bisect bad</code> 告诉Git当前提交是有问题的</p><p><code>git bisect good &lt;commit&gt;</code> 告诉Git没有问题的提交是哪一次</p><p><code>git bisect good</code> 告诉Git当前提交没有问题</p><p><code>git bisect reset</code> 结束二分查找</p><p><code>git biesect start &lt;bad_id&gt; &lt;good_id&gt;</code> 快速执行二分查找，第一个参数是不正常的提交，第二个参数是正常的提交</p><p><code>git bisect run &lt;path&gt;</code> 执行脚本进行二分查找</p></blockquote></li></ul><h4 id="Git-Replace"><a href="#Git-Replace" class="headerlink" title="Git Replace"></a>Git Replace</h4><ul><li><p><code>git replace</code> 替换指定对象</p><blockquote><p><code>git replace &lt;commit1&gt; &lt;commit2&gt;</code> 将commit1替换为commit2</p></blockquote></li></ul><h4 id="Git-底层命令"><a href="#Git-底层命令" class="headerlink" title="Git 底层命令"></a>Git 底层命令</h4><ul><li><p><code>git ls-files</code> 显示有关索引和工作树中文件的信息</p><blockquote><p><code>-u(--unmerged)</code> 显示冲突对象的哈希值</p><p><code>-s(--stage)</code> 显示暂存区当前状态  </p></blockquote></li><li><p><code>git rev-list</code> 按时间倒序列出提交对象</p><blockquote><p><code>--count &lt;分支名&gt;</code> 查看指定分支的提交数量  </p></blockquote></li><li><p><code>git cat-file</code> 查看指定对象的内容或类型和大小信息</p><blockquote><p><code>-p</code> 获取指定对象的内容或类型信息</p><p><code>-t</code> 获取指定对象的类型</p><p><code>-s</code> 获取指定对象的大小  </p></blockquote></li><li><p><code>git ls-tree</code> 列出树对象的内容</p><blockquote><p><code>-r</code> 递归子树对象下的内容  </p></blockquote></li><li><p><code>git update-ref</code> 更新存储在ref中的对象名称</p><blockquote><p>示例：</p><p><code>git update-ref refs/tags/v1.0 c7cfb9</code> 给指定提交对象添加一个轻量标签  </p></blockquote></li><li><p><code>git count-objects -v</code> 查看仓库的详细占用空间</p></li><li><p><code>git for-each-ref</code> 显示所有的引用</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ObjC 风格指南</title>
      <link href="/2021/08/07/iOS/ObjC%20%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/"/>
      <url>/2021/08/07/iOS/ObjC%20%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由 布多(budo) 发布于 2023-10-26 • 最后更新于 2023-10-29</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>制定风格指南主要的目的是统一团队的代码风格与样式，提高工作效率与阅读性还有维护性；<br>这篇文章虽然是OC风格指南，但是有些风格是所有编程语言通用的，另外它还参考了<a href="https://github.com/alibaba/Alibaba-Java-Coding-Guidelines">阿里巴巴Java代码规范</a>，想不到吧。</p><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><h3 id="优化阅读体验，而非写代码的体验"><a href="#优化阅读体验，而非写代码的体验" class="headerlink" title="优化阅读体验，而非写代码的体验"></a>优化阅读体验，而非写代码的体验</h3><p>&nbsp;&nbsp;&nbsp; 代码库通常具有较长的生命周期，并且花在阅读代码上的时间也远多于编写代码的时间。所以我们应该明确一个目标：去优化别人阅读、维护我们代码时的体验，而不是优化写代码时的体验(<code>例如随便使用缩写进行编码，代码量变少了，但是增加了阅读和维护的难度</code>)。</p><p>&nbsp;&nbsp;&nbsp; 适当的规范限制和标准不是消灭代码内容的创造性、优雅性，而是限制过度个性化，以一种普遍认可的方式一起做事，进而提高工作效率，降低沟通成本。提高稳定性。</p><h3 id="与上下文尽量保持一致"><a href="#与上下文尽量保持一致" class="headerlink" title="与上下文尽量保持一致"></a>与上下文尽量保持一致</h3><p>&nbsp;&nbsp;&nbsp; 尽量保持代码库中的风格样式一致。在整个代码库中始终保持一种风格可以让工程师更专注于其他(更重要的)问题。一致性还可以实现更好的自动化。</p><p>&nbsp;&nbsp;&nbsp; 如果风格指南中没有说明，那么就按照代码库之前的风格样式或者参考 <code>Apple SDK</code> 的风格样式。</p><h2 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h2><h3 id="通用命名风格"><a href="#通用命名风格" class="headerlink" title="通用命名风格"></a>通用命名风格</h3><ul><li><p><strong>[必须]</strong> 清晰和简洁(<code>好的名称应该是能自我描述的</code>)，简洁的原则是为了保持更好的清晰度和可读性，记住 <strong>不要本末倒置</strong>。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">// 移除一个对象。</span><br><span class="line">1. removeObject:</span><br><span class="line">// 使用指定字符串替换出现过的字符串。</span><br><span class="line">2. stringByReplacingOccurrencesOfString: withString:</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">// 要移除什么？</span><br><span class="line">1. remove:</span><br><span class="line">// 要将什么替换成什么？是全部都替换还是只替换第一个匹配的位置？</span><br><span class="line">2. replace(&quot;1&quot;, &quot;2&quot;)</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 一致性：命名应该和上下文乃至全局保持一致性，相同类型或者具有相同作用方法的名称应该相同或类似。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">1. NSDictionary、NSArray、NSSet这些类中名叫 count 的方法所体现的作用都是一样的。</span><br><span class="line">2. 系统的一些代理方法和通知的名称也会刻意保持一致，</span><br><span class="line">   例如 `UIApplicationDelegate`协议中的 `applicationDidBecomeActive` 方法名</span><br><span class="line">   就和 `UIApplicationDidBecomeActiveNotification`通知的名称是一致的。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 禁止自我指涉：命名不要自我指涉(通知、掩码或常量等除外)。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">NSString</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">NSStringObject</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 禁止过度缩写和自创缩写，一些通用缩写名除外(例如ATM、GPS、max、min等)，具体请参考 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/APIAbbreviations.html#//apple_ref/doc/uid/20001285-BCIHCGAE">可接受的缩写词列表</a>。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">阅读者可能来自不同的地方接受不同的教育和不同的文化，</span><br><span class="line">他们不一定会明白你写的缩写的意思。</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line">setBackgroundColor</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">setBgColor</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 禁止使用无意义的拼音，国际通用名、地名、人名除外。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">Beijing、Alibaba</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">// 打折</span><br><span class="line">DaZhePromotion</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 代码和注释中避免使用任何语言的种族歧视性词语。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">secondary、main</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">slave、master</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 禁止以new、alloc、copy、mutableCopy等关键字作为名称的开始部分。</p></li><li><p><strong>[必须]</strong> 由于 <strong>OC</strong> 没有命名空间的概念，所以全局名称(<code>类名、协议名、全局常量名、全局变量名、函数名、typedef名称</code>)必须添加前缀，前缀由3个及以上字符组成且全部大写。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips: </span><br><span class="line">由于系统保留任意两个字符作为前缀的使用权(NS、UI、CG、CF、CA、WK、MK、CI、NC等等)，</span><br><span class="line">为了避免和系统命名冲突，所以前缀至少由3个字符组成。</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line">ZTYLoginViewController</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">ZTLoginViewController</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 如果某个全局名称(<code>例如函数名、通知名、协议方法名</code>)和某个类有所关联，那么请使用相关类名作为其前缀，否则请使用通用前缀。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">UIApplicationDidBecomeActiveNotification</span><br><span class="line">MAGUserLoginSuccessNotification</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 命名风格统一使用 <strong>驼峰命名方式</strong> ，局部变量名等特殊名称可以不遵守。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">totalRemain</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">total_remain</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 成员变量名称必须以_作为开始部分。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">_nameString</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">nameString</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 在给常量或变量命名时，请将表示类型的名词放在词尾，以提高辨识度。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">nameLabel、nameString</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">name</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 如果模块、接口、类、方法使用了某种模式，在命名时尽量体现出具体模式。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">OrderFactory、LoginProxy</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 建议给临时变量名称添加前缀，以提高辨识度(<code>特殊情况除外，例如for循环里面的i</code>)。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">// t表示temp</span><br><span class="line">t_label</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">label</span><br></pre></td></tr></table></figure></li></ul><h3 id="类名风格"><a href="#类名风格" class="headerlink" title="类名风格"></a>类名风格</h3><ul><li><p><strong>[必须]</strong> 一个完整的类名由 <strong>前缀+名称+类型</strong> 3个部分组成。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">MAGLoginViewControler</span><br><span class="line"></span><br><span class="line">前缀：MAG</span><br><span class="line">名称：Login</span><br><span class="line">类型：ViewControler</span><br></pre></td></tr></table></figure></li></ul><h3 id="分类命名风格"><a href="#分类命名风格" class="headerlink" title="分类命名风格"></a>分类命名风格</h3><ul><li><p><strong>[必须]</strong> 分类命名风格和类名类似，由 <strong>前缀+名称</strong> 2个部分组成。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">UIView (MAGAdd)</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">UIView (Add)</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 分类中的方法名必须要添加前缀，防止覆盖系统或3方库的私有方法，前缀需要保持唯一性(<code>例如mp_</code>)。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">mp_substringFromString</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">substringFromString</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 分类中建议不要声明属性，尽量挪到主类中声明。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips: </span><br><span class="line">尽管从技术上来讲可以在分类中声明属性，但是这么做需要格外小心，</span><br><span class="line">因为它很容易出现内存上或其他一些问题，而且出现问题很难排查。</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 如果一个类比较复杂，建议使用分类重新组织结构和代码(<code>可以参考系统的UIView</code>)。</p></li></ul><h3 id="枚举命名风格"><a href="#枚举命名风格" class="headerlink" title="枚举命名风格"></a>枚举命名风格</h3><ul><li><p><strong>[必须]</strong> 枚举名称的前缀应该和 <strong>typedef</strong> 的名称保持一致。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">typedef NS_ENUM(NSInteger, MGradientChangeDirection) &#123;</span><br><span class="line">    MGradientChangeDirectionLevel,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">typedef NS_ENUM(NSInteger, MGradientChangeDirection) &#123;</span><br><span class="line">    level,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法命名风格"><a href="#方法命名风格" class="headerlink" title="方法命名风格"></a>方法命名风格</h3><ul><li><p><strong>[必须]</strong> 方法名称的开头一般以小写字母开始，特殊单词除外(<code>例如HTTP、URL</code>)。</p></li><li><p><strong>[必须]</strong> 方法名称禁止直接使用_作为开始部分。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips: </span><br><span class="line">由于系统的私有方法通常以_作为开始部分，这么做可以避免不小心覆盖系统私有方法。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 私有方法必须添加前缀，前缀需要保持唯一性(<code>例如mp_</code>)。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips: </span><br><span class="line">给私有方法添加前缀有如下好处：</span><br><span class="line">1. 提高辨识度，提高代码可读性。</span><br><span class="line">2. 避免不小心覆盖系统或框架的私有方法。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 如果方法返回某个属性值，那么请直接使用属性名作为方法名。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">- (CGSize)cellSize;</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">- (CGSize)getCellSize;</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 方法的每个参数前必须添加有效关键字。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">- (void)sendAction:(SEL)aSelector </span><br><span class="line">          toObject:(id)anObject </span><br><span class="line">       forAllCells:(BOOL)flag;</span><br><span class="line">       </span><br><span class="line">反例：</span><br><span class="line">- (void)sendAction:(SEL)aSelector </span><br><span class="line">                  :(id)anObject </span><br><span class="line">                  :(BOOL)flag;</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 如果某个方法是由通知触发的，那么请使用 <code>Notification</code> 关键字作为名称后缀。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">appDidBecomeActiveNotification</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">appDidBecomeActive</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 尽量不要使用“and”连接接收者属性，尽管and读起来还算顺口，但随着你创建的方法参数的增加，这将会带来一系列的问题。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">- (int)runModalForDirectory:(NSString *)path </span><br><span class="line">                       file:(NSString *)name </span><br><span class="line">                      types:(NSArray *)fileTypes;</span><br><span class="line">                      </span><br><span class="line">反例：</span><br><span class="line">- (int)runModalForDirectory:(NSString *)path </span><br><span class="line">                    andFile:(NSString *)name </span><br><span class="line">                   andTypes:(NSArray *)fileTypes;</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 如果方法描述了两个独立的动作，则可以使用 <code>and</code> 连接。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">- (BOOL)openFile:(NSString *)fullPath </span><br><span class="line"> withApplication:(NSString *)appName </span><br><span class="line">   andDeactivate:(BOOL)flag;</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 尽量不要使用 <code>get</code> 作为方法名称的开始部分，除非这个方法间接返回对象或值。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">- (UIColor *)backgroundColor;</span><br><span class="line">- (void)getLineDash:(float *)pattern count:(int *)count phase:(float *)phase;</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">- (UIColor *)getBackgroundColor;</span><br></pre></td></tr></table></figure></li></ul><h3 id="协议命名风格"><a href="#协议命名风格" class="headerlink" title="协议命名风格"></a>协议命名风格</h3><ul><li><p><strong>[必须]</strong> 协议中的方法名以触发消息的对象名开头，省略类名前缀并首字母小写，如果它没有关联任何类则可以忽略这个规则。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">- (BOOL)tableView:(NSTableView *)tableView </span><br><span class="line">  shouldSelectRow:(int)row;</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 除非协议方法只有一个参数，否则冒号需紧跟在类名后面。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">1. - (BOOL)tableView:(NSTableView *)tableView </span><br><span class="line">     shouldSelectRow:(int)row;</span><br><span class="line">  </span><br><span class="line">2. - (BOOL)applicationOpenUntitledFile:(NSApplication *)sender;</span><br></pre></td></tr></table></figure></li></ul><h3 id="通知命名风格"><a href="#通知命名风格" class="headerlink" title="通知命名风格"></a>通知命名风格</h3><ul><li><p><strong>[必须]</strong> 一个完整的通知名称由 <strong>关联的类名&#x2F;通用前缀+名称+Notification</strong> 3个部分组成。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">UIApplicationDidBecomeActiveNotification</span><br><span class="line"></span><br><span class="line">关联的类：UIApplication</span><br><span class="line">通知名称：DidBecomeActive</span><br><span class="line">固定后缀：Notification</span><br></pre></td></tr></table></figure></li></ul><h3 id="常量命名风格"><a href="#常量命名风格" class="headerlink" title="常量命名风格"></a>常量命名风格</h3><ul><li><p><strong>[必须]</strong> 如果常量局限于某个 <strong>编译单元</strong>(<code>通常指某个类的实现文件内</code>) 之内，通常在前面加小写字母k作为前缀，若常量在全局可见，通常以类名作为前缀，然后采用首字母大写驼峰命名方式。</p>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">// 局部可见</span><br><span class="line">const CGFloat kAnimationDuration = 2.0;</span><br><span class="line">// 全局可见</span><br><span class="line">const CGFloat UIActivityIndicatorViewAnimationDuration = 2.0;</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> const如果修饰的是基本数据类型，则放在最左侧，如果修饰的是对象，则放在变量名前面。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">const NSInteger age</span><br><span class="line">NSString * const name</span><br></pre></td></tr></table></figure></li></ul><h3 id="异常类命名风格"><a href="#异常类命名风格" class="headerlink" title="异常类命名风格"></a>异常类命名风格</h3><ul><li><strong>[必须]</strong> 一个完整的异常类名称由 <strong>前缀+名称+Exception</strong> 3个部分组成。</li></ul><h3 id="文件命名风格"><a href="#文件命名风格" class="headerlink" title="文件命名风格"></a>文件命名风格</h3><ul><li><p><strong>[必须]</strong> 文件名全部小写，使用_连接不同的模块，模块中的单词可以使用驼峰命名。</p></li><li><p><strong>[必须]</strong> 文件名称由 <strong>所属模块+描述</strong> 2个部分组成。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">public_back@2x.png</span><br></pre></td></tr></table></figure></li></ul><h3 id="注释风格"><a href="#注释风格" class="headerlink" title="注释风格"></a>注释风格</h3><ul><li><p><strong>[必须]</strong> 注释请遵守 <a href="https://www.doxygen.nl/index.html">Doxygen</a> 风格。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个好的例子：</span><br><span class="line">/**</span><br><span class="line"> * @brief 关于这个方法的一个简短说明。</span><br><span class="line"> * @discussion 一段详细的描述。</span><br><span class="line"> * @warning 一些警告信息。</span><br><span class="line"> * @note 描述一些需要注意的事情。</span><br><span class="line"> * @param obj1 参数1的说明。</span><br><span class="line"> * @return 返回值的说明。</span><br><span class="line"> * @code</span><br><span class="line"> * 示例代码：</span><br><span class="line"> * id temp = [self testFunction:@&quot;111&quot;];</span><br><span class="line"> * @endcode</span><br><span class="line"> *</span><br><span class="line"> * @par 分割线，上面是一些常用的注释语法，下面是不常用的注释语法。</span><br><span class="line"> *</span><br><span class="line"> * @todo 即将要做的事情。</span><br><span class="line"> * @bug 可能存在的BUG，或者对缺陷的说明。</span><br><span class="line"> * @since 说明从什么版本、什么时间加入此代码。</span><br><span class="line"> * @exception 对可能存在的异常的解释。</span><br><span class="line"> * @pre 用来说明执行方法所需要的前提条件。</span><br><span class="line"> * @post 用来说明执行方法之后的使用条件。</span><br><span class="line"> * @author 作者名称。</span><br><span class="line"> * @remark 一些评论信息。</span><br><span class="line"> * @copyright 版权信息。</span><br><span class="line"> * @version 当前的工程版本。</span><br><span class="line"> * @par 一个新的名称</span><br><span class="line"> *</span><br><span class="line"> * 开始一个新段落。</span><br><span class="line"> */</span><br><span class="line">- (id)testFunction:(NSString *)obj1 &#123;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  效果图<br>  <img src="f01e7d9511334d728efdf822fe013f79~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p></li><li><p><strong>[必须]</strong> 注释的作用是用于解释那些复杂不容易理解的逻辑，以及需要注意的地方，而不是告诉别人这个方法的作用，作用应该在名称中体现出来，提供一个合理的名称比使用晦涩的名称然后试图通过注释来解释它们要好的多。</p></li><li><p><strong>[必须]</strong> 如果修改了实现细节，请记得修改注释。</p></li><li><p><strong>[必须]</strong> 注释不要写的太冗长或太简短，这样都不利于别人快速理解。</p></li><li><p><strong>[必须]</strong> 注释的双斜线和内容之间有且仅有一个空格。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">// 这是示例注释，请注意在双斜线后有一个空格。</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 注释中的语句也需要添加适量的标点符号和空格帮助别人理解。</p></li><li><p><strong>[必须]</strong> 对于代码注释需要谨慎，代码被注释一般有2种可能，1. 后续会恢复此段代码逻辑； 2. 永久不用；对于第1种情况需添加相应注释，如果没有注释信息难以知晓注释动机，后者建议直接删除。如果有需要可以通过代码仓库查阅历史代码。</p></li><li><p><strong>[必须]</strong> 如果某个方法是有问题的，可以使用特殊注释来提醒别人和自己。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">// MARK: - 方法集</span><br><span class="line">// TODO: 等待实现</span><br><span class="line">// FIXME: 有bug，需要修改</span><br><span class="line">// !!!: 逻辑混乱，需要完善</span><br><span class="line">// ???: 具体干什么用的？</span><br><span class="line">- (void)testFunction;</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 行尾注解和代码保持2个空格，如果后续行有多个注释，将它们排列起来通常会更具可读性。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例:</span><br><span class="line">[self doSomethingWithALongName];  // Two spaces before the comment.</span><br><span class="line">[self doSomethingShort];          // More spacing to align the comment.</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 别给糟糕的代码加注释，重构它。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips: </span><br><span class="line">注释不能美化糟糕的代码。当企图使用注释前，先考虑是否可以通过调整结构，命名等操作，消除写注释的必要。</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 如果一个类比较复杂或者有需要注意的地方，那么请在声明它的地方加上注释帮助别人快速理解，如果有必要可以使用 <a href="https://wwi.lanzout.com/iyHlYz0lxqf"><strong>Monodraw</strong></a> 工具绘制ASCII图形提高可读性，如下图所示。</p><p>  monodraw示例图(这张图很清楚的向别人表达这个类的作用)<br>  <img src="63b45029f3684dfba4de6f7b4a6e8a8a~tplv-k3u1fbpfcp-zoom-1.image" alt="monodraw示例图"></p></li></ul><h2 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h2><ul><li><p><strong>[必须]</strong> 不要增加多余空格来使上下代码的等号对齐。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">int a1 = 1;</span><br><span class="line">long a2 = 3;</span><br><span class="line">NSString *a3 = @&quot;&quot;;</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">int a1       = 1;</span><br><span class="line">long a2      = 3;</span><br><span class="line">NSString *a3 = @&quot;&quot;;</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 逗号(,)后面、二元运算符的左右应该添加1个空格，小括号左右不要有空格。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">kColorRGB(255, 255, 255);</span><br><span class="line">int a = 3 + 4;</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">kColorRGB(255,255,255)</span><br><span class="line">int a = 3+4;</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 尽量使用 if return 代替 if else，if 嵌套最好不超过5层。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">if (x == 1) &#123;</span><br><span class="line">……</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (x == 2) &#123;</span><br><span class="line">……</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">if (x == 1) &#123;</span><br><span class="line">……</span><br><span class="line">&#125; else if (x == 2) &#123;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 尽量避免采用取反逻辑运算符，因为取反逻辑不利于快速理解。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">if (array == nil) &#123;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br><span class="line">反例：</span><br><span class="line">if (!array) &#123;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="结构风格"><a href="#结构风格" class="headerlink" title="结构风格"></a>结构风格</h2><ul><li><p><strong>[必须]</strong> 文件内部使用的常量、静态变量在@interface之前声明，如果没有@interface就在@implementation前声明。</p></li><li><p><strong>[必须]</strong> 同一类型的属性声明放在一块显示，中间用一行空格区分，不同类型的声明用2行空格隔开，属性声明的开始和末尾都要添加一行空格。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">@interface MineViewController ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak) UIView *headView;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak) UITableView *tableView;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSArray *dataSourceArray;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 不同作用的方法按照顺序进行排序，生命周期相关的方法 &gt; 公开方法 &gt; 私有方法 &gt; 继承方法 &gt; 通知方法 &gt; 协议方法 &gt; getter&#x2F;setter方法，简单的说就是越重要越常用的方法越靠前。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma mark - LifeCycle(生命周期相关的代码放在最上面)</span><br><span class="line">- (void)dealloc &#123;&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewWillAppear:(BOOL)animated &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - Public(公开方法)</span><br><span class="line">// code...</span><br><span class="line">// 下空两行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - Private(私有方法)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - Override(需要覆盖父类的方法)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - Notification(通知方法)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - Delegate(Delegate需要实现的方法)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - Getter/Setter</span><br></pre></td></tr></table></figure></li><li><p><strong>[必须]</strong> 方法的声明顺序应该为类方法 &gt; 初始化方法 &gt; 实例方法。</p></li><li><p><strong>[建议]</strong> 不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开以提升可读性。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例:</span><br><span class="line">[self createSubviews];</span><br><span class="line">[self createTableview];</span><br><span class="line"></span><br><span class="line">[self netRequest];</span><br></pre></td></tr></table></figure></li><li><p><strong>[建议]</strong> 头文件包含顺序应该是系统头文件 &gt; SDK头文件 &gt; 其他依赖的头文件，用一个空行分隔逻辑上不同的头文件，在每个组中，包含的内容建议按首字母顺序排列。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例:</span><br><span class="line">#import &quot;ProjectX/BazViewController.h&quot;</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;base/basictypes.h&quot;</span><br><span class="line">#include &quot;base/integral_types.h&quot;</span><br><span class="line">#include &quot;util/math/mathutil.h&quot;</span><br><span class="line"></span><br><span class="line">#import &quot;ProjectX/BazModel.h&quot;</span><br><span class="line">#import &quot;Shared/Util/Foo.h&quot;</span><br></pre></td></tr></table></figure></li></ul><p>一个好的头文件例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">#import &quot;WXYZ_ADDefine.h&quot;</span><br><span class="line">    </span><br><span class="line">@class WXYZ_ADModel;</span><br><span class="line">    </span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line">    </span><br><span class="line">/// 提供给外部使用的广告实例对象，所有需要使用广告的地方都应该使用 WXYZ_ADView 创建。</span><br><span class="line">@interface WXYZ_ADView : UIView</span><br><span class="line">    </span><br><span class="line">/// 广告相关属性，key表示广告标题，value表示广告宽度。</span><br><span class="line">@property(nonatomic, copy) NSDictionary&lt;NSString *, NSNumber *&gt; *attributes;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">/// 根据广告类型和广告位置返回是否一个布尔值，表示是否需要展示广告。</span><br><span class="line">+ (BOOL)canLoadADWithADType:(WXYZ_ADViewType)adType adPosition:(WXYZ_ADViewPosition)adPosition;</span><br><span class="line">    </span><br><span class="line">/// 根据广告类型和广告位置创建并返回一个adView对象。</span><br><span class="line">/// @discussion 如果广告开关是关闭状态则返回nil。</span><br><span class="line">/// @param adType 广告类型</span><br><span class="line">/// @param adPosition 广告位置</span><br><span class="line">+ (nullable instancetype)createADViewWithType:(WXYZ_ADViewType)adType adPosition:(WXYZ_ADViewPosition)adPosition;</span><br><span class="line">    </span><br><span class="line">/// 设置adModel将会更新正在显示的广告内容。</span><br><span class="line">- (void)setAdModel:(WXYZ_ADModel *)adModel;</span><br><span class="line">    </span><br><span class="line">+ (instancetype)allocWithZone:(struct _NSZone *)zone UNAVAILABLE_ATTRIBUTE;</span><br><span class="line">    </span><br><span class="line">+ (instancetype)new UNAVAILABLE_ATTRIBUTE;</span><br><span class="line">    </span><br><span class="line">+ (instancetype)alloc UNAVAILABLE_ATTRIBUTE;</span><br><span class="line">    </span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame UNAVAILABLE_ATTRIBUTE;</span><br><span class="line">    </span><br><span class="line">- (instancetype)init UNAVAILABLE_ATTRIBUTE;</span><br><span class="line">    </span><br><span class="line">@end</span><br><span class="line">    </span><br><span class="line">NS_ASSUME_NONNULL_END</span><br></pre></td></tr></table></figure><ol><li>使用 <strong>@class</strong> 向前声明 <code>WXYZ_ADModel</code>而不是用 <code>#import</code>包含。</li><li>@interface 之前有关于类的说明注释，帮助别人在使用这个类时快速了解这个类的作用以及需要注意的地方。</li><li>字典使用了泛型声明字典包含的类型，并且在注释中详细的说明了字典包含的内容。</li><li>属性和第一个方法之间有2个空格来区分它们没有关联性。</li><li>每个属性和返回值都有是否为空的状态，例如 <code>+ createADViewWithType</code> 方法使用 <code>nullable</code> 表明了返回值可能为空的状态，并且在注释中说明了什么情况下会返回空对象。</li><li>遵守了类方法 &gt; 初始化方法 &gt; 实例方法的规则。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html">Cocoa编码规范</a></li><li><a href="https://github.com/alibaba/Alibaba-Java-Coding-Guidelines">阿里巴巴Java代码规范</a></li><li><a href="https://book.douban.com/subject/25829244/">Effective Objective-C 2.0  编写高质量iOS与OS X代码的52个有效方法</a></li><li><a href="https://google.github.io/styleguide/objcguide.html">Google的Objective-C风格指南</a></li><li><a href="https://www.bilibili.com/video/BV1gi421i7nz/?spm_id_from=333.999.0.0&vd_source=6327e0feef1a22aae76d47cc73e13ccd">给代码起名字的三要三不要准则</a></li></ol><!-- >命名规范把命名做到准确且详细，不仅仅是表面功夫，它能够极大的影响工作效率。好的名称能减少代码的歧义，提升团队的阅读效率。能降低维护的难度。三要：如果一个名字，需要在旁边写上注释，就说明这个名称不够好。把信息体现在名称里，例如 `reportCutOffDate` 比 `date` 好。例如 `if (orderCreatedDate < reportCutOffDate)` 比 `if (date2 < date1)` 好。- 要区分度    例如 `genenorReport` 就不够好，report 有可能有多种类型，例如 AReport, BReport. 应该在名称中体现这是什么  .- 要识别度- 要够详细三不要：很多人为的，为了规范而规范的行为，往往都没有好下场。因为他们都会低估了事物的复杂度和未来的不确定性。一个命名，只要客观上没有错误。不影响理解、不产生歧义、不增加维护成本。就应该被接受。我们更应该关心的是正确性和准确性，而不是统一规范。原子能的命名规则：正确性(correctness)、准确性(precision)、一致性(consistency)- 不要规范- 不要主观- 不要造字--> ]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
          <category> 开发规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ObjC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法备忘录</title>
      <link href="/2021/03/08/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Markdown%E8%AF%AD%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95/"/>
      <url>/2021/03/08/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Markdown%E8%AF%AD%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由 布多(budo) 发布于 2021-03-08</p></blockquote><p>这不是一篇教你如何入门 Markdown 语法的文章，它存在的目的是记录我们平常不经常使用的语法，例如如何调整图片的宽度信息；由于这些语法我们不经常使用，所以到用时总是会忘记，此时就需要一篇文章来记录这些不常用的语法，需要用到但又忘记的时候打开来看一下即可。</p><p>基于这个原则，文章不会有如何声明标题这样的语法。</p><blockquote><p>注意：文章中用到了很多 HTML 语法，某些平台可能不支持这些语法。</p></blockquote><hr><h3 id="多行段落"><a href="#多行段落" class="headerlink" title="多行段落"></a>多行段落</h3><p>默认情况下多行空白内容只会显示一行；可以使用 <code>&lt;br&gt;&lt;/br&gt;</code> 实现多行效果。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一行</span><br><span class="line"></span><br><span class="line">&lt;br&gt;&lt;/br&gt;</span><br><span class="line">&lt;br&gt;&lt;/br&gt;</span><br><span class="line">第二行</span><br></pre></td></tr></table></figure><p>第一行</p><p><br></br><br><br></br><br>第二行</p><h3 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h3><p>由于是注释内容，所以你看不到实际内容，这是正常现象(<code>如果你看到了实际内容，说明该平台不支持该语法</code>)。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[//]: 这是一行注释</span><br></pre></td></tr></table></figure><h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">我是第一行注释，</span><br><span class="line">我是第二行注释。</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure><!--我是第一行注释，我是第二行注释。--><h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><p><span id="anchor1">默认情况下</span>多个空格只会显示为一个空格，可以使用 <code>&amp;nbsp;</code> 实现多个空格的效果。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文字1 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;文字2</span><br></pre></td></tr></table></figure><p>文字1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文字2</p><h3 id="链接的悬停文案"><a href="#链接的悬停文案" class="headerlink" title="链接的悬停文案"></a>链接的悬停文案</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[百度](https://www.baidu.com &quot;当鼠标悬停在文字上方时，你会看到它&quot;)</span><br></pre></td></tr></table></figure><p><a href="https://www.baidu.com/" title="当鼠标悬停在文字上方时，你会看到它">百度</a>(<code>ps: 把鼠标悬停在「百度」上，你能看到悬停文案</code>)</p><h3 id="图片的悬停文案"><a href="#图片的悬停文案" class="headerlink" title="图片的悬停文案"></a>图片的悬停文案</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![阿西河图片](https://p.upyun.com/docs/cloud/demo.jpg &quot;当鼠标悬停在文字上方时，你会看到它&quot;)</span><br></pre></td></tr></table></figure><p><img src="demo.jpg" alt="阿西河图片" title="当鼠标悬停在文字上方时，你会看到它"></p><h3 id="图片自定义对齐方式和尺寸等参数"><a href="#图片自定义对齐方式和尺寸等参数" class="headerlink" title="图片自定义对齐方式和尺寸等参数"></a>图片自定义对齐方式和尺寸等参数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div style=&quot;text-align: center;background-color: #b6ffc8;&quot;&gt;</span><br><span class="line">    &lt;img </span><br><span class="line">        src=&quot;https://p.upyun.com/docs/cloud/demo.jpg&quot; </span><br><span class="line">        alt=&quot;阿西河图片&quot; </span><br><span class="line">        title=&quot;阿西河图片Title&quot; </span><br><span class="line">        style=&quot;width:300px;height:300px;&quot;</span><br><span class="line">    &gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><div style="text-align: center;background-color: #b6ffc8;">    <img         src="demo.jpg"         alt="阿西河图片"         title="阿西河图片Title"         style="width:300px;height:300px;"    ></div><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```c</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    printf(&quot;Hello World!&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大部分语言的关键字都是其名称的小写形式，例如 JavaScript 对应的关键字是 javascript，故而我只记录了一些特殊的关键字：</p><table><thead><tr><th align="center">语言名</th><th align="center">关键字</th></tr></thead><tbody><tr><td align="center">C++</td><td align="center">cpp</td></tr><tr><td align="center">c#</td><td align="center">cs</td></tr><tr><td align="center">Objective-C</td><td align="center">objc</td></tr></tbody></table><h3 id="跳转到指定标题"><a href="#跳转到指定标题" class="headerlink" title="跳转到指定标题"></a>跳转到指定标题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[点击跳转到「多行段落」标题](#多行段落)</span><br></pre></td></tr></table></figure><p><a href="#%E5%A4%9A%E8%A1%8C%E6%AE%B5%E8%90%BD">点击跳转到「多行段落」标题</a></p><h3 id="跳转到指定文案"><a href="#跳转到指定文案" class="headerlink" title="跳转到指定文案"></a>跳转到指定文案</h3><p>要跳转处的文案必须这样写：<code>&lt;span id=&quot;anchor1&quot;&gt;默认情况下&lt;/span&gt;</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[点击跳转到指定位置「默认情况下」](#anchor1)</span><br></pre></td></tr></table></figure><p><a href="#anchor1">点击跳转到指定位置「默认情况下」</a></p><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">脚注1[^1]</span><br></pre></td></tr></table></figure><p>脚注1 <a href="%E8%84%9A%E6%B3%A81">^1</a></p><h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- [x] 已完成的任务</span><br><span class="line">- [ ] 未完成的任务</span><br></pre></td></tr></table></figure><ul><li><input checked="" disabled="" type="checkbox"> 已完成的任务</li><li><input disabled="" type="checkbox"> 未完成的任务</li></ul><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是 ~~删除线~~</span><br></pre></td></tr></table></figure><p>这是 <del>删除线</del></p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;font face=&quot;黑体&quot; size=5&gt;我是黑体字&lt;/font&gt;</span><br><span class="line">&lt;font face=&quot;微软雅黑&quot; size=5&gt;我是微软雅黑&lt;/font&gt;</span><br></pre></td></tr></table></figure><p><font face="黑体" size=5>我是黑体字</font><br><font face="微软雅黑" size=5>我是微软雅黑</font></p><h3 id="文字颜色"><a href="#文字颜色" class="headerlink" title="文字颜色"></a>文字颜色</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;font color=#0099ff&gt;我的文字颜色是蓝色&lt;/font&gt;</span><br></pre></td></tr></table></figure><p><font color=#0099ff>我的文字颜色是蓝色</font></p><h3 id="上标"><a href="#上标" class="headerlink" title="上标"></a>上标</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n&lt;sup&gt;2&lt;/sup&gt; = n * n</span><br></pre></td></tr></table></figure><p>n<sup>2</sup> &#x3D; n * n</p><h3 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">H&lt;sub&gt;2&lt;/sub&gt;O</span><br></pre></td></tr></table></figure><p>H<sub>2</sub>O</p><h3 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p style=&quot;background-color: #b6ffc8;&quot;&gt;&lt;font color=#000&gt;背景是绿色&lt;/font&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p style="background-color: #b6ffc8;"><font color=#000>背景是绿色</font></p><h3 id="文字对齐方式"><a href="#文字对齐方式" class="headerlink" title="文字对齐方式"></a>文字对齐方式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p style=&quot;text-align: left;background-color: #b6ffc8;&quot;&gt;&lt;font color=#000&gt;文字左对齐&lt;/font&gt;&lt;/p&gt;</span><br><span class="line">&lt;p style=&quot;text-align: center;background-color: #b6ffc8;&quot;&gt;&lt;font color=#000&gt;文字居中对齐&lt;/font&gt;&lt;/p&gt;</span><br><span class="line">&lt;p style=&quot;text-align: right;background-color: #b6ffc8;&quot;&gt;&lt;font color=#000&gt;文字右对齐&lt;/font&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p style="text-align: left;background-color: #b6ffc8;"><font color=#000>文字左对齐</font></p><p style="text-align: center;background-color: #b6ffc8;"><font color=#000>文字居中对齐</font></p><p style="text-align: right;background-color: #b6ffc8;"><font color=#000>文字右对齐</font></p><h3 id="插入音频"><a href="#插入音频" class="headerlink" title="插入音频"></a>插入音频</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;iframe </span><br><span class="line">    frameborder=&quot;no&quot; </span><br><span class="line">    border=&quot;0&quot; </span><br><span class="line">    marginwidth=&quot;0&quot; </span><br><span class="line">    marginheight=&quot;0&quot; </span><br><span class="line">    width=100% </span><br><span class="line">    height=auto </span><br><span class="line">    src=&quot;https://music.163.com/outchain/player?type=2&amp;id=528478901&amp;auto=1&amp;height=66&quot;&gt;</span><br><span class="line">&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><iframe     frameborder="no"     border="0"     marginwidth="0"     marginheight="0"     width=100%     height=auto     src="https://music.163.com/outchain/player?type=2&id=528478901&auto=1&height=66"></iframe><h3 id="插入视频"><a href="#插入视频" class="headerlink" title="插入视频"></a>插入视频</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;iframe </span><br><span class="line">    src=&quot;https://player.bilibili.com/player.html?aid=10631344&amp;cid=17548810&amp;page=1&quot; </span><br><span class="line">    scrolling=&quot;no&quot; </span><br><span class="line">    style=&quot;border:0;width:100%;height:auto;min-height:790px;&quot;</span><br><span class="line">    allowfullscreen=&quot;true&quot;&gt; </span><br><span class="line">&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><iframe     src="https://player.bilibili.com/player.html?aid=10631344&cid=17548810&page=1"     scrolling="no"     style="border:0;width:100%;height:auto;min-height:790px;"    allowfullscreen="true"> </iframe><h3 id="使用Mermaid画图"><a href="#使用Mermaid画图" class="headerlink" title="使用Mermaid画图"></a>使用Mermaid画图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```mermaid</span><br><span class="line">sequenceDiagram</span><br><span class="line">    participant Alice</span><br><span class="line">    participant Bob</span><br><span class="line">    Alice-&gt;John: Hello John, how are you?</span><br><span class="line">    loop Healthcheck</span><br><span class="line">        John-&gt;John: Fight against hypochondria</span><br><span class="line">    end</span><br><span class="line">    Note right of John: Rational thoughts &lt;br/&gt;prevail...</span><br><span class="line">    John--&gt;Alice: Great!</span><br><span class="line">    John-&gt;Bob: How about you?</span><br><span class="line">    Bob--&gt;John: Jolly good!</span><br><span class="line">```</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant Alice</span><br><span class="line">    participant Bob</span><br><span class="line">    Alice-&gt;John: Hello John, how are you?</span><br><span class="line">    loop Healthcheck</span><br><span class="line">        John-&gt;John: Fight against hypochondria</span><br><span class="line">    end</span><br><span class="line">    Note right of John: Rational thoughts &lt;br/&gt;prevail...</span><br><span class="line">    John--&gt;Alice: Great!</span><br><span class="line">    John-&gt;Bob: How about you?</span><br><span class="line">    Bob--&gt;John: Jolly good!</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LLDynamicLaunchScreen的设计思路</title>
      <link href="/2021/03/07/iOS/LLDynamicLaunchScreen%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/"/>
      <url>/2021/03/07/iOS/LLDynamicLaunchScreen%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由 布多(budo) 发布于 2021-03-07</p></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;动态修改iPhone上APP的启动图，将它修改为用户喜欢的图片，这样用户每次打开APP第一眼就可以看到自己喜欢的图片，这对于用户来说是不是挺爽呢。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;其实这个想法我很早之前就萌发了(大概是2019年上半年)，有一次我发现苹果提供了方法可以动态修改APP的Logo，就萌发了动态修改启动图的想法，当时查阅了一些资料，然后自己通过实践发现确实可以不更新APP动态修改启动图。不过因为当时公司的APP并不需要这个功能，而且大部分的软件厂商也并没有注意到这一块的用户体验，所有的APP也都不支持用户自定义启动图，所以当时也就没继续往下深究了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;时间眨眼就来到了2020年下半年，当时因为公司的APP要实现暗黑模式，但是这个APP已经更新迭代了3年多，在所有页面添加修改色值的代码工作量太大，而且我们的APP支持iOS10但是系统的暗黑API最低支持iOS13，然后自己就写了一个暗黑框架<a href="https://github.com/internetWei/llDark">LLDark</a>，当APP集成好这个暗黑框架后，发现APP强行切换成一个模式后，APP的启动图却没有跟随APP的模式变化，而是跟随系统模式，简单的说就是APP强行设置成了浅色模式，但是系统是深色模式，当用户打开APP时启动图会显示深色(系统)的启动图而不是浅色(APP)的启动图。对于大部分的人来说可能觉得这个问题可以跳过，因为大部分的APP也都这样，但是我是一个完美主义者，为了能让用户有一个完美的体验，然后我就写了<a href="https://github.com/internetWei/LLDynamicLaunchScreen">LLDynamicLaunchScreen</a>，它最初的目的只是为了配合<a href="https://github.com/internetWei/llDark">LLDark</a>实现完美的暗黑模式，后面考虑到可能有APP注意到了这一块的用户体验想要实现动态修改启动图，所以就把它抽离出来并开源了<a href="https://github.com/internetWei/LLDynamicLaunchScreen">LLDynamicLaunchScreen</a>。</p><h3 id="关于启动图的坑"><a href="#关于启动图的坑" class="headerlink" title="关于启动图的坑"></a>关于启动图的坑</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;启动图莫名其妙变成黑色的这个BUG已经有很多APP遇到了，我公司的APP也遇到了，我手机上的微信也遇到了，基本可以确定是苹果的BUG。如图1.1(这是我在手机上录制的，录制时间为2021年3月7号)，大家可以发现我在打开微信APP时屏幕是一片黑色的，我拿同事的手机测试了发现他的手机打开微信APP启动图依旧是原来的一个地球和一个人，所以确定不是微信把启动图换成了黑色(同事手机上的微信版本和我手机上的微信版本是一致的，而且我们的系统版本号也一致)。</p><table><thead><tr><th align="center"><img src="202103061844.gif"></th></tr></thead><tbody><tr><td align="center">图1.1</td></tr></tbody></table><p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/internetWei/LLDynamicLaunchScreen">LLDynamicLaunchScreen</a>支持修复如上问题，您只需要将它集成到您的工程中即可，什么事情都不用做，图2.1这样的情况将可能不会出现在您的APP中，最坏的情况是用户第一次打开APP时可能会出现。</p><table><thead><tr><th align="center"><img src="202102141921.jpg"></th></tr></thead><tbody><tr><td align="center">图2.1</td></tr></tbody></table><h3 id="LLDynamicLaunchScreen介绍"><a href="#LLDynamicLaunchScreen介绍" class="headerlink" title="LLDynamicLaunchScreen介绍"></a>LLDynamicLaunchScreen介绍</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<code>LLDynamicLaunchScreen</code>除了支持上述提到的自动修复启动图莫名其妙变成黑色的BUG，还支持运行时动态修改APP的任意启动图，仅需一行代码即可。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;目前市场上并没有和<code>LLDynamicLaunchScreen</code>类似的框架，github上有一个<code>DynamicLaunchImage</code>框架也实现了动态替换启动图的功能，但是我并不建议您使用它，具体原因我会在下面的对比中详细描述。</p><h3 id="关于LLDynamicLaunchScreen和DynamicLaunchImage"><a href="#关于LLDynamicLaunchScreen和DynamicLaunchImage" class="headerlink" title="关于LLDynamicLaunchScreen和DynamicLaunchImage"></a>关于LLDynamicLaunchScreen和DynamicLaunchImage</h3><ol><li><p><code>LLDynamicLaunchScreen</code>是我开发的一款用于修复iOS上APP启动图异常和动态修改启动图的框架，它实现了如下功能:</p><ol><li>集成后自动修复APP启动图异常显示。</li><li>集成者只需要一行代码即可修改启动图。</li><li>支持修改任意类型的启动图(暗黑竖屏启动图、暗黑横屏启动图、浅色竖屏启动图、浅色横屏启动图)。</li><li>当用户更新APP后自动恢复上一次设置的启动图。</li><li>支持获取当前显示的启动图和任意类型的启动图。</li></ol></li><li><p><code>DynamicLaunchImage</code>是百度团队开发的一款动态修改启动图的框架，它只实现了一个动态修改启动图的功能，而且当用户更新APP后，<code>DynamicLaunchImage</code>并没有记录用户上次的修改信息，它会导致用户更新版本后丢失之前设置的启动图，这是致命的；并且它也不支持单独修改暗黑系启动图或者单独修改浅色系启动图；最致命的是它的开发者并没有继续维护它，我提交了一个issues并没有人去跟进处理。所以建议您使用<a href="https://github.com/internetWei/LLDynamicLaunchScreen">LLDynamicLaunchScreen</a>。</p></li></ol><h3 id="LLDynamicLaunchScreen的具体思路"><a href="#LLDynamicLaunchScreen的具体思路" class="headerlink" title="LLDynamicLaunchScreen的具体思路"></a>LLDynamicLaunchScreen的具体思路</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<code>LLDynamicLaunchScreen</code>它的核心功能其实就是替换系统本地的启动图，但是替换的过程中有如下的问题(只列举了一些比较重要的问题):</p><ol><li>替换系统本地的启动图但不能修改原名称，否则系统会重新生成启动图，这就需要知道本地的启动图名称对应的是哪个具体的启动图(例如本地启动图a.png代表的是深色竖屏启动图还是浅色坚屏启动图还是…)。</li><li>为了实现自动修复启动图异常，需要在APP启动后根据storyboard文件生成一整套的启动图文件并且替换本地的启动图，开发过程中遇到一个问题不管在什么时候生成与系统相反模式的启动图总是失败(例如当前系统是浅色模式，那么在生成深色启动图时实际获取到的总是浅色启动图)，后面通过KVO的思想解决了这个难题，具体思路是利用运行时创建一个自定义的<code>UIViewControler</code>对象并将它与系统的<code>UIViewController</code>的isa指针进行互换，然后监听它的<code>viewDidAppear:</code>方法的实现，在这个方法里再去生成启动图就可以了，当监听完成后会自动释放创建的对象然后将isa指针还原回去。</li><li>在iOS13以下的真机中没有启动图文件夹的读取和修改权限，针对这个问题确实愁了很多天，就在我想放弃iOS13以下系统可以动态修改启动图的想法前，我看到了<code>DynamicLaunchImage</code>的一篇实现文章，文章中提到它也遇到了这个问题，并且通过<code>moveItemAtPath: toPath: error:</code>这个方法解决了。经过测试发现确实可以变相的达到获取启动图信息并且替换启动图的功能，在这里感谢<code>DynamicLaunchImage</code>提供的思路。</li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;具体的实现细节大家可以阅读<a href="https://github.com/internetWei/LLDynamicLaunchScreen">LLDynamicLaunchScreen</a>源码，例如它是怎么在用户更新版本后自动还原至之前的设置。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;如果您有更好的意见或者发现有任何BUG，欢迎您提交<a href="https://github.com/internetWei/LLDynamicLaunchScreen/issues">issues</a>或者联系我。</p><h3 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;由于iOS系统的限制，更新APP后第一次打开会显示默认启动图，之后才会显示自定义的启动图。另外它暂时对iPad的支持性不是很好，因为iPad有多达10种启动图样式，建议不要要iPad中使用它，后续我会升级它支持iPad。<code>LLDynamicLaunchScreen</code>它不支持非LaunchScreen配置的启动图(现在应该没有APP没有使用LaunchScreen适配启动图了吧)。</p><h3 id="LLDynamicLaunchScreen效果图"><a href="#LLDynamicLaunchScreen效果图" class="headerlink" title="LLDynamicLaunchScreen效果图"></a>LLDynamicLaunchScreen效果图</h3><table><thead><tr><th align="center"><img src="160c58e9014740029800c2ffc4752965~tplv-k3u1fbpfcp-zoom-1.image"></th></tr></thead><tbody><tr><td align="center"><a href="https://github.com/internetWei/LLDynamicLaunchScreen">LLDynamicLaunchScreen</a></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ObjC </tag>
            
            <tag> Framework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS适配深色模式最佳方法，绝对干货</title>
      <link href="/2020/12/05/iOS/iOS%E9%80%82%E9%85%8D%E6%B7%B1%E8%89%B2%E6%A8%A1%E5%BC%8F%E6%9C%80%E4%BD%B3%E6%96%B9%E6%B3%95%EF%BC%8C%E7%BB%9D%E5%AF%B9%E5%B9%B2%E8%B4%A7/"/>
      <url>/2020/12/05/iOS/iOS%E9%80%82%E9%85%8D%E6%B7%B1%E8%89%B2%E6%A8%A1%E5%BC%8F%E6%9C%80%E4%BD%B3%E6%96%B9%E6%B3%95%EF%BC%8C%E7%BB%9D%E5%AF%B9%E5%B9%B2%E8%B4%A7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由 布多(budo) 发布于 2020-12-05</p></blockquote><h1 id="LLDark"><a href="#LLDark" class="headerlink" title="LLDark"></a>LLDark</h1><p>适用于iOS的强大深色主题框架，快速适配深色模式。<br>国内用户可以访问<a href="https://gitee.com/internetWei/llDark">这个链接</a></p><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><ul><li>集成简单，只需改动少量代码即可完美适配。</li><li>高性能，仅在需要更新页面时更新指定页面，有相关缓存策略缩短刷新时长。</li><li>功能强大，所有使用UIColor、UIImage、CGColor的地方均可完美适配。</li><li>兼容iOS13以下机型。</li><li>支持从网络上获取深色主题配置。</li><li>自动适配启动图为APP当前主题模式。</li></ul><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p><img src="eb36809a0d784094abb1f173d36e0f5e~tplv-k3u1fbpfcp-zoom-1.image" alt="Manual.gif"> <img src="c62d05b8d9b14c1e9b5fc86d5c4e15fc~tplv-k3u1fbpfcp-zoom-1.image" alt="System.gif"> <img src="ea92ed26bf5e466392e0edf9dc9abe0b~tplv-k3u1fbpfcp-zoom-1.image" alt="Screen.gif"></p><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>配置深色资源：<br>在工程任意NSObject分类(建议单独新建一个主题分类)中创建<code>+ (NSDictionary&lt;id, id&gt; *)llDarkTheme</code>类方法，字典的key表示浅色主题下的颜色&#x2F;图片名称&#x2F;图片地址，字典的value表示深色主题下的颜色&#x2F;图片名称&#x2F;图片地址。可参考样例代码：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSDictionary</span>&lt;<span class="type">id</span>, <span class="type">id</span>&gt; *)llDarkTheme &#123;</span><br><span class="line">    <span class="keyword">return</span> @&#123;</span><br><span class="line">             <span class="built_in">UIColor</span>.whiteColor : kColorRGB(<span class="number">27</span>, <span class="number">27</span>, <span class="number">27</span>),</span><br><span class="line">             kColorRGB(<span class="number">240</span>, <span class="number">238</span>, <span class="number">245</span>) : kColorRGB(<span class="number">39</span>, <span class="number">39</span>, <span class="number">39</span>),</span><br><span class="line">             [<span class="built_in">UIColor</span> colorWithRed:<span class="number">14.0</span> / <span class="number">255.0</span> green:<span class="number">255.0</span> / <span class="number">255.0</span> blue:<span class="number">0.0</span> alpha:<span class="number">1.0</span>] : [<span class="built_in">UIColor</span> colorWithRed:<span class="number">0.0</span> green:<span class="number">14.0</span> / <span class="number">255.0</span> blue:<span class="number">255.0</span> / <span class="number">255.0</span> alpha:<span class="number">1.0</span>],</span><br><span class="line">             <span class="string">@&quot;background_light&quot;</span> : <span class="string">@&quot;background_dark&quot;</span>,</span><br><span class="line">             <span class="string">@&quot;~/path/background_light.png&quot;</span> : <span class="string">@&quot;~/path/background_dark.png&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tips:<br><code>1.不必把所有情况下的颜色/图片都填写进去，对于偶尔或少数使用到的深色颜色可以参考高级用法单独适配。 2.图片名称不用考虑倍图关系；如果填写的是图片路径一定要填写完整的图片路径(包含后缀)。</code></p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>UIColor和CGColor只需要追加.themeColor(nil)即可。<br>UIImage只需要将imageNamed或imageWithContentsOfFile替换为themeImage即可。</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UIColor</span></span><br><span class="line"><span class="built_in">UIColor</span>.redColor; <span class="comment">// 之前的用法</span></span><br><span class="line"><span class="built_in">UIColor</span>.redColor.themeColor(<span class="literal">nil</span>); <span class="comment">// 现在的用法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CGColor</span></span><br><span class="line"><span class="built_in">UIColor</span>.redColor.CGColor; <span class="comment">// 之前的用法</span></span><br><span class="line"><span class="built_in">UIColor</span>.redColor.themeCGColor(<span class="literal">nil</span>); <span class="comment">// 现在的用法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// UIImage</span></span><br><span class="line">[<span class="built_in">UIImage</span> imageNamed:<span class="string">@&quot;lightImageName&quot;</span>]; <span class="comment">// 之前的用法</span></span><br><span class="line">[<span class="built_in">UIImage</span> themeImage:<span class="string">@&quot;lightImageName&quot;</span>]; <span class="comment">// 现在的用法</span></span><br></pre></td></tr></table></figure><p>Tips:<br><code>1.themeImage适配了imageNamed和imageWithContentsOfFile两个方法，可以传递图片名称，也可以传递图片路径。 2.只有适配过的Color和Image在主题切换时才会刷新。 </code></p><h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>themeColor()里面的参数如果是具体的Color对象，深色主题则会使用指定的Color对象刷新,</span><br><span class="line">如果是<span class="literal">nil</span>则会返回llDarkTheme中配置的深色颜色刷新，</span><br><span class="line">如果llDarkTheme未配置则会返回浅色主题下的颜色。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>themeCGColor()参数的作用和themeColor()参数作用一样。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>themeImage()有<span class="number">2</span>个参数，参数可以是图片名称，也可以是图片地址,</span><br><span class="line">第<span class="number">1</span>个参数表示浅色主题下使用的图片(必填)，</span><br><span class="line">第<span class="number">2</span>个参数表示深色主题下使用的图片(可以为空)，</span><br><span class="line">第<span class="number">2</span>个参数为空的话和themeColor()为空的处理方式一样。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>appearanceBindUpdater，所有继承自<span class="built_in">UIView</span>的对象都拥有这个属性，</span><br><span class="line">对象需要刷新时会调用它，可以在这里实现自己的刷新逻辑。</span><br><span class="line">仅在需要刷新时会调用，主题更改不一定需要刷新UI。</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>userInterfaceStyle，类似iOS13系统的overrideUserInterfaceStyle方法，</span><br><span class="line">但是功能比overrideUserInterfaceStyle更加强大，</span><br><span class="line">它支持所有的对象，例如<span class="built_in">CALayer</span>。</span><br><span class="line">它支持iOS13以下的系统使用。</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>themeDidChange，所有对象都拥有这个属性，作用和ThemeDidChangeNotification一样，</span><br><span class="line">themeDidChange会在对象释放时被释放掉，</span><br><span class="line">可以在多个地方使用，不保证回调顺序，</span><br><span class="line">不同于appearanceBindUpdater，只要主题发生改变就会调用themeDidChange。</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>systemThemeDidChange，所有对象都拥有这个属性，作用和SystemThemeDidChangeNotification一样，</span><br><span class="line">释放时机和themeDidChange一样，</span><br><span class="line">可以在多个地方使用，不保证回调顺序，</span><br><span class="line">只要系统主题发生改变就会调用systemThemeDidChange。</span><br><span class="line"></span><br><span class="line"><span class="number">8.</span>darkStyle，所有<span class="built_in">UIImageView</span>对象都拥有这个方法，用于适配没有深色图片的图片对象，例如网络图片。</span><br><span class="line">darkStyle有<span class="number">3</span>个参数，第<span class="number">1</span>个参数决定如何适配深色主题，目前有LLDarkStyleSaturation和LLDarkStyleMask两种，</span><br><span class="line">LLDarkStyleMask使用蒙层适配，LLDarkStyleSaturation通过降低原图饱合度适配。</span><br><span class="line">第<span class="number">2</span>个参数决定蒙层透明度/饱合度值，具体使用可看源码注释。</span><br><span class="line">第<span class="number">3</span>个参数可以为<span class="literal">nil</span>，使用LLDarkStyleSaturation时需要传递一个唯一字符串当做标识符，通常是图片的url。</span><br><span class="line">样例代码：</span><br><span class="line"><span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc] init];</span><br><span class="line"><span class="built_in">NSString</span> *url = <span class="string">@&quot;图片URL&quot;</span>;</span><br><span class="line">imageView.darkStyle(LLDarkStyleSaturation, <span class="number">0.2</span>, url);</span><br><span class="line"><span class="comment">// imageView.darkStyle(LLDarkStyleMask, 0.5, nil);</span></span><br><span class="line"></span><br><span class="line"><span class="number">9.</span>updateDarkTheme:，如果需要运行时修改深色主题配置信息，或者需要从网络上获取深色主题配置信息，可以使用updateDarkTheme:来达到目的。</span><br><span class="line">请确保在第<span class="number">1</span>个UI对象加载前配置好深色主题信息，否则会无效。</span><br><span class="line">样例代码:</span><br><span class="line"><span class="built_in">NSDictionary</span> *darkTheme = @&#123;</span><br><span class="line">    <span class="built_in">UIColor</span>.whiteColor : kColorRGB(<span class="number">27</span>, <span class="number">27</span>, <span class="number">27</span>),</span><br><span class="line">    kColorRGB(<span class="number">240</span>, <span class="number">238</span>, <span class="number">245</span>) : kColorRGB(<span class="number">39</span>, <span class="number">39</span>, <span class="number">39</span>),</span><br><span class="line">    [<span class="built_in">UIColor</span> colorWithRed:<span class="number">14.0</span> / <span class="number">255.0</span> green:<span class="number">255.0</span> / <span class="number">255.0</span> blue:<span class="number">0.0</span> alpha:<span class="number">1.0</span>] : [<span class="built_in">UIColor</span> colorWithRed:<span class="number">0.0</span> green:<span class="number">14.0</span> / <span class="number">255.0</span> blue:<span class="number">255.0</span> /  <span class="number">255.0</span> alpha:<span class="number">1.0</span>],</span><br><span class="line">    <span class="string">@&quot;background_light&quot;</span> : <span class="string">@&quot;background_dark&quot;</span>,</span><br><span class="line">    <span class="string">@&quot;~/path/background_light.png&quot;</span> : <span class="string">@&quot;~/path/background_dark.png&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">[LLDarkSource updateDarkTheme:darkTheme];</span><br><span class="line"></span><br><span class="line"><span class="number">10.</span>thirdControlClassName，如果需要支持第<span class="number">3</span>方控件的刷新方法，可以在appearanceBindUpdater中单独实现刷新逻辑，也可以按照如下方法实现刷新逻辑，更加推荐如下方法。</span><br><span class="line">首先需要实现thirdControlClassName这个类方法，并返回一个数组，数组包含第<span class="number">3</span>方控件的类名字符串。</span><br><span class="line">然后实现refresh+类名字符串的对象方法，在方法里实现第<span class="number">3</span>方控件的刷新逻辑，可以参考LLThird.m文件中已经实现的YYLabel的刷新逻辑。</span><br><span class="line">详情可以下载工程查看Demo了解具体实现。</span><br></pre></td></tr></table></figure><p>高级用法中第8条darkStyle方法的样例图(为了突出效果特意将饱合度和透明度调整的很低)：<br><img src="1241324201ce4deea2ab431d547b9a62~tplv-k3u1fbpfcp-zoom-1.image" alt="137a9000178656346577e"> </p><h1 id="快速适配"><a href="#快速适配" class="headerlink" title="快速适配"></a>快速适配</h1><p>仅需要3步即可快速完美适配深色主题模式，经测试大部分工程都能在0.5天内适配完成，<br>少量工程1天内适配完成，极少需要1天以上的工作量进行适配。</p><ol><li>配置深色主题资源，可参考<code>前提</code>，也可以参考<code>高级方法9</code>从网络中获取资源适配。</li><li>将需要适配的Color和Image适配为主题Color和主题Image，适配方法可参考<code>基础用法</code>和<code>高级用法</code>。</li><li>运行工程，检查完整性。</li></ol><p>Tips:<br>如果您还需要适配<code>WKWebView</code>，可以<a href="https://www.jianshu.com/p/be578117f84c">点击链接</a>参考文章进行适配。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h3 id="CocoaPods"><a href="#CocoaPods" class="headerlink" title="CocoaPods"></a>CocoaPods</h3><ol><li>将 cocoapods 更新至最新版本。</li><li>在 Podfile 中添加 pod ‘LLDark’。</li><li>执行 pod install 或 pod update。</li><li>导入 &lt;LLDark&#x2F;LLDark.h&gt;。</li></ol><h3 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h3><ol><li>下载 LLDark 文件夹内的所有内容。</li><li>将 LLDark 工程中的LLDark文件夹添加(拖放)到你的工程。</li><li>导入 “LLDark.h”。</li></ol><h1 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h1><p>该项目最低支持iOS9.0和Xcode10.0，如果想在更低系统上使用请联系作者。</p><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ol><li>需要自己监听主题模式修改状态栏颜色。</li></ol><h1 id="已知问题"><a href="#已知问题" class="headerlink" title="已知问题"></a>已知问题</h1><ul><li>需要适配深色主题的图片资源请不要放在Assets.xcassets中，否则可能会获取不到。</li><li>暂时不支持其他主题模式，后续会支持多种主题自由搭配。</li></ul><h1 id="联系作者"><a href="#联系作者" class="headerlink" title="联系作者"></a>联系作者</h1><p>如果你有更好的改进，please pull reqeust me</p><p>如果你有任何更好的意见，请创建一个<a href="https://github.com/internetWei/llDark/issues">Issue</a></p><p>可以通过此邮箱联系作者<code>internetwei@foxmail.com</code></p><h1 id="许可证"><a href="#许可证" class="headerlink" title="许可证"></a>许可证</h1><p>LLDark 使用 MIT 许可证，详情见 LICENSE 文件。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ObjC </tag>
            
            <tag> Framework </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
