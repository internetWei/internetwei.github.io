<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="揭开 iOS 中 weak 指针的神秘面纱：从原理到实践"><meta name="keywords" content="ObjC,Runtime,Category"><meta name="author" content="布多"><meta name="copyright" content="布多"><title>揭开 iOS 中 weak 指针的神秘面纱：从原理到实践 | 布多的博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?f0d94d3f99211c3546490e469f6ecbd8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="布多的博客" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#weak-%E6%8C%87%E9%92%88%E4%B9%8B%E7%BC%96%E8%AF%91%E6%9C%9F%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.</span> <span class="toc-text">weak 指针之编译期实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#weak-%E6%8C%87%E9%92%88%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.</span> <span class="toc-text">weak 指针之运行时实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#weak-%E6%8C%87%E9%92%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%86%E8%8A%82%EF%BC%9AstoreWeak"><span class="toc-number">3.1.</span> <span class="toc-text">weak 指针的初始化细节：storeWeak</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#weak-%E6%8C%87%E9%92%88%E5%BB%BA%E7%AB%8B%E5%85%B3%E8%81%94%E7%9A%84%E7%BB%86%E8%8A%82%EF%BC%9Aweak-register-no-lock"><span class="toc-number">3.2.</span> <span class="toc-text">weak 指针建立关联的细节：weak_register_no_lock</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90-SideTable-%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">深入剖析 SideTable 类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#weak-%E6%8C%87%E9%92%88%E8%87%AA%E5%8A%A8%E8%B5%8B%E5%80%BC-nil-%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82%EF%BC%9Aweak-clear-no-lock"><span class="toc-number">5.</span> <span class="toc-text">weak 指针自动赋值 nil 的实现细节：weak_clear_no_lock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-weak-%E6%8C%87%E9%92%88%E7%9A%84%E4%B8%80%E4%BA%9B%E7%96%91%E9%97%AE%E4%B8%8E%E8%A7%A3%E7%AD%94"><span class="toc-number">7.</span> <span class="toc-text">关于 weak 指针的一些疑问与解答</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%BB%99-Category-%E6%B7%BB%E5%8A%A0-weak-%E5%B1%9E%E6%80%A7%EF%BC%9F"><span class="toc-number">7.1.</span> <span class="toc-text">为什么不能给 Category 添加 weak 属性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8-block-%E4%B8%AD%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8-weak-%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%85%B6%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E3%80%82"><span class="toc-number">7.2.</span> <span class="toc-text">为什么在 block 中不能使用 weak 指针访问其成员变量。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E5%AF%B9%E8%B1%A1%E6%B2%A1%E6%9C%89%E5%BC%B1%E5%BC%95%E7%94%A8%E6%97%B6%E4%B9%9F%E4%BC%9A%E6%89%A7%E8%A1%8C-weak-clear-no-lock"><span class="toc-number">7.3.</span> <span class="toc-text">为什么在对象没有弱引用时也会执行 weak_clear_no_lock</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="images/avatar.jpg"></div><div class="author-info__name text-center">布多</div><div class="author-info__description text-center">前进！前进！！不择手段地前进！！！</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/internetwei">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">9</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">8</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">4</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友链</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.coderqi.com/">齐小胖之家</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(images/backgroundImage.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">布多的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/about">关于</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">揭开 iOS 中 weak 指针的神秘面纱：从原理到实践</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-10-21</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/">iOS</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">5.2k</span><span class="post-meta__separator">|</span><span>阅读时长: 19 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>由 布多(budo) 发布于 2023-10-21 • 最后更新于 2025-02-10</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>weak 指针是 iOS 开发中一个非常基础的概念，在开发过程中我们经常使用它，它到底是怎么实现的？这篇文章将从 Runtime 源码入手，为你介绍 weak 指针的实现原理；让你知其然，更知其所以然。</p>
<h2 id="weak-指针之编译期实现"><a href="#weak-指针之编译期实现" class="headerlink" title="weak 指针之编译期实现"></a>weak 指针之编译期实现</h2><p>当我们初始化一个 weak 指针时： <code>__weak typeof(obj) weakObj = obj;</code>，编译器其实会把它们转换成类似这样的代码：<code>objc_initWeak((void *)&amp;weakObj, obj);</code></p>
<p><img src="https://github.com/internetWei/internetwei.github.io/blob/master/images/%E6%8F%AD%E5%BC%80%20iOS%20%E4%B8%AD%20weak%20%E6%8C%87%E9%92%88%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1%EF%BC%9A%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5/entrance.png?raw=true" alt="weak 指针的初始化入口"></p>
<p>从上图的断点中我们也可以发现，weak 指针调用了 <code>objc_initWeak</code> 函数来完成初始化。在 Runtime 源码中我们可以找到 <code>objc_initWeak</code> 相关的实现细节。</p>
<blockquote>
<p>本文引用的 Runtime 源码版本是 <a target="_blank" rel="noopener" href="https://github.com/apple-oss-distributions/objc4/tree/objc4-906">objc4-906</a>，为了更方便阅读，我对代码样式和排版略作了修改以及删减了那些不影响主逻辑的冗余代码。</p>
<p>我在 <a target="_blank" rel="noopener" href="https://github.com/internetWei/ObjCRuntimes">这里</a> 维护了一个可以直接运行调试的 Runtime 项目，方便大家在自己的电脑上直接调试。</p>
</blockquote>
<h2 id="weak-指针之运行时实现"><a href="#weak-指针之运行时实现" class="headerlink" title="weak 指针之运行时实现"></a>weak 指针之运行时实现</h2><p>与 weak 指针初始化相关的函数有以下 4 个：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化一个全新的 weak 指针。</span></span><br><span class="line"><span class="function">id <span class="title">objc_initWeak</span><span class="params">(id *location, id newObj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!newObj) &#123;</span><br><span class="line">        *location = nil;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">storeWeak</span>&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;(location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和前面的 objc_initWeak 一样，</span></span><br><span class="line"><span class="comment">// 但是，如果指向的对象（即 newObj）正在释放的话不要报错而是返回 nil。</span></span><br><span class="line"><span class="function">id <span class="title">objc_initWeakOrNil</span><span class="params">(id *location, id newObj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!newObj) &#123;</span><br><span class="line">        *location = nil;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">storeWeak</span>&lt;DontHaveOld, DoHaveNew, DontCrashIfDeallocating&gt;(location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放 weak 指针当前指向的对象，并将它指向新对象（即 newObj）。</span></span><br><span class="line"><span class="function">id <span class="title">objc_storeWeak</span><span class="params">(id *location, id newObj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">storeWeak</span>&lt;DoHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;(location, (objc_object *)newObj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和 objc_storeWeak 一样。</span></span><br><span class="line"><span class="comment">// 但是，如果指向的对象（即 newObj）正在释放的话不要报错而是返回 nil。</span></span><br><span class="line"><span class="function">id <span class="title">objc_initWeakOrNil</span><span class="params">(id *location, id newObj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!newObj) &#123;</span><br><span class="line">        *location = nil;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">storeWeak</span>&lt;DontHaveOld, DoHaveNew, DontCrashIfDeallocating&gt;(location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于函数 objc_initWeak 和 objc_storeWeak 的区别：</p>
<ul>
<li><p><code>objc_initWeak</code>：用来初始化一个全新的 weak 指针。例如以下场景：</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *obj = ...;</span><br><span class="line">__<span class="keyword">weak</span> <span class="type">id</span> weakPtr = obj;<span class="comment">// 在初始化的时候就指向了对象。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>objc_storeWeak</code>：当 weak 指针被赋值的时候调用。例如以下场景：</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *obj = ...;</span><br><span class="line">__<span class="keyword">weak</span> <span class="type">id</span> weakPtr;</span><br><span class="line">weakPtr = obj;<span class="comment">// 先初始化，后赋值。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>从以上 4 个初始化函数不难发现，它们最终都调用了同一个函数 <code>storeWeak</code>，区别就是传递给函数的模板参数略有不同。</p>
<h3 id="weak-指针的初始化细节：storeWeak"><a href="#weak-指针的初始化细节：storeWeak" class="headerlink" title="weak 指针的初始化细节：storeWeak"></a>weak 指针的初始化细节：storeWeak</h3><p><code>storeWeak</code> 函数的相关代码整理后如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">HaveOld</span> &#123; DontHaveOld = <span class="literal">false</span>, DoHaveOld = <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">HaveNew</span> &#123; DontHaveNew = <span class="literal">false</span>, DoHaveNew = <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CrashIfDeallocating</span> &#123;</span><br><span class="line">    DontCrashIfDeallocating = <span class="literal">false</span>, DoCrashIfDeallocating = <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">location: weak 指针的内存地址，即 `__weak id weakPtr;` 中的 &amp;weakPtr。</span></span><br><span class="line"><span class="comment">newObj: weak 指针要指向的对象，即 `__weak id weakPtr = obj;` 中的 obj。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;HaveOld haveOld, HaveNew haveNew, </span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CrashIfDeallocating</span> crashIfDeallocating&gt;</span><br><span class="line"><span class="function"><span class="type">static</span> id <span class="title">storeWeak</span><span class="params">(id *location, objc_object *newObj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当 newObj 的类型还未初始化的时候会用到。</span></span><br><span class="line">    Class previouslyInitializedClass = nil;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存 weak 指针当前指向的对象。</span></span><br><span class="line">    id oldObj;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// SideTable 是用来存储弱引用关联的 1 个数据结构，后面会单独讲。</span></span><br><span class="line">    SideTable *oldTable;</span><br><span class="line">    SideTable *newTable;</span><br><span class="line"></span><br><span class="line"> retry:</span><br><span class="line">    <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">        oldObj = *location;</span><br><span class="line">        <span class="comment">// 调用全局函数 SideTables 获取 oldObj 对应的 SideTable 对象。</span></span><br><span class="line">        oldTable = &amp;<span class="built_in">SideTables</span>()[oldObj];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        oldTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        newTable = &amp;<span class="built_in">SideTables</span>()[newObj];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该函数不是线程安全的，所以执行到这里的时候，</span></span><br><span class="line">    <span class="comment">// weak 指针的值有可能被其它线程修改了，</span></span><br><span class="line">    <span class="comment">// 如果是的话就跳转到 retry 重新获取数据。</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld &amp;&amp; *location != oldObj) &#123;</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (haveNew &amp;&amp; newObj) &#123;</span><br><span class="line">        Class cls = newObj-&gt;<span class="built_in">getIsa</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        检查 newObj 的类型是否已经完成初始化。</span></span><br><span class="line"><span class="comment">        一般都不会发生这种情况，除非你在 +initialize 中对该对象进行弱引用，</span></span><br><span class="line"><span class="comment">        例如以下场景：</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">        ```objc</span></span><br><span class="line"><span class="comment">        @implementation Person</span></span><br><span class="line"><span class="comment">        + (void)initialize &#123;</span></span><br><span class="line"><span class="comment">           Person *obj = [[self alloc] init];</span></span><br><span class="line"><span class="comment">           // 此时 Person 类还未完成初始化操作。</span></span><br><span class="line"><span class="comment">           __weak typeof(obj) weakObj = obj;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        @end</span></span><br></pre></td></tr></table></figure>
<pre><code>    */
    if (cls != previouslyInitializedClass &amp;&amp;  
        !cls-&gt;isInitialized()) &#123;  
        
        // 对 newObj 类型进行初始化操作，然后跳转 retry 重新获取数据。
        class_initialize(cls, newObj);
        previouslyInitializedClass = cls;

        goto retry;
    &#125;
&#125;

if (haveOld) &#123;
    // 如果 weak 指针当前持有了一个对象，先解除与这个对象的弱引用关联。
    weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);
&#125;

if (haveNew) &#123;
    // 将 weak 指针与新对象建立弱引用关联。
    newObj = weak_register_no_lock(&amp;newTable-&gt;weak_table,
    (id)newObj,
    location,
    /*
    之前在初始化函数那里提到过带 OrNil 后缀和不带后缀的区别，
    重点就在这里，带后缀的函数这里会传递 ReturnNilIfDeallocating，
    不带后缀的会传递 CrashIfDeallocating。
    函数内部会检查 newObj 是否正在释放过程中，
    如果是的话就会使用这个参数来决定怎么处理。
    */
    crashIfDeallocating ? CrashIfDeallocating : ReturnNilIfDeallocating);
    
    // 修改 newObj 对象的 isa 中关于是否有弱引用的标记。
    if (!_objc_isTaggedPointerOrNil(newObj)) &#123;
        newObj-&gt;setWeaklyReferenced_nolock();
    &#125;

    // 将 weak 指针指向 newObj。
    *location = (id)newObj;
&#125;
    
/* 
这个函数我翻了往年的 runtime 源码，发现是从 objc4-818.2 开始引入的。
它的内部逻辑大致如下：

1. 检查对象是否实现了手动引用计数。
2. 如果支持的话，再判断对象是否有实例方法 _setWeaklyReferenced 的实现，如果有的话就调用。
*/
callSetWeaklyReferenced((id)newObj);

return (id)newObj;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这个函数就是 weak 指针初始化的最终函数。从函数中不难发现，它主要就干了 2 件事：</span><br><span class="line"></span><br><span class="line">1. 调用 `weak_unregister_no_lock`：将 weak 指针与当前对象解除弱引用关联。</span><br><span class="line">2. 调用 `weak_register_no_lock`：将 weak 指针与新对象建立弱引用关联。</span><br><span class="line"></span><br><span class="line">### weak 指针解除关联的细节：weak_unregister_no_lock</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">void</span><br><span class="line">weak_unregister_no_lock(weak_table_t *weak_table,</span><br><span class="line">                        id referent_id,</span><br><span class="line">                        id *referrer_id) &#123;</span><br><span class="line">    // weak 指针当前指向的对象，即 `__weak id weakPtr = obj;` 中的 obj。</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    // weak 指针的内存地址，即 `__weak id weakPtr;` 中的 &amp;weakPtr。</span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id;</span><br><span class="line"></span><br><span class="line">    // referent 对象的弱引用表。</span><br><span class="line">    weak_entry_t *entry;</span><br><span class="line"></span><br><span class="line">    if (!referent) return;</span><br><span class="line"></span><br><span class="line">    // 从 weak_table 中取出 referent 对应的弱引用表。</span><br><span class="line">    if ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</span><br><span class="line">        // 从弱引用表中移除 weak 指针的地址，即移除 referrer。</span><br><span class="line">        remove_referrer(entry, referrer);</span><br><span class="line">        </span><br><span class="line">        // 移除后检查一下表是否为空，</span><br><span class="line">        // 如果是的话就删除这个表。</span><br><span class="line">        bool empty = true;</span><br><span class="line">        if (entry-&gt;out_of_line() &amp;&amp;</span><br><span class="line">            entry-&gt;num_refs != 0) &#123;</span><br><span class="line">            empty = false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (size_t i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">                if (entry-&gt;inline_referrers[i]) &#123;</span><br><span class="line">                    empty = false; </span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (empty) &#123;</span><br><span class="line">            weak_entry_remove(weak_table, entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 从弱引用表中获取某个对象对应的那张表数据。</span><br><span class="line">static weak_entry_t *</span><br><span class="line">weak_entry_for_referent(weak_table_t *weak_table, objc_object *referent) &#123;</span><br><span class="line">    // 下面的逻辑是一段典型的哈希表实现细节，关于哈希表的实现原理请自行了解。</span><br><span class="line">    weak_entry_t *weak_entries = weak_table-&gt;weak_entries;</span><br><span class="line"></span><br><span class="line">    if (!weak_entries) return nil;</span><br><span class="line"></span><br><span class="line">    size_t begin = hash_pointer(referent) &amp; weak_table-&gt;mask;</span><br><span class="line">    size_t index = begin;</span><br><span class="line">    size_t hash_displacement = 0;</span><br><span class="line">    </span><br><span class="line">    while (weak_table-&gt;weak_entries[index].referent != referent) &#123;</span><br><span class="line">        index = (index+1) &amp; weak_table-&gt;mask;</span><br><span class="line">        if (index == begin) bad_weak_table(weak_table-&gt;weak_entries);</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        if (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123;</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return &amp;weak_table-&gt;weak_entries[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 从弱引用表中移除指定的 weak 指针。</span><br><span class="line">static void</span><br><span class="line">remove_referrer(weak_entry_t *entry, objc_object **old_referrer) &#123;</span><br><span class="line">    // 系统在存储弱指针数据的时候会采用 2 套方案。</span><br><span class="line">    // 如果数据量比较小就会使用静态数组存放。</span><br><span class="line">    // 这里的逻辑就是判断，如果是静态数组方案就执行这段逻辑。</span><br><span class="line">    if (!entry-&gt;out_of_line()) &#123;</span><br><span class="line">        for (size_t i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            if (entry-&gt;inline_referrers[i] == old_referrer) &#123;</span><br><span class="line">                entry-&gt;inline_referrers[i] = nil;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果是动态数组存储的话，就执行这段逻辑。</span><br><span class="line">    size_t begin = w_hash_pointer(old_referrer) &amp; (entry-&gt;mask);</span><br><span class="line">    size_t index = begin;</span><br><span class="line">    size_t hash_displacement = 0;</span><br><span class="line">    </span><br><span class="line">    while (entry-&gt;referrers[index] != old_referrer) &#123;</span><br><span class="line">        index = (index+1) &amp; entry-&gt;mask;</span><br><span class="line">        if (index == begin) bad_weak_table(entry);</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        if (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123;</span><br><span class="line">            // 弱引用表中没有这个弱指针数据，不需要移除。</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    entry-&gt;referrers[index] = nil;</span><br><span class="line">    entry-&gt;num_refs--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 从弱引用表中移除某张表。</span><br><span class="line">static void</span><br><span class="line">weak_entry_remove(weak_table_t *weak_table, weak_entry_t *entry) &#123;</span><br><span class="line">    // 如果是动态数组方案的话，释放创建的动态数组。</span><br><span class="line">    if (entry-&gt;out_of_line()) free(entry-&gt;referrers);</span><br><span class="line">    </span><br><span class="line">    memset(entry, 0, sizeof(*entry));</span><br><span class="line"></span><br><span class="line">    weak_table-&gt;num_entries--;</span><br><span class="line"></span><br><span class="line">    // 如果需要的话，对弱引用表进行缩容。</span><br><span class="line">    weak_compact_maybe(weak_table);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码稍微有点多，但整体的逻辑比较清晰。<code>weak_unregister_no_lock</code> 函数中主要做了 3 件事：</p>
<ol>
<li>调用 <code>weak_entry_for_referent</code> 从弱引用表中获取指定的那张表数据。</li>
<li>调用 <code>remove_referrer</code> 从表中移除弱指针（即 referrer）。</li>
<li>检查表是否为空，是的话就调用 <code>weak_entry_remove</code> 从 weak_table 中移除这张表。</li>
</ol>
<p>移除弱引用关联，本质上就是从 weak_table 中找到对象对应的弱引用数组，然后从数组中找到需要移除的 weak 指针并将其置空。weak_table 其实就是一个哈希表，关于哈希表的实现原理请自行了解。</p>
<h3 id="weak-指针建立关联的细节：weak-register-no-lock"><a href="#weak-指针建立关联的细节：weak-register-no-lock" class="headerlink" title="weak 指针建立关联的细节：weak_register_no_lock"></a>weak 指针建立关联的细节：weak_register_no_lock</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">id </span></span><br><span class="line"><span class="function"><span class="title">weak_register_no_lock</span><span class="params">(<span class="type">weak_table_t</span> *weak_table,</span></span></span><br><span class="line"><span class="params"><span class="function">                      id referent_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                      id *referrer_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                      WeakRegisterDeallocatingOptions deallocatingOptions)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// weak 指针当前指向的对象，即 `__weak id weakPtr = obj;` 中的 obj。</span></span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    <span class="comment">// weak 指针的内存地址，即 `__weak id weakPtr;` 中的 &amp;weakPtr。</span></span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里是确保 weak 指针要指向的那个对象是有效的（即没有正在释放）。</span></span><br><span class="line">    <span class="keyword">if</span> (deallocatingOptions == ReturnNilIfDeallocating ||</span><br><span class="line">        deallocatingOptions == CrashIfDeallocating) &#123;</span><br><span class="line">        <span class="type">bool</span> deallocating;</span><br><span class="line">        <span class="keyword">if</span> (!referent-&gt;<span class="built_in">ISA</span>()-&gt;<span class="built_in">hasCustomRR</span>()) &#123;</span><br><span class="line">            deallocating = referent-&gt;<span class="built_in">rootIsDeallocating</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> allowsWeakReference = (<span class="built_in">BOOL</span>(*)(objc_object *, SEL))</span><br><span class="line">            <span class="built_in">lookUpImpOrForwardTryCache</span>((id)referent, @<span class="built_in">selector</span>(allowsWeakReference),</span><br><span class="line">                                       referent-&gt;<span class="built_in">getIsa</span>());</span><br><span class="line">            <span class="keyword">if</span> ((IMP)allowsWeakReference == _objc_msgForward) &#123;</span><br><span class="line">                <span class="keyword">return</span> nil;</span><br><span class="line">            &#125;</span><br><span class="line">            deallocating =</span><br><span class="line">            ! (*allowsWeakReference)(referent, @<span class="built_in">selector</span>(allowsWeakReference));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果正在释放的话，根据参数 deallocatingOptions 来决定执行什么操作。</span></span><br><span class="line">        <span class="keyword">if</span> (deallocating) &#123;</span><br><span class="line">            <span class="keyword">if</span> (deallocatingOptions == CrashIfDeallocating) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">&quot;Cannot form weak reference to instance (%p) of &quot;</span></span><br><span class="line">                            <span class="string">&quot;class %s. It is possible that this object was &quot;</span></span><br><span class="line">                            <span class="string">&quot;over-released, or is in the process of deallocation.&quot;</span>,</span><br><span class="line">                            (<span class="type">void</span>*)referent, <span class="built_in">object_getClassName</span>((id)referent));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nil;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">weak_entry_t</span> *entry;</span><br><span class="line">    <span class="comment">// weak_entry_for_referent 函数在前面的 weak_unregister_no_lock 中已解释过。</span></span><br><span class="line">    <span class="keyword">if</span> ((entry = <span class="built_in">weak_entry_for_referent</span>(weak_table, referent))) &#123;</span><br><span class="line">        <span class="built_in">append_referrer</span>(entry, referrer);</span><br><span class="line">    &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 找不到对应的表，创建一个新表。</span></span><br><span class="line">        <span class="type">weak_entry_t</span> <span class="built_in">new_entry</span>(referent, referrer);</span><br><span class="line">        <span class="comment">// 如果需要的话，对 weak_table 进行扩容。</span></span><br><span class="line">        <span class="built_in">weak_grow_maybe</span>(weak_table);</span><br><span class="line">        <span class="comment">// 将新表插入到 weak_table 中。</span></span><br><span class="line">        <span class="built_in">weak_entry_insert</span>(weak_table, &amp;new_entry);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> referent_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向弱引用表中添加一个 weak 指针。</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">append_referrer</span><span class="params">(<span class="type">weak_entry_t</span> *entry, objc_object **new_referrer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前采用的是静态数组方案就执行这段逻辑。</span></span><br><span class="line">    <span class="keyword">if</span> (!entry-&gt;<span class="built_in">out_of_line</span>()) &#123;</span><br><span class="line">        <span class="comment">// 尝试在静态数组中插入数据。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;inline_referrers[i] == nil) &#123;</span><br><span class="line">                entry-&gt;inline_referrers[i] = new_referrer;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 来到这里说明静态数组已经存满了，后面的逻辑是把静态数组转为动态数组存储。</span></span><br><span class="line">        <span class="type">weak_referrer_t</span> *new_referrers = (<span class="type">weak_referrer_t</span> *)</span><br><span class="line">            <span class="built_in">calloc</span>(<span class="number">4</span>, <span class="built_in">sizeof</span>(<span class="type">weak_referrer_t</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            new_referrers[i] = entry-&gt;inline_referrers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        entry-&gt;referrers = new_referrers;</span><br><span class="line">        entry-&gt;num_refs = <span class="number">4</span>;</span><br><span class="line">        entry-&gt;out_of_line_ness = <span class="number">2</span>;</span><br><span class="line">        entry-&gt;mask = <span class="number">4</span> - <span class="number">1</span>;</span><br><span class="line">        entry-&gt;max_hash_displacement = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果数组的元素数量大于等于总容量的 3/4，则对数组进行扩容并插入新数据。</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;num_refs &gt;= (entry-&gt;mask + <span class="number">1</span>) * <span class="number">3</span>/<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">grow_refs_and_insert</span>(entry, new_referrer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">size_t</span> begin = <span class="built_in">w_hash_pointer</span>(new_referrer) &amp; (entry-&gt;mask);</span><br><span class="line">    <span class="type">size_t</span> index = begin;</span><br><span class="line">    <span class="type">size_t</span> hash_displacement = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (entry-&gt;referrers[index] != nil) &#123;</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; entry-&gt;mask;</span><br><span class="line">        <span class="keyword">if</span> (index == begin) <span class="built_in">bad_weak_table</span>(entry);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// hash_displacement 保存的是此次遇到的哈希冲突次数，</span></span><br><span class="line">    <span class="comment">// 之所以要保存这个值，是因为取值的时候也会遇到哈希冲突，</span></span><br><span class="line">    <span class="comment">// 此时需要和这个值进行比较，如果大于这个值的话就说明哈希表中没有要找的数据。</span></span><br><span class="line">    <span class="keyword">if</span> (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123;</span><br><span class="line">        entry-&gt;max_hash_displacement = hash_displacement;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">weak_referrer_t</span> &amp;ref = entry-&gt;referrers[index];</span><br><span class="line">    ref = new_referrer;</span><br><span class="line">    entry-&gt;num_refs++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建立关联和解除关联的逻辑相似，本质都是通过 <code>weak_entry_for_referent</code> 获取对应的表。然后在通过 weak 指针进行一系列哈希运算，从而拿到要添加&#x2F;要删除的数组索引，最终对数组元素进行添加&#x2F;删除操作。</p>
<p>截止到这里，关于 weak 指针的整个初始化过程已经全部讲完了。如果你还想了解更多细节的话可以继续阅读后面的内容。</p>
<h2 id="深入剖析-SideTable-类型"><a href="#深入剖析-SideTable-类型" class="headerlink" title="深入剖析 SideTable 类型"></a>深入剖析 SideTable 类型</h2><p>SideTable 是用来存储弱引用数据和引用计数的一个数据结构，由于这篇文章只涉及弱引用相关问题，所以在后面的源码中我会特意去掉与文章不相关的内容，如果你想了解全部细节的话请阅读源码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SideTable</span> &#123;</span><br><span class="line">	 <span class="comment">// 你可以把它理解成一个哈希表，</span></span><br><span class="line">    <span class="comment">// key 是对象；value 是对象对应的弱引用表数据。</span></span><br><span class="line">    <span class="type">weak_table_t</span> weak_table;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">weak_table_t</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这是一个数组，数组中的每个元素是一个 weak_entry_t 对象。</span></span><br><span class="line"><span class="comment">    weak_entry_t 里存储了弱引用的相关数据。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">weak_entry_t</span> *weak_entries;</span><br><span class="line">    <span class="comment">// 数组 weak_entries 的元素数量。</span></span><br><span class="line">    <span class="type">size_t</span>    num_entries;</span><br><span class="line">    <span class="comment">// 数组 weak_entries 的长度减一，求数组索引时需要用到。</span></span><br><span class="line">    <span class="type">uintptr_t</span> mask;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    记录在存储元素时遇到的最大的哈希冲突次数。</span></span><br><span class="line"><span class="comment">    在查找元素的时候会被用到，</span></span><br><span class="line"><span class="comment">    如果查找过程中哈希冲突次数大于这个值就说明哈希表中没有要找的数据。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uintptr_t</span> max_hash_displacement;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正用来存储弱引用数据的结构。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">weak_entry_t</span> &#123;</span><br><span class="line">    <span class="comment">// weak 指针所指向的那个对象（类似哈希表中的 key）。</span></span><br><span class="line">    id referent;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    从以下代码可以发现：系统内部在存储弱引用数据的时候有 2 套方案，</span></span><br><span class="line"><span class="comment">    如果数据比较少就使用静态数组 inline_referrers 存储；</span></span><br><span class="line"><span class="comment">    如果数据比较多就使用动态数组 referrers 存储。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="comment">// 用来存储弱引用的动态数组。</span></span><br><span class="line">            id *referrers;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            一个标记位，如果这个值是 2 的话就表示使用的是动态数组。</span></span><br><span class="line"><span class="comment">            因为 objc 对象的内存地址的最后一位只会是 0x8 或 0x0，</span></span><br><span class="line"><span class="comment">            即：如果采用的是静态数组方案的话，这个位置的数据绝对是 0。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="type">uintptr_t</span>        out_of_line_ness : <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 数组 referrers 的元素数量。</span></span><br><span class="line">            <span class="type">uintptr_t</span>        num_refs : <span class="number">62</span>;</span><br><span class="line">            <span class="comment">// 数组 referrers 的长度减一，和 weak_table_t 中的 mask 功能一样。</span></span><br><span class="line">            <span class="type">uintptr_t</span>        mask;</span><br><span class="line">            <span class="comment">// 和 weak_table_t 中的 max_hash_displacement 功能一样。</span></span><br><span class="line">            <span class="type">uintptr_t</span>        max_hash_displacement;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="comment">// 用来存储弱引用的静态数组。</span></span><br><span class="line">            id inline_referrers[<span class="number">4</span>];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>你可以把 SideTable 理解成一个获取弱引用表的入口，weak_table 类似一个大哈希表，这个哈希表的 key 是 objc 对象，value 是对应的弱引用数组。关于 weak 指针的操作，例如解除关联和建立关联，其实就是从 weak_table 中获取其对应的弱引用数组，然后从这个数组中移除或添加对应的弱指针地址。</p>
<h2 id="weak-指针自动赋值-nil-的实现细节：weak-clear-no-lock"><a href="#weak-指针自动赋值-nil-的实现细节：weak-clear-no-lock" class="headerlink" title="weak 指针自动赋值 nil 的实现细节：weak_clear_no_lock"></a>weak 指针自动赋值 nil 的实现细节：weak_clear_no_lock</h2><p>众所周知，weak 指针在对象被释放之后会自动指向 nil，那么它到底是如何实现的呢？</p>
<p>关于释放流程的函数调用顺序这里就不具体展开了，在 <a target="_blank" rel="noopener" href="https://github.com/apple-oss-distributions/objc4/tree/objc4-906">objc4-906</a> 版本中，其函数调用顺序如下：dealloc &#x3D;&gt; _objc_rootDealloc &#x3D;&gt; rootDealloc &#x3D;&gt; object_dispose &#x3D;&gt; objc_destructInstance &#x3D;&gt; clearDeallocating &#x3D;&gt; clearDeallocating_slow &#x3D;&gt; weak_clear_no_lock，我们重点看一下最后一个函数 <code>weak_clear_no_lock</code> 的实现细节。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">weak_clear_no_lock</span><span class="params">(<span class="type">weak_table_t</span> *weak_table, id referent_id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 正在释放的对象。</span></span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前对象对应的弱引用表。</span></span><br><span class="line">    <span class="type">weak_entry_t</span> *entry = <span class="built_in">weak_entry_for_referent</span>(weak_table, referent);</span><br><span class="line">    <span class="keyword">if</span> (entry == nil) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">weak_referrer_t</span> *referrers;</span><br><span class="line">    <span class="type">size_t</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取弱指针数组和数组容量。</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;<span class="built_in">out_of_line</span>()) &#123;</span><br><span class="line">        referrers = entry-&gt;referrers;</span><br><span class="line">        count = (entry-&gt;mask ? entry-&gt;mask + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        referrers = entry-&gt;inline_referrers;</span><br><span class="line">        count = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重点：系统会遍历弱指针数组中的每个地址，并将它们赋值为 nil。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        objc_object **referrer = referrers[i];</span><br><span class="line">        <span class="keyword">if</span> (referrer) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*referrer == referent) &#123;<span class="comment">// 等价于 weakSelf == self(self 表示当前正在释放的对象)</span></span><br><span class="line">                *referrer = nil;<span class="comment">// 等价于 weakSelf = nil;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*referrer) &#123;</span><br><span class="line">                <span class="built_in">REPORT_WEAK_ERROR</span>(<span class="string">&quot;__weak variable at %p holds %p instead of %p. &quot;</span></span><br><span class="line">                                  <span class="string">&quot;This is probably incorrect use of &quot;</span></span><br><span class="line">                                  <span class="string">&quot;objc_storeWeak() and objc_loadWeak().&quot;</span>,</span><br><span class="line">                                  referrer, (<span class="type">void</span>*)*referrer, (<span class="type">void</span>*)referent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从弱引用表中移除这张表。</span></span><br><span class="line">    <span class="built_in">weak_entry_remove</span>(weak_table, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中不难发现，系统会在对象释放的时候，获取其对应的弱引用表，然后遍历这个表中的 weak 指针并将其赋值为 nil。</p>
<p>到此为止，关于 weak 指针的所有内容就讲完了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 runtime 初始化的时候，会调用一个全局函数 <code>side_tables_init</code> 初始化一个全局数组，数组的元素是 SideTable 对象，可以通过全局函数 <code>SideTables</code> 拿到这个数组以及对象对应的 SideTable 对象。</p>
<p>SideTable 中有一个变量 weak_table，你可以将它理解成一个哈希表，哈希表的 key 是对象，value 是一个数组，数组中的元素就是指向这个 key 的 weak 指针地址。</p>
<p>weak 指针的初始化操作就是拿到这个对象对应的弱指针数组，然后往数组里面把 weak 指针的内存地址添加进去。</p>
<p>如果 weak 指针需要指向别的对象，需要拿到旧对象对应的弱指针数组并将数组中存放 weak 指针的那个位置置空，然后拿到新对象对应的弱指针数组并将 weak 指针添加进去。</p>
<p>如果对象释放了，就拿到这个对象对应的弱指针数组并挨个将里面的 weak 指针赋值为 nil。</p>
<p>为了加深自己的理解，我模仿系统的实现写了一个示例项目 <a target="_blank" rel="noopener" href="https://github.com/internetWei/WeakPointer">WeakPointer</a>，我在这个项目里还给分类属性也支持了 weak 特性，感兴趣的同学可以参考一下。</p>
<h2 id="关于-weak-指针的一些疑问与解答"><a href="#关于-weak-指针的一些疑问与解答" class="headerlink" title="关于 weak 指针的一些疑问与解答"></a>关于 weak 指针的一些疑问与解答</h2><h3 id="为什么不能给-Category-添加-weak-属性？"><a href="#为什么不能给-Category-添加-weak-属性？" class="headerlink" title="为什么不能给 Category 添加 weak 属性？"></a>为什么不能给 Category 添加 weak 属性？</h3><p>我们一般是这样初始化一个 weak 指针：<code>__weak id weakPtr = obj;</code>，从源码中我们知道编译器会把代码转换成这样：<code>objc_storeWeak((void *)&amp;weakPtr, obj);</code>。</p>
<p>从这里可以发现，要实现 weak 特性，你必须能拿到 obj 对象和 weak 指针的内存地址，而 Category 中的属性是依靠 runtime 中的 <code>objc_setAssociatedObject</code> 和 <code>objc_getAssociatedObject</code> 这 2 个函数来实现的，我们拿不到 weak 指针的内存地址，故而无法给 Category 的属性支持 weak 特性。</p>
<p>类的属性之所以支持 weak 特性，是因为编译器能拿到这个属性的成员变量的地址（即 weak 指针的内存地址）。</p>
<p>如果你一定要给 Category 添加 weak 属性的话，有以下 2 个思路（建议选择第 2 个）：</p>
<ol>
<li><p>参考我的这个项目 <a target="_blank" rel="noopener" href="https://github.com/internetWei/WeakPointer">WeakPointer</a> 模仿系统的实现手动维护一个弱引用表来支持 Category 的 weak 属性。</p>
</li>
<li><p>创建一个中间类，给中间类声明一个 weak 属性，Category 的属性强引用这个中间类，中间类的 weak 属性指向真正的对象。</p>
<p> 示例代码：</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WeakTarget</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="type">id</span> weakObj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span>(<span class="title">Category</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="type">id</span> weakObj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span> (<span class="title">Category</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setWeakObj:(<span class="built_in">NSObject</span> *)obj &#123;</span><br><span class="line">    WeakTarget *target = [[WeakTarget alloc] init];</span><br><span class="line">    target.weakObj = obj;</span><br><span class="line"></span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(weakObj), target, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)weakObj &#123;</span><br><span class="line">    WeakTarget *target = objc_getAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(weakObj));</span><br><span class="line">    <span class="keyword">return</span> target.weakObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">WeakTarget</span> @<span class="title">end</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="为什么在-block-中不能使用-weak-指针访问其成员变量。"><a href="#为什么在-block-中不能使用-weak-指针访问其成员变量。" class="headerlink" title="为什么在 block 中不能使用 weak 指针访问其成员变量。"></a>为什么在 block 中不能使用 weak 指针访问其成员变量。</h3><p>这是我在项目中实际遇到的一个问题，伪代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    weakSelf-&gt;_propertyName;<span class="comment">// 使用 weak 指针直接访问成员变量。</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面的代码无法通过编译，如果改成这样就没问题了：<code>weakSelf.propertyName;</code>。</p>
<p>众所周知，在 objc 里访问属性最终还是会访问成员变量。那为什么访问属性就正常，访问成员变量就会报错呢？</p>
<p>之所以会这样，是因为现在的编译器比较智能，考虑的比较多。weakSelf 在运行时有可能为 nil 从而导致崩溃，编译器认为这样的代码不安全所以报错。但是使用 weakSelf 访问属性是安全的，因为访问属性实际上是调用了属性的 get&#x2F;set 方法，在 objc 里对 nil 调用方法是不会导致异常。</p>
<p>上面的报错代码可以改成以下代码来解决编译报错：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="keyword">if</span> (weakSelf) &#123;<span class="comment">// 这一步很重要，因为这里的 weak 指针有可能已经是 nil 了。</span></span><br><span class="line">        __<span class="keyword">strong</span> <span class="keyword">typeof</span>(weakSelf) strongSelf = weakSelf;</span><br><span class="line">        strongSelf-&gt;_propertyName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="为什么在对象没有弱引用时也会执行-weak-clear-no-lock"><a href="#为什么在对象没有弱引用时也会执行-weak-clear-no-lock" class="headerlink" title="为什么在对象没有弱引用时也会执行 weak_clear_no_lock"></a>为什么在对象没有弱引用时也会执行 weak_clear_no_lock</h3><p>在研究 weak 指针自动赋值 nil 的过程中，我发现，对象只要曾经被 weak 指针指向过，在对象释放的时候即使没有指向它的 weak 指针，也会执行到 weak_clear_no_lock 函数。</p>
<p>在 storeWeak 函数中会调用这行代码设置对象被 weak 指针指向的标记：<code>newObj-&gt;setWeaklyReferenced_nolock();</code>。</p>
<p>但是，当对象没有任何 weak 指针指向时，weak_unregister_no_lock 函数中并没有调用相关函数将标记设置为 false。</p>
<p>这会导致在对象释放的时候，即调用到 rootDealloc 函数时无法执行快速释放逻辑。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">objc_object::rootDealloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isTaggedPointer</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(<span class="built_in">isa</span>().nonpointer                     &amp;&amp;</span><br><span class="line">    <span class="comment">// 如果对象曾经被 weak 指针指向过，即使现在没有了，weakly_referenced 也是 true。</span></span><br><span class="line">                 !<span class="built_in">isa</span>().weakly_referenced             &amp;&amp;</span><br><span class="line">                 !<span class="built_in">isa</span>().has_assoc                     &amp;&amp;</span><br><span class="line">                 !<span class="built_in">isa</span>().<span class="built_in">getClass</span>(<span class="literal">false</span>)-&gt;<span class="built_in">hasCxxDtor</span>() &amp;&amp;</span><br><span class="line">                 !<span class="built_in">isa</span>().has_sidetable_rc)) &#123;</span><br><span class="line">        <span class="built_in">free</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">object_dispose</span>((id)<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我也不太清楚为什么这么做？如果你知道其中的具体细节的话，还请留言告知。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">布多</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://internetwei.github.io/2023/10/21/iOS/揭开 iOS 中 weak 指针的神秘面纱：从原理到实践/">https://internetwei.github.io/2023/10/21/iOS/揭开 iOS 中 weak 指针的神秘面纱：从原理到实践/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://internetwei.github.io">布多的博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ObjC/">ObjC</a><a class="post-meta__tags" href="/tags/Runtime/">Runtime</a><a class="post-meta__tags" href="/tags/Category/">Category</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2024/04/28/iOS/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3iOS%E4%B8%AD%E7%9A%84RunLoop/"><i class="fa fa-chevron-left">  </i><span>深入理解iOS中的RunLoop</span></a></div><div class="next-post pull-right"><a href="/2022/07/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%85%8E%E7%94%A8unsigned%E7%B1%BB%E5%9E%8B/"><span>慎用unsigned类型</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="lv-container" data-id="city" data-uid="MTAyMC81MzU5Ny8zMDA3MA=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div><footer class="footer-bg" style="background-image: url(images/backgroundImage.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2025 By 布多</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>