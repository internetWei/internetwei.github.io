<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="ObjC 开发规范"><meta name="keywords" content="ObjC"><meta name="author" content="布多"><meta name="copyright" content="布多"><title>ObjC 开发规范 | 布多的博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?f0d94d3f99211c3546490e469f6ecbd8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '6.3.0'
} </script><link rel="alternate" href="/atom.xml" title="布多的博客" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%88%99"><span class="toc-number">2.</span> <span class="toc-text">原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E8%A7%84%E8%8C%83"><span class="toc-number">3.</span> <span class="toc-text">通用规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6%E8%A7%84%E8%8C%83"><span class="toc-number">4.</span> <span class="toc-text">头文件规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Block%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83"><span class="toc-number">5.</span> <span class="toc-text">Block开发规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%9F%A5%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83"><span class="toc-number">6.</span> <span class="toc-text">通知开发规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">7.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.jpg"></div><div class="author-info__name text-center">布多</div><div class="author-info__description text-center">前进！前进！！不择手段地前进！！！</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/internetwei">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">11</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">9</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">4</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友链</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.coderqi.com/">齐小胖之家</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/images/backgroundImage.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">布多的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/about">关于</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">ObjC 开发规范</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-01-20</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/">iOS</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/">开发规范</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">5k</span><span class="post-meta__separator">|</span><span>阅读时长: 16 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>由 布多(budo) 发布于 2022-01-20 • 最后更新于 2025-02-13</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章是基于笔者个人经验以及一些开发规范总结而成，目的是提高公司内部项目的稳定性与效率。<br>文章的前半部分是一些通用开发规范，适用于所有编程语言甚至是生活中遇到的问题；<br>后半部分是关于OC的开发规范以及开发中容易犯的错误，如果不想看可以跳过。</p>
<h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><p>我们无法写出完全没有BUG的代码，但是我们可以尽量写出容易阅读和逻辑简单清楚的代码，容易阅读和逻辑简单清楚的代码从某种程度上会减少BUG以及BUG的修复难度。</p>
<h2 id="通用规范"><a href="#通用规范" class="headerlink" title="通用规范"></a>通用规范</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">虽然BUG无法完全避免，但是我们可以遵循一些规范和规则让BUG尽早暴露，或者让它便于排查。</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>[必须]</strong> 开发完一个模块(<code>功能、页面等等</code>)时，自测一遍，确认没有问题后再开发下一个模块，如果一个模块很大，可以完成一个小功能时自测一遍，不要把所有问题都放到最后测试，更不要依赖测试人员。</p>
</li>
<li><p><strong>[必须]</strong> 禁止实现未来可能需要的功能，如果这个功能现在不需要就不要实现它，等未来需要的时候再去实现它，因为那个时候你可以更清晰的看到那个功能完整的模样(<code>如果必须要实现它，必须要考虑所有可能发生的情况以及细节，并且加上注释说明</code>)。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">实现一个未来可能需要的功能在大部分情况下都是得不偿失的，有以下缺点：</span><br><span class="line">1. 未来可能不需要这个功能。</span><br><span class="line">2. 增加垃圾代码，当别人看见这段代码时不理解为什么要这么写。</span><br><span class="line">3. 增加维护成本和开发时间(即使某段代码不使用也是需要维护的)。</span><br><span class="line">4. 后期真正要用的时候可能会发现当初实现的时候考虑不全面，最后还是要重新写一遍。</span><br><span class="line">5. ……</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>[必须]</strong> 不要尝试去推测并解决未来可能发生的问题，等问题出现的时候再去解决它，因为那个时候你可以更清晰的看见问题的真实样子。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">这个规则不是说要你发现问题了不去解决等到被别人发现提出后再解决；</span><br><span class="line">现实生活中有一些完美主义者想让自己写的代码非常完美没有任何问题，所以他们会尽</span><br><span class="line">量假设各种各样的情况，甚至很多极端情况，有时候会为了一个发生概率很小并且</span><br><span class="line">影响不是很重要的问题而大改特改，直到满意为止，这么做很可能会影响别人甚至导致项目延迟上线。</span><br><span class="line">在修改过程中如果改动的范围特别大还可能会引进新的问题，而且由于这个问题是未来</span><br><span class="line">可能会发生的问题，所以可能还会有你没考虑到的地方，最后既引进了新的问题还可能没解决问题。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>[必须]</strong> 对于服务端返回的值，永远不要假设它是正确的类型和值(<code>即使服务端的人保证</code>)，使用之前必须检查它的真实类型和值是否符合预期。</p>
</li>
<li><p><strong>[必须]</strong> 不要让代码脱离开发者的掌控。当我们开发一个功能时，总是希望让使用者调用更少的API或者自动调用，但是有些步骤让使用者主动调用会更好一些，这样使用者知道他干了什么，而不是出了问题时一头雾水，当你把某个步骤设置成自动调用时想一下这是否有必要？如果不是请让使用者主动调用它并在文档中加以说明。</p>
</li>
<li><p><strong>[必须]</strong> 所见即所得，例如页面上2个控件的间距是10，那么代码中的间距设置也应该是10，而不应该是一个控件很高，有很多的空白区域，然后用-xx(负间距)去填充。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">UILabel *label1 = [[UILabel alloc] init];</span><br><span class="line">label1.frame = CGRectMake(0, 0, 100, 30);</span><br><span class="line"></span><br><span class="line">UILabel *label2 = [[UILabel alloc] init];</span><br><span class="line">label2.frame = CGRectMake(0, 30 + 10, 100, 30);</span><br><span class="line">上述代码明显的告诉你 label2 的顶部和 label1 的底部间距为10。</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">UILabel *label1 = [[UILabel alloc] init];</span><br><span class="line">label1.frame = CGRectMake(0, 0, 100, 30);</span><br><span class="line"></span><br><span class="line">UILabel *label2 = [[UILabel alloc] init];</span><br><span class="line">label2.frame = CGRectMake(0, -20, 100, 90);</span><br><span class="line">假设文字实际展示需要 30 高度，上述代码和正例中的代码给用户的感觉是一样的，</span><br><span class="line">但是阅读性却非常差。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>[必须]</strong> 一般情况下禁止使用过时的方法或类，应该及时去了解和使用新方法或类。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">对于过时的方法或类，大都是因为其自身有缺陷或BUG，</span><br><span class="line">使用新方法前建议了解一下旧方法/类废弃的原因。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>[必须]</strong> 尽量不要使用runtime去交换方法，可以使用中间者模式或者其他方法代替，如果一定要这么做，那么请留下注释说明交换方法后做了什么，以及为什么要这么做？</p>
</li>
<li><p><strong>[必须]</strong> 尽量不要直接使用成员变量，而是使用属性替代它。</p>
</li>
<li><p><strong>[必须]</strong> 在dealloc方法内禁止将self传递出去，如果self被retain，到下个runloop周期再释放则会多次释放导致crash。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反例：</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [self unsafeMethod:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>[必须]</strong> 对剪切板的读取操作必须放在子线程中进行，因为用户可能在Mac上复制大量数据然后通过接力同步到iPhone上。</p>
</li>
<li><p><strong>[必须]</strong> 当方法可能会提前return时，需要注意对象的释放问题，避免内存泄漏。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反例：</span><br><span class="line">CFArrayRef arrayRef = (__bridge CFArrayRef)array;</span><br><span class="line"></span><br><span class="line">if (x == YES) return;</span><br><span class="line"> </span><br><span class="line">CFRelease(arrayRef);</span><br><span class="line"></span><br><span class="line">如果if条件成立那么arrayRef对象就会内存泄漏。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>[必须]</strong> 使用@try处理异常时，需要注意对象的释放问题，避免内存泄漏。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反例：</span><br><span class="line">@try &#123;</span><br><span class="line">CFArrayRef arrayRef = (__bridge CFArrayRef)array;</span><br><span class="line">    </span><br><span class="line">do some thing……</span><br><span class="line"></span><br><span class="line">CFRelease(arrayRef);</span><br><span class="line">        </span><br><span class="line">&#125; @catch (NSException *exception) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果do some thing……出现异常的话那么arrayRef就会出现内存泄漏。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>[必须]</strong> 如果使用到的值和另一个值有所关联，在代码中体现出这种关联性，这能增加代码可读性，也能增加代码稳定性。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">例如有1个头像控件需要显示为圆形，我们经常会这样设置：</span><br><span class="line">1. 给头像控件设置圆角：layer.cornerRadius = 15.0;</span><br><span class="line">2. 给头像控件设置宽高：.frame = CGRectMake(0, 0, 30.0, 30.0);</span><br><span class="line">// 上述代码中的15.0 和 30.0 就没有任何关联性，如果它们之间相隔了很多代码，</span><br><span class="line">   修改宽高的时候可能会忘记修改cornerRadius。</span><br><span class="line">   </span><br><span class="line">正例：</span><br><span class="line">1. 给头像控件设置圆角：layer.cornerRadius = 15.0;</span><br><span class="line">2. 给头像控件设置宽高：.frame = CGRectMake(0, 0, layer.cornerRadius * 2.0, layer.cornerRadius * 2.0);</span><br><span class="line">// 这样后面阅读代码的人一眼就能明白宽高和 layer.cornerRadius 的关系，既增加了可读性，又增加了稳定性。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>[必须]</strong> 如果一个值需要特别多个变量计算出来，请把它们提取成一个变量并且加上注释说明这个变量是怎么组成的。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">// 屏幕宽度 - label左边距 - label右边距 - 开关按钮宽度 - 按钮右边距</span><br><span class="line">    CGFloat titleMaxWidth = kScreenWidth - labelLeftSpacing - labelRightSpacing - buttonWidth - buttonRightSpacing;</span><br><span class="line"></span><br><span class="line">// 这样写的好处在于以后如果需要修改某个控件的布局信息，只需要修改一处即可，降低了后续维护难度。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>[建议]</strong> 声明常量尽量使用const类型，不要使用#define。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips: </span><br><span class="line">宏定义声明常量的缺点：</span><br><span class="line">1. 宏定义只是简单的替换，缺少编译检查，运行期可能会出现溢出或数据错误等问题。</span><br><span class="line">2. 宏定义缺少类型，不方便编写文档用例。</span><br><span class="line">3. 宏定义可能会被替换。</span><br><span class="line">4. 宏定义无法编写符合规范的注释信息。</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">#define kTime @&quot;10&quot;</span><br><span class="line">    </span><br><span class="line">if (NO) &#123;</span><br><span class="line">#define kTime @&quot;20&quot;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">NSLog(@&quot;time = %@&quot;, kTime);</span><br><span class="line"></span><br><span class="line">即使if永远不会执行，但是编译器也会将kTime替换为@&quot;20&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>[建议]</strong> 工具类尽量在头文件的注释中写清楚该功能如何使用，以及需要注意的事项。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">1. 如果是一个UI工具，使用时是否需要提前设置frame，是否可以使用约束布局？</span><br><span class="line">2. 对于一些比较复杂的工具，最好在注释中给出一段示例代码。</span><br><span class="line">包括但不限于上述的注意事项，</span><br><span class="line">例如一个封装好的弹窗工具，应该说明如何弹出，是否需要提前设置frame或者约束</span><br><span class="line"></span><br><span class="line">以下是一个简单的示例伪代码:</span><br><span class="line">/**</span><br><span class="line">* @brief UIActivityIndicatorView的增强版，和UIActivityIndicatorView使用方式一致，但扩展了一些额外功能。</span><br><span class="line">* @discussion 1. 除了可以自定义颜色之外，还可以自定义指示器的详细大小(例如指示器宽度、高度、离心距离等)。</span><br><span class="line">* @discussion 2. 内部会自动计算控件所需要的最小宽高，可以不设置宽高约束或宽高Frame。</span><br><span class="line">* @discussion 3. 可以暂停/恢复指示器动画。</span><br><span class="line">* @code</span><br><span class="line">* LLActivityIndicatorView *activityIndicatorView = [LLActivityIndicatorView activityIndicatorWithStyle:LLActivityIndicatorViewStyleGrayMedium];</span><br><span class="line">* activityIndicatorView.backgroundColor = UIColor.redColor;</span><br><span class="line">* activityIndicatorView.frame = CGRectMake(0, 0, 50, 50);</span><br><span class="line">* activityIndicatorView.center = self.view.center;</span><br><span class="line">* [self.view addSubview:activityIndicatorView];</span><br><span class="line">* [activityIndicatorView startAnimating];</span><br><span class="line">* @encode</span><br><span class="line">*/</span><br><span class="line">@interface LLActivityIndicatorView : UIView</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>[必须]</strong> 不要滥用懒加载，只在必要时刻使用它。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">只在以下三种情况下才使用懒加载：</span><br><span class="line">1. 对象的创建需要依赖其他对象</span><br><span class="line">2. 对象可能被使用，也可能不被使用</span><br><span class="line">3. 对象创建比较消耗性能</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>[必须]</strong> 使用NSUserDefaults存储数据时禁止调用synchronize方法，因为系统会在合适的时机将数据保存到本地(即使程序闪退等极端情况)。</p>
</li>
<li><p><strong>[建议]</strong> 对于一些体积小并且不是特别重要的数据，不要频繁的进行写入操作，可以使用NSUserDefaults。它会在合适的时机将数据存储到本地，这避免了频繁的写入操作，而且在某些极端情况下它也能保证数据存储到本地(例如程序闪退等情况)。</p>
</li>
<li><p><strong>[必须]</strong> 添加到集合中的对象应该是不可变的，或者在加入之后其哈希值是不可变的。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反例：</span><br><span class="line">NSMutableSet *sets = [NSMutableSet set];</span><br><span class="line">NSMutableString *string1 = [NSMutableString stringWithString:@&quot;1&quot;];</span><br><span class="line">[sets addObject:string1];</span><br><span class="line">[sets addObject:@&quot;12&quot;];</span><br><span class="line">    </span><br><span class="line">[string1 appendString:@&quot;2&quot;];</span><br><span class="line"></span><br><span class="line">当 [string1 appendString:@&quot;2&quot;] 执行完以后sets对象内会包含2个@&quot;12&quot;。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>[必须]</strong> 不可变对象请使用copy修饰，如果重写set方法，请注意调用copy方法。</p>
</li>
<li><p><strong>[必须]</strong> 请使用CGRectGet函数获取Frame的各种值，而不是通过frame.的方式获取。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">CGRect t_frame = CGRectMake(-10, -10, -10, -10);</span><br><span class="line">当一个view的frame设置成t_frame后，其坐标会隐式的转换为CGRectMake(-20, -20, 10, 10)，</span><br><span class="line">因为宽高不可能出现负值；</span><br><span class="line">这时通过t_frame.的方式获取的值都是错误的，而CGRectGet会自动帮您处理这些隐式转换。</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line">CGRectGetWidth(frame)、CGRectGetMinX(frame)、CGRectGetMaxX(frame)</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">frame.size.width、frame.origin.x、frame.size.width + frame.origin.x</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>[必须]</strong> 代码中单行字符数不要超过150个，超过请换行(空格除外)，可以在 Xcode -&gt; Preferences… -&gt; Text Editing -&gt; Page guide at column 中设置为150方便排查。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">- (void)setImageWithURL:(nullable NSURL *)imageURL</span><br><span class="line">            placeholder:(nullable UIImage *)placeholder</span><br><span class="line">                options:(YYWebImageOptions)options</span><br><span class="line">               progress:(nullable YYWebImageProgressBlock)progress</span><br><span class="line">               ransform:(nullable YYWebImageTransformBlock)transform</span><br><span class="line">             completion:(nullable YYWebImageCompletionBlock)completion;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>[建议]</strong> 单个方法的行数建议不超过80行，注释、左右大括号、空行、回车等除外。</p>
</li>
<li><p><strong>[必须]</strong> 在多线程环境下谨慎使用可变集合，必要时候可以采用加锁或GCD的同步线程进行保护，或者在访问可变集合时先将其copy为不可变对象然后再对其访问。</p>
</li>
<li><p><strong>[必须]</strong> 属性和方法必须有 <strong>nullable</strong> 或 <strong>nonnull</strong> 限定符，由于OC是动态语言，所以即使使用 <code>nonnull</code> 声明对象不为空，使用前也必须判断是否为空。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">- (void)setName:(NSString * _Nonnull)name &#123;</span><br><span class="line">    if (name == nil) &#123;</span><br><span class="line">      ………</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>[必须]</strong> 如果有使用到数组、字典等类型，尽量使用泛型声明其包含的类型，这样可以提高代码可读性。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">NSArray&lt;NSString *&gt; *array;</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">NSArray *array;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>[必须]</strong> 如果类中包含多个初始化方法，请使用 <code>NS_DESIGNATED_INITIALIZER</code> 和 <code>NS_UNAVAILABLE</code> 宏标记提高代码可读性。</p>
</li>
<li><p><strong>[必须]</strong> 避免使用无符号整数(除非匹配系统接口使用的类型)，在工程中全部使用一种类型可以提高代码安全与一致性，无符号整数在进行数学运算和倒数到零的时候会出现细微的错误。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">NSUInteger numberOfObjects = array.count;</span><br><span class="line">for (NSInteger counter = numberOfObjects - 1; counter &gt; 0; counter--)</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">for (NSUInteger counter = numberOfObjects - 1, counter &gt; 0; counter--)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>[必须]</strong> 在自动引用计数下，OC对象会自动初始化为nil，但是有些对象不会自动初始化为nil，例如CoreFoundation中的对象，所以在声明局部对象时需要手动初始化。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">NSObject *obj = nil;</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">NSObject *obj;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>[必须]</strong> 不要使用一个类去维护多个类的内容，例如使用一个常量类维护所有的常量，要按功能进行归类，分开维护。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips: </span><br><span class="line">大而全的类，杂乱无章，使用查找功能才能定位到具体位置，不利于理解也不利于维护。</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line">缓存相关常量类放在CacheConsts下，系统配置相关常量类放在SystemConfigConsts下。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>[必须]</strong> 如果超类的某个初始化方法不适用于子类，那么子类一定要重写超类的这个方法解决问题或抛出异常。</p>
</li>
<li><p><strong>[必须]</strong> 把一些稳定的、公共的变量或者方法抽取到父类中。子类尽量只维持父类所不具备的特性和功能。</p>
</li>
<li><p><strong>[必须]</strong> 禁止将布尔对象直接和 YES 或者 NO进行判断，例如 &#x3D;&#x3D; YES， !&#x3D; YES，&#x3D;&#x3D; NO，!&#x3D; NO。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">在32位机器上YES被定义为1，NO定义为0；</span><br><span class="line">而64位机器上YES被定义为非0，NO定义为0；</span><br><span class="line"></span><br><span class="line">BOOL result = 4;</span><br><span class="line"></span><br><span class="line">if (result == YES) &#123;</span><br><span class="line">    NSLog(@&quot;YES&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    NSLog(@&quot;NO&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">以上代码在64位机器会输出YES，而上32位机器上则会输出NO。因为在32位机器上 </span><br><span class="line">(result == YES) 会被解释为 (4 == (signed int) 1)，</span><br><span class="line">所以会输出NO，而在64位机器上会认为result不等于0所以输出YES。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>[必须]</strong> 删除代码时将内部用到的无用文件、无用类、无用函数等统一删除干净。</p>
</li>
<li><p><strong>[建议]</strong> 如果可以，尽量使用 #undef 限制宏的作用范围。</p>
</li>
<li><p><strong>[建议]</strong> 局部变量尽量定义在最靠近使用它的地方。</p>
</li>
<li><p><strong>[建议]</strong> 在写一些简单的类方法和宏方法时，尽量使用内联函数或全局函数代替它。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">函数不通过对象调用，所以不会走OC的消息转发流程，效率高于方法调用；</span><br><span class="line">而且函数会有返回值和参数类型以及参数检查，这些都是宏定义没有的。</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line">UIKIT_STATIC_INLINE NSString * kNSStringFromInteger(NSInteger a) &#123;</span><br><span class="line">    return [NSString stringWithFormat:@&quot;%zd&quot;, a];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">#define kNSStringFromInteger(a) [NSString stringWithFormat:@&quot;%zd&quot;, a]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>[建议]</strong> 如果用到了很多协议，必要时可以把协议封装到一个单独的头文件中，这样做不仅可以减少编译时间，还能避免循环引用。</p>
</li>
<li><p><strong>[建议]</strong> 使用switch枚举时尽量将所有枚举类型都case出来而不要使用default，这样的话以后增加或删除枚举类型时如果switch没有处理的话编译器会有警告提醒。</p>
</li>
<li><p><strong>[建议]</strong> 尽量使用字面量语法创建对象，少用与之等价的方法。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips:</span><br><span class="line">OC中的NSArray、NSString、NSDictionary、NSNumber都有与之对应的字面量语法: @[]、@&quot;&quot;、@&#123;&#125;、@()；</span><br><span class="line">使用它们有以下优点：</span><br><span class="line">1. 简单易读，提高代码的可读性和维护性。</span><br><span class="line">2. 使用字面量创建数组、字典时如果元素里在nil则会抛出异常，</span><br><span class="line">   而使用arrayWithObjects:方法创建则会丢失nil后的数据，</span><br><span class="line">   抛出异常能让你知道这里有问题及时修改防止问题在线上发生。</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">1. 使用字面量创建的对象默认是不可变的，如果要创建可变对象需要进行mutableCopy操作。</span><br><span class="line">2. 不支持子类，如果你创建了一个NSString的子类，@&quot;&quot;并不会返回你想要的子类对象。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>[建议]</strong> UI控件尽量使用weak修饰而不是strong修饰，这样对梳理对象引用会更清晰明了。</p>
</li>
<li><p><strong>[建议]</strong> 尽量不要使用+load方法，如果必须要使用那么不要在方法内实现复杂逻辑或堵塞线程。</p>
</li>
<li><p><strong>[建议]</strong> 尽量减少继承层级，类的继承建议不要超过3层，必要时刻可以考虑用分类、协议来代替继承。</p>
</li>
</ul>
<h2 id="头文件规范"><a href="#头文件规范" class="headerlink" title="头文件规范"></a>头文件规范</h2><ul>
<li><p><strong>[必须]</strong> 头文件中尽量不要直接引用其他头文件，而是使用@class向前声明，每次引入其他头文件时先问问自己是否必须要这样做。</p>
</li>
<li><p><strong>[建议]</strong> 头文件中暴露的方法和属性尽可能少，例如外部只需要覆值操作，那就不要提供getter方法或者属性。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">@interface BookView : NSObject</span><br><span class="line"></span><br><span class="line">- (void)setBookName:(NSString *)bookName;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line">@interface BookView : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSString *bookName;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>[建议]</strong> 头文件中的属性尽量声明为只读，可以在实现文件中再将属性声明为可读可写。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正例：</span><br><span class="line">@interface WXYZModel : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, readonly) NSString *name;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface WXYZModel ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSString *name;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation WXYZModel</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Block开发规范"><a href="#Block开发规范" class="headerlink" title="Block开发规范"></a>Block开发规范</h2><ul>
<li><p><strong>[必须]</strong> 在Block内部使用上下文的对象时要注意相互引用的问题(<code>不一定要在 block 内使用 self 才会相互引用</code>)。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips: </span><br><span class="line">1. 不一定在Block内使用self才会相互引用，如下情况也会造成循环引用:</span><br><span class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">    WXYZ_TitleTableViewCell *cell = ………</span><br><span class="line">    </span><br><span class="line">    cell.refreshTableViewBlock = ^&#123;</span><br><span class="line">        [tableView reloadData];</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    return cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2. Block内部是否要使用weak需要看Block本身和weak的这个对象是否存在直接或间接的相互引用，</span><br><span class="line">   若无相互引用则不需要使用weak。</span><br><span class="line"></span><br><span class="line">3. 如果Block内部使用了strong修饰了外部的weak变量，那么当使用strong指向成员变量时需要进行判空，否则会崩溃，参考以下代码:</span><br><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">    cell.refreshTableViewBlock = ^&#123;</span><br><span class="line">        __strong typeof(weakSelf) strongSelf = weakSelf;</span><br><span class="line">        if (strongSelf != nil) &#123;</span><br><span class="line">            strongSelf-&gt;_name = @&quot;name&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">如果把(strongSelf != nil)的判断去掉那么可能会崩溃。</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="通知开发规范"><a href="#通知开发规范" class="headerlink" title="通知开发规范"></a>通知开发规范</h2><ul>
<li><p><strong>[必须]</strong> 在发送通知时，请使用<code>userInfo</code>对象进行传值，而不是<code>object</code>。</p>
</li>
<li><p><strong>[必须]</strong> 避免重复注册通知，这会导致重复执行通知方法。</p>
</li>
<li><p><strong>[必须]</strong> 在使用通知的<code>object</code>参数时，需要确保接收方和发送方的object对象类型是一致的。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反例：</span><br><span class="line">[NSNotificationCenter.defaultCenter addObserver:self selector:@selector(testFunction) name:@&quot;testNotificationName&quot; object:model.bookID];</span><br><span class="line">[NSNotificationCenter.defaultCenter postNotificationName:@&quot;testNotificationName&quot; object:@&quot;123&quot;];</span><br><span class="line"></span><br><span class="line">假设 model.bookID 的值就是字符串123，也可能无法收到通知，</span><br><span class="line">因为NSString有__NSCFConstantString， __NSCFString， NSTaggedPointerString等多个子类对象，</span><br><span class="line">如果 model.bookID 的真实对象类型是 NSTaggedPointerString 的话就会收不到通知。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>[建议]</strong> 在工程里能不用通知尽量不用通知，通知虽然灵活强大，但是如果滥用会导致工程质量下降并且增加维护难度。</p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/25829244/">Effective Objective-C 2.0  编写高质量iOS与OS X代码的52个有效方法</a></li>
<li><a target="_blank" rel="noopener" href="https://google.github.io/styleguide/objcguide.html">Google的Objective-C风格指南</a></li>
<li><a target="_blank" rel="noopener" href="https://google.github.io/eng-practices/review/reviewer/">Google的代码审查指南</a></li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">布多</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://budo.top/2022/01/20/iOS/ObjC 开发规范/">https://budo.top/2022/01/20/iOS/ObjC 开发规范/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://budo.top">布多的博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ObjC/">ObjC</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/01/20/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/Code%20Reivew%E8%A7%84%E8%8C%83/"><i class="fa fa-chevron-left">  </i><span>Code Review规范</span></a></div><div class="next-post pull-right"><a href="/2021/08/11/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/"><span>Git命令手册</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="lv-container" data-id="city" data-uid="MTAyMC81MzU5Ny8zMDA3MA=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div><footer class="footer-bg" style="background-image: url(/images/backgroundImage.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2025 By 布多</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>