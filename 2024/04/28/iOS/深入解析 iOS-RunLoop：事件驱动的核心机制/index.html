<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="深入解析 iOS-RunLoop：事件驱动的核心机制"><meta name="keywords" content="RunLoop"><meta name="author" content="布多"><meta name="copyright" content="布多"><title>深入解析 iOS-RunLoop：事件驱动的核心机制 | 布多的博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?f0d94d3f99211c3546490e469f6ecbd8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '6.3.0'
} </script><link rel="alternate" href="/atom.xml" title="布多的博客" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Even-Loop"><span class="toc-number">2.</span> <span class="toc-text">什么是 Even Loop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RunLoop-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">RunLoop 的工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RunLoop-%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-number">4.</span> <span class="toc-text">RunLoop 的实现细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RunLoop-%E5%85%A5%E5%8F%A3"><span class="toc-number">4.1.</span> <span class="toc-text">RunLoop 入口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RunLoop-%E6%A0%B8%E5%BF%83"><span class="toc-number">4.2.</span> <span class="toc-text">RunLoop 核心</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RunLoop-%E4%B8%8E-RunLoopMode"><span class="toc-number">5.</span> <span class="toc-text">RunLoop 与 RunLoopMode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-CommonModes"><span class="toc-number">6.</span> <span class="toc-text">关于 CommonModes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RunLoop-%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">7.</span> <span class="toc-text">RunLoop 与线程的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8B%B9%E6%9E%9C%E5%88%A9%E7%94%A8-RunLoop-%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">8.</span> <span class="toc-text">苹果利用 RunLoop 实现的功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AutoreleasePool-%E4%B8%8E-RunLoop"><span class="toc-number">8.1.</span> <span class="toc-text">AutoreleasePool 与 RunLoop</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.jpg"></div><div class="author-info__name text-center">布多</div><div class="author-info__description text-center">前进！前进！！不择手段地前进！！！</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/internetwei">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">11</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">9</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">4</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友链</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.coderqi.com/">齐小胖之家</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/images/backgroundImage.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">布多的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/about">关于</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">深入解析 iOS-RunLoop：事件驱动的核心机制</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2024-04-28</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/">iOS</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">3.3k</span><span class="post-meta__separator">|</span><span>阅读时长: 13 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>由 布多(budo) 发布于 2024-04-28 • 最后更新于 2025-03-21</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>RunLoop 是 iOS 开发中的一个基础概念，苹果有许多功能都依赖于 RunLoop，例如线程中的自动释放池、NSTimer、系统事件响应、屏幕刷新等。本文将深入剖析 iOS 中 RunLoop 的内部实现细节，帮助你更好地理解这一机制。</p>
<h2 id="什么是-Even-Loop"><a href="#什么是-Even-Loop" class="headerlink" title="什么是 Even Loop"></a>什么是 Even Loop</h2><p>在讨论 RunLoop 之前，先了解一下线程的基本概念。通常，线程执行完一个任务后就会退出，要重新执行任务只能再创建一个新线程。但如果我们希望线程在处理完任务后不退出，而是等待并处理新的任务，就需要一种机制来保持线程的活动状态，这就是 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Event_loop">Even Loop</a>（事件循环）。</p>
<p>在 iOS 中，这个机制由 RunLoop 实现。它是一个持续运行的循环，负责管理线程中的事件和消息，确保线程在没有任务时进入休眠状态，在有任务时被唤醒并处理。</p>
<h2 id="RunLoop-的工作原理"><a href="#RunLoop-的工作原理" class="headerlink" title="RunLoop 的工作原理"></a>RunLoop 的工作原理</h2><p>RunLoop 本质上是一个对象，它管理需要处理的事件。线程启动 RunLoop 后，会一直处理「接受消息 -&gt; 处理消息 -&gt; 等待消息」的循环中，实现逻辑大致如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">startRunLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var message = <span class="built_in">get_next_message</span>();</span><br><span class="line">        <span class="built_in">process_message</span>(message);</span><br><span class="line">    &#125; <span class="keyword">while</span> (message != quit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RunLoop-的实现细节"><a href="#RunLoop-的实现细节" class="headerlink" title="RunLoop 的实现细节"></a>RunLoop 的实现细节</h2><p>在 iOS 中，RunLoop 通过两个对象提供：NSRunLoop 和 CFRunLoopRef。其中，NSRunLoop 是 CFRunLoopRef 的封装，提供了面向对象的 API。</p>
<p>RunLoop 被包含在开源项目 <a href="ttps://github.com/apple-oss-distributions/CF">Core Foundation</a> 中，你可以下载查看。</p>
<blockquote>
<p>本文使用的 Core Foundation 版本是 <a target="_blank" rel="noopener" href="https://github.com/apple-oss-distributions/CF/releases/tag/CF-1153.18">CF-1153.18</a>，为了方便阅读，我对代码样式和排版略作了修改以及删减了一些不影响主逻辑的冗余代码。</p>
</blockquote>
<h3 id="RunLoop-入口"><a href="#RunLoop-入口" class="headerlink" title="RunLoop 入口"></a>RunLoop 入口</h3><p>首先看看 CFRunLoopRun 和 CFRunLoopRunInMode 的实现，这两个函数负责启动 RunLoop：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用默认 Mode 启动。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CFRunLoopRun</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int32_t</span> result;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        result = <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- modeName: 指定要使用的 Mode。</span></span><br><span class="line"><span class="comment">- seconds: 设置 RunLoop 的超时时间。</span></span><br><span class="line"><span class="comment">- returnAfterSourceHandled: 如果是YES，则运行完后立即返回。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">SInt32 <span class="title">CFRunLoopRunInMode</span><span class="params">(CFStringRef modeName,</span></span></span><br><span class="line"><span class="params"><span class="function">                          CFTimeInterval seconds,</span></span></span><br><span class="line"><span class="params"><span class="function">                          Boolean returnAfterSourceHandled)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(),</span><br><span class="line">                                modeName,</span><br><span class="line">                                seconds,</span><br><span class="line">                                returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用 <code>CFRunLoopRunSpecific</code>，RunLoop 会进入具体的模式进行运行，直到满足退出的条件。</p>
<p>接下来的关键函数是 CFRunLoopRunSpecific，它会获取指定的 Mode，然后进入 RunLoop，相关代码整理后如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">SInt32 <span class="title">CFRunLoopRunSpecific</span><span class="params">(CFRunLoopRef rl,</span></span></span><br><span class="line"><span class="params"><span class="function">                            CFStringRef modeName,</span></span></span><br><span class="line"><span class="params"><span class="function">                            CFTimeInterval seconds,</span></span></span><br><span class="line"><span class="params"><span class="function">                            Boolean returnAfterSourceHandled)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取对应 Mode。</span></span><br><span class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果当前 Mode 下没有任何事件，立即返回。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == currentMode ||</span><br><span class="line">        __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) &#123;</span><br><span class="line">        <span class="keyword">return</span> kCFRunLoopRunFinished;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把 Loop 当前的数据临时保存起来。</span></span><br><span class="line">    <span class="keyword">volatile</span> _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl);</span><br><span class="line">    CFRunLoopModeRef previousMode = rl-&gt;_currentMode;</span><br><span class="line">    rl-&gt;_currentMode = currentMode;</span><br><span class="line">    <span class="type">int32_t</span> result = kCFRunLoopRunFinished;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通知 Observer，即将进入 Loop。</span></span><br><span class="line">    <span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry) &#123;</span><br><span class="line">        __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进入 RunLoop。</span></span><br><span class="line">	result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通知 Observer，即将退出 Loop。</span></span><br><span class="line">    <span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopExit) &#123;</span><br><span class="line">        __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复之前保存的临时数据。</span></span><br><span class="line">    __CFRunLoopPopPerRunData(rl, previousPerRun);</span><br><span class="line">    <span class="comment">// 把 Mode 恢复成之前的 Mode。</span></span><br><span class="line">    rl-&gt;_currentMode = previousMode;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RunLoop-核心"><a href="#RunLoop-核心" class="headerlink" title="RunLoop 核心"></a>RunLoop 核心</h3><p>在 <code>__CFRunLoopRun</code> 中，RunLoop 会进入 do while 循环，不断检查并处理事件，直到满足退出条件（超时、手动停止等）。核心的实现依赖于 <code>mach_msg</code> 函数，系统会调用这个函数将线程置于休眠状态，等待消息的到来，每当有事件（例如来自 <code>mach_port</code> 的消息或定时器触发）时，RunLoop 会被唤醒处理相关事件。相关代码整理后如下所示（函数有点长，不想看可以跳过，后面有解释）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int32_t</span> __CFRunLoopRun(CFRunLoopRef rl,</span><br><span class="line">                              CFRunLoopModeRef rlm,</span><br><span class="line">                              CFTimeInterval seconds,</span><br><span class="line">                              Boolean stopAfterHandle,</span><br><span class="line">                              CFRunLoopModeRef previousMode) &#123;</span><br><span class="line">    <span class="type">uint64_t</span> startTSR = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line">    <span class="type">mach_port_name_t</span> dispatchPort = MACH_PORT_NULL;</span><br><span class="line">    </span><br><span class="line">    <span class="type">dispatch_source_t</span> timeout_timer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">__timeout_context</span> *timeout_context = (<span class="keyword">struct</span> __timeout_context *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(*timeout_context));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (seconds &lt;= <span class="number">0.0</span>) &#123;</span><br><span class="line">        timeout_context-&gt;termTSR = <span class="number">0ULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123;</span><br><span class="line">        <span class="comment">// ... 对 timeout_timer 和 timeout_context 的初始化及其它操作。</span></span><br><span class="line">        <span class="comment">// 感兴趣的同学可以自行阅读源码。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置 RunLoop 的目标超时时间，比如当前是第 10 秒，</span></span><br><span class="line">        <span class="comment">// 超时时间是 100 秒，那目标超时时间就是第 110 秒。</span></span><br><span class="line">        timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注册 RunLoop 超时回调。</span></span><br><span class="line">        <span class="built_in">dispatch_source_set_event_handler_f</span>(timeout_timer, __CFRunLoopTimeout);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        timeout_context-&gt;termTSR = UINT64_MAX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Boolean didDispatchPortLastTime = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int32_t</span> retVal = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进入 RunLoop</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">voucher_mach_msg_state_t</span> voucherState = VOUCHER_MACH_MSG_STATE_UNCHANGED;</span><br><span class="line">        <span class="type">voucher_t</span> voucherCopy = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">uint8_t</span> msg_buffer[<span class="number">3</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="type">mach_msg_header_t</span> *msg = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">mach_port_t</span> livePort = MACH_PORT_NULL;</span><br><span class="line">        __CFPortSet waitSet = rlm-&gt;_portSet;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知 Observer，即将处理 Timer。</span></span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) &#123;</span><br><span class="line">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知 Observer，即将处理 Source。</span></span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) &#123;</span><br><span class="line">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用户可能会在 observer 中添加 Block，</span></span><br><span class="line">        <span class="comment">// 这里需要处理它们。</span></span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行 Source0 事件。</span></span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 同理，用户可能在 Source 中添加 Block。</span></span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果有 Source1 事件，则处理它然后跳到 handle_msg 去处理消息。</span></span><br><span class="line">        <span class="keyword">if</span> (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;</span><br><span class="line">            msg = (<span class="type">mach_msg_header_t</span> *)msg_buffer;</span><br><span class="line">            <span class="keyword">if</span> (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, <span class="built_in">sizeof</span>(msg_buffer), &amp;livePort, <span class="number">0</span>, &amp;voucherState, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">                <span class="keyword">goto</span> handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        didDispatchPortLastTime = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知 Observer，即将进入休眠。</span></span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting) &#123;</span><br><span class="line">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        msg = (<span class="type">mach_msg_header_t</span> *)msg_buffer;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         线程进入休眠，并监听 mach port 消息。</span></span><br><span class="line"><span class="comment">         直到被下面的某个事件唤醒：</span></span><br><span class="line"><span class="comment">         1. 基于 port 的 Source 事件。</span></span><br><span class="line"><span class="comment">         2. Timer 事件。</span></span><br><span class="line"><span class="comment">         3. RunLoop 的超时时间到了。</span></span><br><span class="line"><span class="comment">         4. 被其它调用者手动唤醒。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="built_in">sizeof</span>(msg_buffer), &amp;livePort, TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知 Observer，从休眠中唤醒。</span></span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting) &#123;</span><br><span class="line">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理消息：</span></span><br><span class="line">        handle_msg:;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理通过 Timer 唤醒的事件。</span></span><br><span class="line">        <span class="keyword">if</span> (livePort == rlm-&gt;_timerPort) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!__CFRunLoopDoTimers(rl, rlm, <span class="built_in">mach_absolute_time</span>())) &#123;</span><br><span class="line">                <span class="comment">// Re-arm the next timer</span></span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理通过 GCD 唤醒的事件，例如 dispatch 到 main_queue 的 block。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (livePort == dispatchPort) &#123;</span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            sourceHandledThisLoop = <span class="literal">true</span>;</span><br><span class="line">            didDispatchPortLastTime = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理通过 Source1 唤醒的事件。</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</span><br><span class="line">            <span class="keyword">if</span> (rls) &#123;</span><br><span class="line">                <span class="type">mach_msg_header_t</span> *reply = <span class="literal">NULL</span>;</span><br><span class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">NULL</span> != reply) &#123;</span><br><span class="line">                    (<span class="type">void</span>)<span class="built_in">mach_msg</span>(reply, MACH_SEND_MSG, reply-&gt;msgh_size, <span class="number">0</span>, MACH_PORT_NULL, <span class="number">0</span>, MACH_PORT_NULL);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行添加到 Loop 中的 Block。</span></span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         进入 Loop 时设置了 stopAfterHandle 为 YES，</span></span><br><span class="line"><span class="comment">         意思是处理完事件就返回。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// RunLoop 运行超时了。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timeout_context-&gt;termTSR &lt; <span class="built_in">mach_absolute_time</span>()) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// RunLoop 被外部强行停止了。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunStopped;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前运行的 Mode 被停止了。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</span><br><span class="line">            rlm-&gt;_stopped = <span class="literal">false</span>;</span><br><span class="line">            retVal = kCFRunLoopRunStopped;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Mode 里没有要处理的事件了。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunFinished;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果参数没说运行完就结束、没超时、Loop 没被停止、Mode 没被停止、Mode 不为空；则继续。</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span> == retVal);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中不难发现，RunLoop 内部其实就是一个 <code>do while</code> 循环，当线程启动 RunLoop 后，就会一直处于这个循环里，有任务时就处理任务，每次处理完 Source1 任务后都会判断一下是否满足退出条件（超时、强行停止、任务列表为空等），如果不满足就进入下一轮。</p>
<p>RunLoop 的核心实现依赖于 <code>mach_msg()</code>，这个函数在 <code>__CFRunLoopServiceMachPort</code> 内部调用。RunLoop 调用 <code>mach_msg()</code> 之后，内核就会将线程置于休眠状态，直到有 port 发送消息或定时器触发。</p>
<p>你可以使用 Xcode 运行一个 iOS 项目，然后在 APP 静止时点击暂停，此时你会看到主线程调用栈停留在一个叫做 <code>mach_msg2_trap()</code> 的函数中。</p>
<p>我画了一个 RunLoop 运行流程图，请参考下图：</p>
<p><img src="runloop0.png" alt="RunLoop 运行流程图"></p>
<h2 id="RunLoop-与-RunLoopMode"><a href="#RunLoop-与-RunLoopMode" class="headerlink" title="RunLoop 与 RunLoopMode"></a>RunLoop 与 RunLoopMode</h2><p>一个 RunLoop 可能会包含多个 Mode，每个 Mode 又可能包含若干个 Source、Timer、Observer。相关代码整理后如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">__CFRunLoop</span> *CFRunLoopRef;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RunLoop 的底层结构。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__CFRunLoop</span> &#123;</span><br><span class="line">    CFMutableSetRef _commonModes;</span><br><span class="line">    CFMutableSetRef _commonModeItems;</span><br><span class="line">    CFRunLoopModeRef _currentMode;</span><br><span class="line">    CFMutableSetRef _modes;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">__CFRunLoopMode</span> *CFRunLoopModeRef;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RunLoopMode 的底层结构。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__CFRunLoopMode</span> &#123;</span><br><span class="line">    CFStringRef _name;<span class="comment">// Mode 的名称。</span></span><br><span class="line">    CFMutableSetRef _sources0;<span class="comment">// 包含所有 Source0，一个 Set。</span></span><br><span class="line">    CFMutableSetRef _sources1;<span class="comment">// 包含所有 Source1，一个 Set。</span></span><br><span class="line">    CFMutableArrayRef _observers;<span class="comment">// 包含所有 Observer，一个 Array。</span></span><br><span class="line">    CFMutableArrayRef _timers;<span class="comment">// 包含所有 Timer，一个 Array。</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>RunLoop 与 Mode 的关系如下图所示：</p>
<p><img src="runloop1.png" alt="RunLoop 与 Mode 的关系"></p>
<p>RunLoop 每次只能指定一个 Mode 运行，这个 Mode 被称为 currentMode。如果需要切换 Mode，只能退出 Loop，然后重新指定 Mode 运行。这样做的目的是为了将不同的 Source、Timer、Observer 分隔开，避免它们相互干扰。</p>
<p>Mode 内部有以下三种类型的事件：</p>
<p><strong>CFRunLoopSourceRef</strong> 表示所有 source0 和 source1 事件。</p>
<ul>
<li>source0 只包含一个函数指针回调，它不能主动触发事件，只能先调用 <code>CFRunLoopSourceSignal(source)</code> 将这个 Source 标记为待处理，然后调用 <code>CFRunLoopWakeUp(runloop)</code> 唤醒 RunLoop 去处理被标记的事件。</li>
<li>source1 是 mach port 发出的事件，被用于通过内核和其它进程相互发送消息，这种事件可以主动唤醒 RunLoop。</li>
</ul>
<p><strong>CFRunLoopTimerRef</strong> 是一个定时器事件，它和 NSTimer 是免费桥接的，当它被加入到 RunLoop 后，RunLoop 会在对应的时间点注册事件，当时间点到达时 Loop 会被唤醒并处理这个事件。</p>
<p><strong>CFRunLoopObserverRef</strong> 是一个观察者事件，当 RunLoop 的状态发生变化时，开发者可以通过注册 Observer 来响应这些变化，可以观察的状态有以下 6 个：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1UL</span> &lt;&lt; <span class="number">0</span>), <span class="comment">// 即将进入 Loop。</span></span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1UL</span> &lt;&lt; <span class="number">1</span>), <span class="comment">// 即将处理 Timer。</span></span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1UL</span> &lt;&lt; <span class="number">2</span>), <span class="comment">// 即将处理 Source。</span></span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">5</span>), <span class="comment">// 即将进入休眠。</span></span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">6</span>), <span class="comment">// 从休眠中唤醒。</span></span><br><span class="line">    kCFRunLoopExit = (<span class="number">1UL</span> &lt;&lt; <span class="number">7</span>), <span class="comment">// 即将退出 Loop。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上的 Source、Timer、Observer 统称为 mode item，一个 item 不能重复加入同一个 Mode，但是可以同时加入多个 mode 中，另外，如果 mode 里没有 item，则 RunLoop 会直接退出，不会进入到循环中。</p>
<h2 id="关于-CommonModes"><a href="#关于-CommonModes" class="headerlink" title="关于 CommonModes"></a>关于 CommonModes</h2><p>CommonModes 是一个特殊的概念，其允许一个事件同时在多个 Mode 中触发。通过 <code>CFRunLoopAddCommonMode</code> 函数，可以将某个 Mode 标记为 “Common” 模式，这样该模式下的事件就会自动同步到其它 Mode 中去。例如，我们可以在 <code>CFRunLoopAddCommonMode</code> 中添加一个定时器，这样它就能同时在多个模式下运行。</p>
<p>相关实现代码精简后如下所示（不想看可以跳过，后面有解释）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CFRunLoopAddObserver</span><span class="params">(CFRunLoopRef rl, CFRunLoopObserverRef rlo, CFStringRef modeName)</span> </span>&#123;</span><br><span class="line">    CFRunLoopModeRef rlm;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (modeName == kCFRunLoopCommonModes) &#123;</span><br><span class="line">        CFSetRef set = rl-&gt;_commonModes ? <span class="built_in">CFSetCreateCopy</span>(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == rl-&gt;_commonModeItems) &#123;</span><br><span class="line">            rl-&gt;_commonModeItems = <span class="built_in">CFSetCreateMutable</span>(kCFAllocatorSystemDefault, <span class="number">0</span>, &amp;kCFTypeSetCallBacks);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">CFSetAddValue</span>(rl-&gt;_commonModeItems, rlo);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != set) &#123;</span><br><span class="line">            CFTypeRef context[<span class="number">2</span>] = &#123;rl, rlo&#125;;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             这里会遍历 rl-&gt;_commonModes 中的所有 Mode，</span></span><br><span class="line"><span class="comment">             然后执行 __CFRunLoopAddItemToCommonModes，</span></span><br><span class="line"><span class="comment">             把事件添加到每个具体的 Mode 中去。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">CFSetApplyFunction</span>(set, (__CFRunLoopAddItemToCommonModes), (<span class="type">void</span> *)context);</span><br><span class="line">            <span class="built_in">CFRelease</span>(set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 非 NSRunLoopCommonModes 的处理逻辑。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CFRunLoopAddCommonMode</span><span class="params">(CFRunLoopRef rl, CFStringRef modeName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">CFSetContainsValue</span>(rl-&gt;_commonModes, modeName)) &#123;</span><br><span class="line">        CFSetRef set = rl-&gt;_commonModeItems ? <span class="built_in">CFSetCreateCopy</span>(kCFAllocatorSystemDefault, rl-&gt;_commonModeItems) : <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">CFSetAddValue</span>(rl-&gt;_commonModes, modeName);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != set) &#123;</span><br><span class="line">            CFTypeRef context[<span class="number">2</span>] = &#123;rl, modeName&#125;;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             把 modeName 对应 Mode 中的所有事件，</span></span><br><span class="line"><span class="comment">             同步到 rl-&gt;_commonModeItems 的所有 Mode 中去。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">CFSetApplyFunction</span>(set, (__CFRunLoopAddItemsToCommonMode), (<span class="type">void</span> *)context);</span><br><span class="line">            <span class="built_in">CFRelease</span>(set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面提到的 CFRunLoopAddObserver 函数，还有两个函数和它类似：CFRunLoopAddTimer 和 CFRunLoopAddSource，它们的内部实现原理基本一致，所以我只介绍了 CFRunLoopAddObserver。</p>
<p>当你往 NSRunLoopCommonModes 中添加一个事件时，系统会拿到 _commonModes 并遍历其每个 Mode，然后为其添加这个事件。</p>
<p>当你调用 CFRunLoopAddCommonMode 将某个 Mode 标记为 “Common” 模式时，系统会取出这个 Mode 中的所有事件，然后遍历 _commonModes 并给每个 Mode 添加这些事件。</p>
<h2 id="RunLoop-与线程的关系"><a href="#RunLoop-与线程的关系" class="headerlink" title="RunLoop 与线程的关系"></a>RunLoop 与线程的关系</h2><p>每个线程都有自己独立的 RunLoop，iOS 不允许我们创建 RunLoop，但提供了两个函数来获取当前线程和主线程的 RunLoop：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取主线程中的 RunLoop。</span></span><br><span class="line"><span class="function">CFRunLoopRef <span class="title">CFRunLoopGetMain</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> CFRunLoopRef __main = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!__main) __main = _CFRunLoopGet0(<span class="built_in">pthread_main_thread_np</span>());</span><br><span class="line">    <span class="keyword">return</span> __main;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前线程的 RunLoop。</span></span><br><span class="line"><span class="function">CFRunLoopRef <span class="title">CFRunLoopGetCurrent</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从当前线程的局部存储中获取 RunLoop 对象。</span></span><br><span class="line">    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);</span><br><span class="line">    <span class="keyword">if</span> (rl) <span class="keyword">return</span> rl;</span><br><span class="line">    <span class="keyword">return</span> _CFRunLoopGet0(<span class="built_in">pthread_self</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局 Dict，key 是线程，value 是 RunLoop。</span></span><br><span class="line"><span class="type">static</span> CFMutableDictionaryRef __CFRunLoops = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(<span class="type">pthread_t</span> t) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     第 1 次获取 RunLoop 对象时，</span></span><br><span class="line"><span class="comment">     自动创建全局 Dict 和主线程的 RunLoop。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!__CFRunLoops) &#123;</span><br><span class="line">        CFMutableDictionaryRef dict = <span class="built_in">CFDictionaryCreateMutable</span>(kCFAllocatorSystemDefault, <span class="number">0</span>,</span><br><span class="line">                                      <span class="literal">NULL</span>, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">        CFRunLoopRef mainLoop = __CFRunLoopCreate(<span class="built_in">pthread_main_thread_np</span>());</span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(dict, <span class="built_in">pthreadPointer</span>(<span class="built_in">pthread_main_thread_np</span>()), mainLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    CFRunLoopRef loop = (CFRunLoopRef)<span class="built_in">CFDictionaryGetValue</span>(__CFRunLoops, <span class="built_in">pthreadPointer</span>(t));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">        <span class="comment">// 如果当前线程还没有 RunLoop，创建一个新的。</span></span><br><span class="line">        CFRunLoopRef newLoop = __CFRunLoopCreate(t);</span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(__CFRunLoops, <span class="built_in">pthreadPointer</span>(t), newLoop);</span><br><span class="line">        loop = newLoop;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_equal</span>(t, <span class="built_in">pthread_self</span>())) &#123;</span><br><span class="line">        _CFSetTSD(__CFTSDKeyRunLoop, (<span class="type">void</span> *)loop, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</span><br><span class="line">            <span class="comment">// 注册一个回调，当线程销毁时，顺便销毁其对应的 RunLoop。</span></span><br><span class="line">            _CFSetTSD(__CFTSDKeyRunLoopCntr, </span><br><span class="line">            (<span class="type">void</span> *)(PTHREAD_DESTRUCTOR_ITERATIONS<span class="number">-1</span>), </span><br><span class="line">            (<span class="built_in">void</span> (*)(<span class="type">void</span> *))__CFFinalizeRunLoop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中不难发现，线程和 RunLoop 的关系是一一对应的，其关系保存在一个全局字典中。另外，iOS 会为每个线程懒加载 RunLoop 对象，并在线程销毁时自动释放它。</p>
<p>我们只能获取当前线程的 RunLoop 对象（主线程的 RunLoop 除外）。</p>
<h2 id="苹果利用-RunLoop-实现的功能"><a href="#苹果利用-RunLoop-实现的功能" class="headerlink" title="苹果利用 RunLoop 实现的功能"></a>苹果利用 RunLoop 实现的功能</h2><h3 id="AutoreleasePool-与-RunLoop"><a href="#AutoreleasePool-与-RunLoop" class="headerlink" title="AutoreleasePool 与 RunLoop"></a>AutoreleasePool 与 RunLoop</h3><p>网络上有一些这方面相关的旧文章，他们会告诉你：iOS 在 APP 启动后会往主线程的 RunLoop 里注册多个 Observer，用来监听以下三种状态：</p>
<p>即将进入 RunLoop：创建 AutoreleasePool。</p>
<p>RunLoop 准备休眠：释放之前创建的 AutoreleasePool，然后创建一个新的 AutoreleasePool。</p>
<p>RunLoop 即将退出：释放之前创建的 AutoreleasePool。</p>
<p>但是，根据我的调试发现，新的 RunLoop 已经不是上述逻辑了。系统会在每个任务的执行前后自动插入相关代码来实现 AutoreleasePool 的创建和释放操作，而不是等到线程休眠前才释放。</p>
<!-- 关于 AutoreleasePool 的更多实现细节，请阅读我写的另一篇文章：\</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">布多</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://budo.top/2024/04/28/iOS/深入解析 iOS-RunLoop：事件驱动的核心机制/">https://budo.top/2024/04/28/iOS/深入解析 iOS-RunLoop：事件驱动的核心机制/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://budo.top">布多的博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/RunLoop/">RunLoop</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2024/12/11/iOS/2024%20%E5%86%8D%E6%8E%A2ObjC-Category%EF%BC%9A%E5%8A%A8%E6%80%81%E7%89%B9%E6%80%A7%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%9E%81%E8%87%B4%E4%B9%8B%E7%BE%8E/"><i class="fa fa-chevron-left">  </i><span>2024 再探ObjC-Category：动态特性与运行时实现的极致之美</span></a></div><div class="next-post pull-right"><a href="/2023/10/21/iOS/%E6%8F%AD%E5%BC%80%20iOS%20%E4%B8%AD%20weak%20%E6%8C%87%E9%92%88%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1%EF%BC%9A%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5/"><span>揭开 iOS 中 weak 指针的神秘面纱：从原理到实践</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="lv-container" data-id="city" data-uid="MTAyMC81MzU5Ny8zMDA3MA=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div><footer class="footer-bg" style="background-image: url(/images/backgroundImage.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2025 By 布多</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>