<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="深入解析 iOS-RunLoop：事件驱动的核心机制"><meta name="keywords" content="RunLoop"><meta name="author" content="布多"><meta name="copyright" content="布多"><title>深入解析 iOS-RunLoop：事件驱动的核心机制 | 布多的博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?f0d94d3f99211c3546490e469f6ecbd8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '6.3.0'
} </script><link rel="alternate" href="/atom.xml" title="布多的博客" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Even-Loop"><span class="toc-number">2.</span> <span class="toc-text">什么是 Even Loop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RunLoop-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">RunLoop 的工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RunLoop-%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-number">4.</span> <span class="toc-text">RunLoop 的实现细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RunLoop-%E5%85%A5%E5%8F%A3"><span class="toc-number">4.1.</span> <span class="toc-text">RunLoop 入口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RunLoop-%E6%A0%B8%E5%BF%83"><span class="toc-number">4.2.</span> <span class="toc-text">RunLoop 核心</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RunLoop-%E4%B8%8E-RunLoopMode"><span class="toc-number">5.</span> <span class="toc-text">RunLoop 与 RunLoopMode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-CommonModes"><span class="toc-number">6.</span> <span class="toc-text">关于 CommonModes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RunLoop-%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">7.</span> <span class="toc-text">RunLoop 与线程的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8B%B9%E6%9E%9C%E5%88%A9%E7%94%A8-RunLoop-%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">8.</span> <span class="toc-text">苹果利用 RunLoop 实现的功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AutoreleasePool-%E4%B8%8E-RunLoop"><span class="toc-number">8.1.</span> <span class="toc-text">AutoreleasePool 与 RunLoop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NSTimer-%E4%B8%8E-RunLoop"><span class="toc-number">8.2.</span> <span class="toc-text">NSTimer 与 RunLoop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PerformSelector-%E4%B8%8E-RunLoop"><span class="toc-number">8.3.</span> <span class="toc-text">PerformSelector 与 RunLoop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GCD-%E4%B8%8E-RunLoop"><span class="toc-number">8.4.</span> <span class="toc-text">GCD 与 RunLoop</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%91%E4%BB%AC%E8%83%BD%E5%88%A9%E7%94%A8-RunLoop-%E5%B9%B2%E4%BB%80%E4%B9%88"><span class="toc-number">9.</span> <span class="toc-text">我们能利用 RunLoop 干什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#APP-%E5%8D%A1%E9%A1%BF%E7%9B%91%E6%8E%A7"><span class="toc-number">9.1.</span> <span class="toc-text">APP 卡顿监控</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BF%9D%E6%B4%BB"><span class="toc-number">9.2.</span> <span class="toc-text">线程保活</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">9.3.</span> <span class="toc-text">性能优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RunLoop-%E7%9B%B8%E5%85%B3%E7%96%91%E6%83%91"><span class="toc-number">10.</span> <span class="toc-text">RunLoop 相关疑惑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CommonModes-%E4%B8%AD%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%98%AF%E5%A6%82%E4%BD%95%E5%90%8C%E6%AD%A5%E7%9A%84%EF%BC%9F"><span class="toc-number">10.1.</span> <span class="toc-text">CommonModes 中的任务是如何同步的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">11.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">12.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.jpg"></div><div class="author-info__name text-center">布多</div><div class="author-info__description text-center">前进！前进！！不择手段地前进！！！</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/internetwei">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">12</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">10</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">4</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友链</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.coderqi.com/">齐小胖之家</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/images/backgroundImage.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">布多的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/about">关于</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">深入解析 iOS-RunLoop：事件驱动的核心机制</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2024-04-28</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/">iOS</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">4.6k</span><span class="post-meta__separator">|</span><span>阅读时长: 17 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>由 布多(budo) 发布于 2024-04-28 • 最后更新于 2025-03-21</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>RunLoop 是 iOS 开发中的一个基础概念，苹果有许多功能都依赖于 RunLoop，例如线程中的自动释放池、NSTimer、系统事件响应、屏幕刷新等。本文将深入剖析 iOS 中 RunLoop 的内部实现细节，帮助你更好地理解这一机制。</p>
<h2 id="什么是-Even-Loop"><a href="#什么是-Even-Loop" class="headerlink" title="什么是 Even Loop"></a>什么是 Even Loop</h2><p>在讨论 RunLoop 之前，先了解一下线程的基本概念。通常，线程执行完一个任务后就会退出，要重新执行任务只能再创建一个新线程。但如果我们希望线程在处理完任务后不退出，而是等待并处理新的任务，就需要一种机制来保持线程的活动状态，这就是 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Event_loop">Even Loop</a>（事件循环）。</p>
<p>在 iOS 中，这个机制由 RunLoop 实现。它是一个持续运行的循环，负责管理线程中的事件和消息，确保线程在没有任务时进入休眠状态，在有任务时被唤醒并处理。</p>
<h2 id="RunLoop-的工作原理"><a href="#RunLoop-的工作原理" class="headerlink" title="RunLoop 的工作原理"></a>RunLoop 的工作原理</h2><p>RunLoop 本质上是一个对象，它管理需要处理的事件。线程启动 RunLoop 后，会一直处理「接受消息 -&gt; 处理消息 -&gt; 等待消息」的循环中，实现逻辑大致如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">startRunLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var message = <span class="built_in">get_next_message</span>();</span><br><span class="line">        <span class="built_in">process_message</span>(message);</span><br><span class="line">    &#125; <span class="keyword">while</span> (message != quit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RunLoop-的实现细节"><a href="#RunLoop-的实现细节" class="headerlink" title="RunLoop 的实现细节"></a>RunLoop 的实现细节</h2><p>在 iOS 中，RunLoop 通过两个对象提供：NSRunLoop 和 CFRunLoopRef。其中，NSRunLoop 是 CFRunLoopRef 的封装，提供了面向对象的 API。</p>
<p>RunLoop 被包含在开源项目 <a target="_blank" rel="noopener" href="https://github.com/apple-oss-distributions/CF">Core Foundation</a> 中，你可以下载查看。</p>
<blockquote>
<p>本文使用的 Core Foundation 版本是 <a target="_blank" rel="noopener" href="https://github.com/apple-oss-distributions/CF/releases/tag/CF-1153.18">CF-1153.18</a>，为了方便阅读，我对代码样式和排版略作了修改以及删减了一些不影响主逻辑的冗余代码。</p>
</blockquote>
<h3 id="RunLoop-入口"><a href="#RunLoop-入口" class="headerlink" title="RunLoop 入口"></a>RunLoop 入口</h3><p>首先看看 CFRunLoopRun 和 CFRunLoopRunInMode 的实现，这两个函数负责启动 RunLoop：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用默认 Mode 启动。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CFRunLoopRun</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int32_t</span> result;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        result = <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- modeName: 指定要使用的 Mode。</span></span><br><span class="line"><span class="comment">- seconds: 设置 RunLoop 的超时时间。</span></span><br><span class="line"><span class="comment">- returnAfterSourceHandled: 如果是YES，则运行完后立即返回。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">SInt32 <span class="title">CFRunLoopRunInMode</span><span class="params">(CFStringRef modeName,</span></span></span><br><span class="line"><span class="params"><span class="function">                          CFTimeInterval seconds,</span></span></span><br><span class="line"><span class="params"><span class="function">                          Boolean returnAfterSourceHandled)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(),</span><br><span class="line">                                modeName,</span><br><span class="line">                                seconds,</span><br><span class="line">                                returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用 <code>CFRunLoopRunSpecific</code>，RunLoop 会进入具体的模式进行运行，直到满足退出的条件。</p>
<p>接下来的关键函数是 CFRunLoopRunSpecific，它会获取指定的 Mode，然后进入 RunLoop，相关代码整理后如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">SInt32 <span class="title">CFRunLoopRunSpecific</span><span class="params">(CFRunLoopRef rl,</span></span></span><br><span class="line"><span class="params"><span class="function">                            CFStringRef modeName,</span></span></span><br><span class="line"><span class="params"><span class="function">                            CFTimeInterval seconds,</span></span></span><br><span class="line"><span class="params"><span class="function">                            Boolean returnAfterSourceHandled)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取对应 Mode。</span></span><br><span class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果当前 Mode 下没有任何事件，立即返回。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == currentMode ||</span><br><span class="line">        __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) &#123;</span><br><span class="line">        <span class="keyword">return</span> kCFRunLoopRunFinished;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把 Loop 当前的数据临时保存起来。</span></span><br><span class="line">    <span class="keyword">volatile</span> _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl);</span><br><span class="line">    CFRunLoopModeRef previousMode = rl-&gt;_currentMode;</span><br><span class="line">    rl-&gt;_currentMode = currentMode;</span><br><span class="line">    <span class="type">int32_t</span> result = kCFRunLoopRunFinished;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通知 Observer，即将进入 Loop。</span></span><br><span class="line">    <span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry) &#123;</span><br><span class="line">        __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进入 RunLoop。</span></span><br><span class="line">	result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通知 Observer，即将退出 Loop。</span></span><br><span class="line">    <span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopExit) &#123;</span><br><span class="line">        __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复之前保存的临时数据。</span></span><br><span class="line">    __CFRunLoopPopPerRunData(rl, previousPerRun);</span><br><span class="line">    <span class="comment">// 把 Mode 恢复成之前的 Mode。</span></span><br><span class="line">    rl-&gt;_currentMode = previousMode;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RunLoop-核心"><a href="#RunLoop-核心" class="headerlink" title="RunLoop 核心"></a>RunLoop 核心</h3><p>在 <code>__CFRunLoopRun</code> 中，RunLoop 会进入 do while 循环，不断检查并处理事件，直到满足退出条件（超时、手动停止等）。核心的实现依赖于 <code>mach_msg</code> 函数，系统会调用这个函数将线程置于休眠状态，等待消息的到来，每当有事件（例如来自 <code>mach_port</code> 的消息或定时器触发）时，RunLoop 会被唤醒处理相关事件。相关代码整理后如下所示（函数有点长，不想看可以跳过，后面有解释）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int32_t</span> __CFRunLoopRun(CFRunLoopRef rl,</span><br><span class="line">                              CFRunLoopModeRef rlm,</span><br><span class="line">                              CFTimeInterval seconds,</span><br><span class="line">                              Boolean stopAfterHandle,</span><br><span class="line">                              CFRunLoopModeRef previousMode) &#123;</span><br><span class="line">    <span class="type">uint64_t</span> startTSR = <span class="built_in">mach_absolute_time</span>();</span><br><span class="line">    <span class="type">mach_port_name_t</span> dispatchPort = MACH_PORT_NULL;</span><br><span class="line">    </span><br><span class="line">    <span class="type">dispatch_source_t</span> timeout_timer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">__timeout_context</span> *timeout_context = (<span class="keyword">struct</span> __timeout_context *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(*timeout_context));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (seconds &lt;= <span class="number">0.0</span>) &#123;</span><br><span class="line">        timeout_context-&gt;termTSR = <span class="number">0ULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123;</span><br><span class="line">        <span class="comment">// ... 对 timeout_timer 和 timeout_context 的初始化及其它操作。</span></span><br><span class="line">        <span class="comment">// 感兴趣的同学可以自行阅读源码。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置 RunLoop 的目标超时时间，比如当前是第 10 秒，</span></span><br><span class="line">        <span class="comment">// 超时时间是 100 秒，那目标超时时间就是第 110 秒。</span></span><br><span class="line">        timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注册 RunLoop 超时回调。</span></span><br><span class="line">        <span class="built_in">dispatch_source_set_event_handler_f</span>(timeout_timer, __CFRunLoopTimeout);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        timeout_context-&gt;termTSR = UINT64_MAX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Boolean didDispatchPortLastTime = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int32_t</span> retVal = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进入 RunLoop</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">voucher_mach_msg_state_t</span> voucherState = VOUCHER_MACH_MSG_STATE_UNCHANGED;</span><br><span class="line">        <span class="type">voucher_t</span> voucherCopy = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">uint8_t</span> msg_buffer[<span class="number">3</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="type">mach_msg_header_t</span> *msg = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">mach_port_t</span> livePort = MACH_PORT_NULL;</span><br><span class="line">        __CFPortSet waitSet = rlm-&gt;_portSet;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知 Observer，即将处理 Timer。</span></span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) &#123;</span><br><span class="line">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知 Observer，即将处理 Source。</span></span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) &#123;</span><br><span class="line">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用户可能会在 observer 中添加 Block，</span></span><br><span class="line">        <span class="comment">// 这里需要处理它们。</span></span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行 Source0 事件。</span></span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 同理，用户可能在 Source 中添加 Block。</span></span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果有 Source1 事件，则处理它然后跳到 handle_msg 去处理消息。</span></span><br><span class="line">        <span class="keyword">if</span> (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;</span><br><span class="line">            msg = (<span class="type">mach_msg_header_t</span> *)msg_buffer;</span><br><span class="line">            <span class="keyword">if</span> (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, <span class="built_in">sizeof</span>(msg_buffer), &amp;livePort, <span class="number">0</span>, &amp;voucherState, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">                <span class="keyword">goto</span> handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        didDispatchPortLastTime = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知 Observer，即将进入休眠。</span></span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting) &#123;</span><br><span class="line">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        msg = (<span class="type">mach_msg_header_t</span> *)msg_buffer;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         线程进入休眠，并监听 mach port 消息。</span></span><br><span class="line"><span class="comment">         直到被下面的某个事件唤醒：</span></span><br><span class="line"><span class="comment">         1. 基于 port 的 Source 事件。</span></span><br><span class="line"><span class="comment">         2. Timer 事件。</span></span><br><span class="line"><span class="comment">         3. RunLoop 的超时时间到了。</span></span><br><span class="line"><span class="comment">         4. 被其它调用者手动唤醒。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="built_in">sizeof</span>(msg_buffer), &amp;livePort, TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知 Observer，从休眠中唤醒。</span></span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting) &#123;</span><br><span class="line">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理消息：</span></span><br><span class="line">        handle_msg:;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理通过 Timer 唤醒的事件。</span></span><br><span class="line">        <span class="keyword">if</span> (livePort == rlm-&gt;_timerPort) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!__CFRunLoopDoTimers(rl, rlm, <span class="built_in">mach_absolute_time</span>())) &#123;</span><br><span class="line">                <span class="comment">// Re-arm the next timer</span></span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理通过 GCD 唤醒的事件，例如 dispatch 到 main_queue 的 block。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (livePort == dispatchPort) &#123;</span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            sourceHandledThisLoop = <span class="literal">true</span>;</span><br><span class="line">            didDispatchPortLastTime = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理通过 Source1 唤醒的事件。</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</span><br><span class="line">            <span class="keyword">if</span> (rls) &#123;</span><br><span class="line">                <span class="type">mach_msg_header_t</span> *reply = <span class="literal">NULL</span>;</span><br><span class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">NULL</span> != reply) &#123;</span><br><span class="line">                    (<span class="type">void</span>)<span class="built_in">mach_msg</span>(reply, MACH_SEND_MSG, reply-&gt;msgh_size, <span class="number">0</span>, MACH_PORT_NULL, <span class="number">0</span>, MACH_PORT_NULL);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行添加到 Loop 中的 Block。</span></span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         进入 Loop 时设置了 stopAfterHandle 为 YES，</span></span><br><span class="line"><span class="comment">         意思是处理完事件就返回。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// RunLoop 运行超时了。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timeout_context-&gt;termTSR &lt; <span class="built_in">mach_absolute_time</span>()) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// RunLoop 被外部强行停止了。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunStopped;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前运行的 Mode 被停止了。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</span><br><span class="line">            rlm-&gt;_stopped = <span class="literal">false</span>;</span><br><span class="line">            retVal = kCFRunLoopRunStopped;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Mode 里没有要处理的事件了。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunFinished;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果参数没说运行完就结束、没超时、Loop 没被停止、Mode 没被停止、Mode 不为空；则继续。</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span> == retVal);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中不难发现，RunLoop 内部其实就是一个 <code>do while</code> 循环，当线程启动 RunLoop 后，就会一直处于这个循环里，有任务时就处理任务，每次处理完 Source1 任务后都会判断一下是否满足退出条件（超时、强行停止、任务列表为空等），如果不满足就进入下一轮。</p>
<p>RunLoop 的核心实现依赖于 <code>mach_msg()</code>，这个函数在 <code>__CFRunLoopServiceMachPort</code> 内部调用。RunLoop 调用 <code>mach_msg()</code> 之后，内核就会将线程置于休眠状态，直到有 port 发送消息或定时器触发。</p>
<p>你可以使用 Xcode 运行一个 iOS 项目，然后在 APP 静止时点击暂停，此时你会看到主线程调用栈停留在一个叫做 <code>mach_msg2_trap()</code> 的函数中。</p>
<p>我画了一个 RunLoop 运行流程图，请参考下图：</p>
<p><img src="runloop0.png" alt="RunLoop 运行流程图"></p>
<h2 id="RunLoop-与-RunLoopMode"><a href="#RunLoop-与-RunLoopMode" class="headerlink" title="RunLoop 与 RunLoopMode"></a>RunLoop 与 RunLoopMode</h2><p>一个 RunLoop 可能会包含多个 Mode，每个 Mode 又可能包含若干个 Source、Timer、Observer。相关代码整理后如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">__CFRunLoop</span> *CFRunLoopRef;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RunLoop 的底层结构。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__CFRunLoop</span> &#123;</span><br><span class="line">    CFMutableSetRef _commonModes;</span><br><span class="line">    CFMutableSetRef _commonModeItems;</span><br><span class="line">    CFRunLoopModeRef _currentMode;</span><br><span class="line">    CFMutableSetRef _modes;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">__CFRunLoopMode</span> *CFRunLoopModeRef;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RunLoopMode 的底层结构。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__CFRunLoopMode</span> &#123;</span><br><span class="line">    CFStringRef _name;<span class="comment">// Mode 的名称。</span></span><br><span class="line">    CFMutableSetRef _sources0;<span class="comment">// 包含所有 Source0，一个 Set。</span></span><br><span class="line">    CFMutableSetRef _sources1;<span class="comment">// 包含所有 Source1，一个 Set。</span></span><br><span class="line">    CFMutableArrayRef _observers;<span class="comment">// 包含所有 Observer，一个 Array。</span></span><br><span class="line">    CFMutableArrayRef _timers;<span class="comment">// 包含所有 Timer，一个 Array。</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>RunLoop 与 Mode 的关系如下图所示：</p>
<p><img src="runloop1.png" alt="RunLoop 与 Mode 的关系"></p>
<p>RunLoop 每次只能指定一个 Mode 运行，这个 Mode 被称为 currentMode。如果需要切换 Mode，只能退出 Loop，然后重新指定 Mode 运行。这样做的目的是为了将不同的 Source、Timer、Observer 分隔开，避免它们相互干扰。</p>
<p>Mode 内部有以下三种类型的事件：</p>
<p><strong>CFRunLoopSourceRef</strong> 表示所有 source0 和 source1 事件。</p>
<ul>
<li>source0 只包含一个函数指针回调，它不能主动触发事件，只能先调用 <code>CFRunLoopSourceSignal(source)</code> 将这个 Source 标记为待处理，然后调用 <code>CFRunLoopWakeUp(runloop)</code> 唤醒 RunLoop 去处理被标记的事件。</li>
<li>source1 是 mach port 发出的事件，被用于通过内核和其它进程相互发送消息，这种事件可以主动唤醒 RunLoop。</li>
</ul>
<p><strong>CFRunLoopTimerRef</strong> 是一个定时器事件，它和 NSTimer 是免费桥接的，当它被加入到 RunLoop 后，RunLoop 会在对应的时间点注册事件，当时间点到达时 Loop 会被唤醒并处理这个事件。</p>
<p><strong>CFRunLoopObserverRef</strong> 是一个观察者事件，当 RunLoop 的状态发生变化时，开发者可以通过注册 Observer 来响应这些变化，可以观察的状态有以下 6 个：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1UL</span> &lt;&lt; <span class="number">0</span>), <span class="comment">// 即将进入 Loop。</span></span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1UL</span> &lt;&lt; <span class="number">1</span>), <span class="comment">// 即将处理 Timer。</span></span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1UL</span> &lt;&lt; <span class="number">2</span>), <span class="comment">// 即将处理 Source。</span></span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">5</span>), <span class="comment">// 即将进入休眠。</span></span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">6</span>), <span class="comment">// 从休眠中唤醒。</span></span><br><span class="line">    kCFRunLoopExit = (<span class="number">1UL</span> &lt;&lt; <span class="number">7</span>), <span class="comment">// 即将退出 Loop。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上的 Source、Timer、Observer 统称为 mode item，一个 item 不能重复加入同一个 Mode，但是可以同时加入多个 mode 中，另外，如果 mode 里没有 item，则 RunLoop 会直接退出，不会进入到循环中。</p>
<h2 id="关于-CommonModes"><a href="#关于-CommonModes" class="headerlink" title="关于 CommonModes"></a>关于 CommonModes</h2><p>CommonModes 是一个特殊的概念，其允许一个事件同时在多个 Mode 中触发。通过 <code>CFRunLoopAddCommonMode</code> 函数，可以将某个 Mode 标记为 “Common” 模式，这样该模式下的事件就会自动同步到其它 Mode 中去。例如，我们可以在 <code>CFRunLoopAddCommonMode</code> 中添加一个定时器，这样它就能同时在多个模式下运行。</p>
<p>相关实现代码精简后如下所示（不想看可以跳过，后面有解释）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CFRunLoopAddObserver</span><span class="params">(CFRunLoopRef rl, CFRunLoopObserverRef rlo, CFStringRef modeName)</span> </span>&#123;</span><br><span class="line">    CFRunLoopModeRef rlm;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (modeName == kCFRunLoopCommonModes) &#123;</span><br><span class="line">        CFSetRef set = rl-&gt;_commonModes ? <span class="built_in">CFSetCreateCopy</span>(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == rl-&gt;_commonModeItems) &#123;</span><br><span class="line">            rl-&gt;_commonModeItems = <span class="built_in">CFSetCreateMutable</span>(kCFAllocatorSystemDefault, <span class="number">0</span>, &amp;kCFTypeSetCallBacks);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">CFSetAddValue</span>(rl-&gt;_commonModeItems, rlo);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != set) &#123;</span><br><span class="line">            CFTypeRef context[<span class="number">2</span>] = &#123;rl, rlo&#125;;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             这里会遍历 rl-&gt;_commonModes 中的所有 Mode，</span></span><br><span class="line"><span class="comment">             然后执行 __CFRunLoopAddItemToCommonModes，</span></span><br><span class="line"><span class="comment">             把事件添加到每个具体的 Mode 中去。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">CFSetApplyFunction</span>(set, (__CFRunLoopAddItemToCommonModes), (<span class="type">void</span> *)context);</span><br><span class="line">            <span class="built_in">CFRelease</span>(set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 非 NSRunLoopCommonModes 的处理逻辑。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CFRunLoopAddCommonMode</span><span class="params">(CFRunLoopRef rl, CFStringRef modeName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">CFSetContainsValue</span>(rl-&gt;_commonModes, modeName)) &#123;</span><br><span class="line">        CFSetRef set = rl-&gt;_commonModeItems ? <span class="built_in">CFSetCreateCopy</span>(kCFAllocatorSystemDefault, rl-&gt;_commonModeItems) : <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">CFSetAddValue</span>(rl-&gt;_commonModes, modeName);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != set) &#123;</span><br><span class="line">            CFTypeRef context[<span class="number">2</span>] = &#123;rl, modeName&#125;;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             把 modeName 对应 Mode 中的所有事件，</span></span><br><span class="line"><span class="comment">             同步到 rl-&gt;_commonModeItems 的所有 Mode 中去。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">CFSetApplyFunction</span>(set, (__CFRunLoopAddItemsToCommonMode), (<span class="type">void</span> *)context);</span><br><span class="line">            <span class="built_in">CFRelease</span>(set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面提到的 CFRunLoopAddObserver 函数，还有两个函数和它类似：CFRunLoopAddTimer 和 CFRunLoopAddSource，它们的内部实现原理基本一致，所以我只介绍了 CFRunLoopAddObserver。</p>
<p>当你往 NSRunLoopCommonModes 中添加一个事件时，系统会拿到 _commonModes 并遍历其每个 Mode，然后为其添加这个事件。</p>
<p>当你调用 CFRunLoopAddCommonMode 将某个 Mode 标记为 “Common” 模式时，系统会取出这个 Mode 中的所有事件，然后遍历 _commonModes 并给每个 Mode 添加这些事件。</p>
<h2 id="RunLoop-与线程的关系"><a href="#RunLoop-与线程的关系" class="headerlink" title="RunLoop 与线程的关系"></a>RunLoop 与线程的关系</h2><p>每个线程都有自己独立的 RunLoop，iOS 不允许我们创建 RunLoop，但提供了两个函数来获取当前线程和主线程的 RunLoop：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取主线程中的 RunLoop。</span></span><br><span class="line"><span class="function">CFRunLoopRef <span class="title">CFRunLoopGetMain</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> CFRunLoopRef __main = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!__main) __main = _CFRunLoopGet0(<span class="built_in">pthread_main_thread_np</span>());</span><br><span class="line">    <span class="keyword">return</span> __main;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前线程的 RunLoop。</span></span><br><span class="line"><span class="function">CFRunLoopRef <span class="title">CFRunLoopGetCurrent</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从当前线程的局部存储中获取 RunLoop 对象。</span></span><br><span class="line">    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);</span><br><span class="line">    <span class="keyword">if</span> (rl) <span class="keyword">return</span> rl;</span><br><span class="line">    <span class="keyword">return</span> _CFRunLoopGet0(<span class="built_in">pthread_self</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局 Dict，key 是线程，value 是 RunLoop。</span></span><br><span class="line"><span class="type">static</span> CFMutableDictionaryRef __CFRunLoops = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(<span class="type">pthread_t</span> t) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     第 1 次获取 RunLoop 对象时，</span></span><br><span class="line"><span class="comment">     自动创建全局 Dict 和主线程的 RunLoop。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!__CFRunLoops) &#123;</span><br><span class="line">        CFMutableDictionaryRef dict = <span class="built_in">CFDictionaryCreateMutable</span>(kCFAllocatorSystemDefault, <span class="number">0</span>,</span><br><span class="line">                                      <span class="literal">NULL</span>, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">        CFRunLoopRef mainLoop = __CFRunLoopCreate(<span class="built_in">pthread_main_thread_np</span>());</span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(dict, <span class="built_in">pthreadPointer</span>(<span class="built_in">pthread_main_thread_np</span>()), mainLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    CFRunLoopRef loop = (CFRunLoopRef)<span class="built_in">CFDictionaryGetValue</span>(__CFRunLoops, <span class="built_in">pthreadPointer</span>(t));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">        <span class="comment">// 如果当前线程还没有 RunLoop，创建一个新的。</span></span><br><span class="line">        CFRunLoopRef newLoop = __CFRunLoopCreate(t);</span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(__CFRunLoops, <span class="built_in">pthreadPointer</span>(t), newLoop);</span><br><span class="line">        loop = newLoop;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_equal</span>(t, <span class="built_in">pthread_self</span>())) &#123;</span><br><span class="line">        _CFSetTSD(__CFTSDKeyRunLoop, (<span class="type">void</span> *)loop, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</span><br><span class="line">            <span class="comment">// 注册一个回调，当线程销毁时，顺便销毁其对应的 RunLoop。</span></span><br><span class="line">            _CFSetTSD(__CFTSDKeyRunLoopCntr, </span><br><span class="line">            (<span class="type">void</span> *)(PTHREAD_DESTRUCTOR_ITERATIONS<span class="number">-1</span>), </span><br><span class="line">            (<span class="built_in">void</span> (*)(<span class="type">void</span> *))__CFFinalizeRunLoop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中不难发现，线程和 RunLoop 的关系是一一对应的，其关系保存在一个全局字典中。另外，iOS 会为每个线程懒加载 RunLoop 对象，并在线程销毁时自动释放它。</p>
<p>我们只能获取当前线程的 RunLoop 对象（主线程的 RunLoop 除外）。</p>
<h2 id="苹果利用-RunLoop-实现的功能"><a href="#苹果利用-RunLoop-实现的功能" class="headerlink" title="苹果利用 RunLoop 实现的功能"></a>苹果利用 RunLoop 实现的功能</h2><h3 id="AutoreleasePool-与-RunLoop"><a href="#AutoreleasePool-与-RunLoop" class="headerlink" title="AutoreleasePool 与 RunLoop"></a>AutoreleasePool 与 RunLoop</h3><p>网络上有一些这方面相关的旧文章，他们会告诉你：iOS 在 APP 启动后会往主线程的 RunLoop 里注册多个 Observer，用来监听以下三种状态：</p>
<p>即将进入 RunLoop：创建 AutoreleasePool。</p>
<p>RunLoop 准备休眠：释放之前创建的 AutoreleasePool，然后创建一个新的 AutoreleasePool。</p>
<p>RunLoop 即将退出：释放之前创建的 AutoreleasePool。</p>
<p>但是，根据我的调试发现，新的 RunLoop 已经不是上述逻辑了。系统会在每个任务的执行前后自动插入相关代码来实现 AutoreleasePool 的创建和释放操作，而不是等到线程休眠前才释放。</p>
<p>关于 AutoreleasePool 的更多细节，请阅读我写的另一篇文章：<a href="/2025/03/30/iOS/AutoreleasePool%EF%BC%9AiOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%90%E7%AB%A0%E4%B8%AD%E7%9A%84%E9%9A%90%E7%A7%98%E6%97%8B%E5%BE%8B/" title="AutoreleasePool：iOS 内存管理乐章中的隐秘旋律">AutoreleasePool：iOS 内存管理乐章中的隐秘旋律</a></p>
<h3 id="NSTimer-与-RunLoop"><a href="#NSTimer-与-RunLoop" class="headerlink" title="NSTimer 与 RunLoop"></a>NSTimer 与 RunLoop</h3><p>iOS 中的 NSTimer 和 RunLoop 中的 CFRunLoopTimerRef 是免费桥接的。当你添加一个 Timer 到 RunLoop 时，系统会自动在下一个时间点注册事件，同时，为了节省资源，RunLoop 并不会在非常准确的时间点回调 Timer，Timer 有个属性叫 tolerance，表示当时间点到达后，容许有多少误差。</p>
<p>如果某个时间点错过了，比如我创建了一个 1 秒执行一次的 Timer，但 RunLoop 执行了一段逻辑消耗了 5 秒，此时，RunLoop 会在第 6 秒的时候回调 Timer，执行这一次事件以及上一次的事件。测试结果如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">16</span>:<span class="number">46</span>:<span class="number">19</span>: 定时器<span class="number">1</span></span><br><span class="line"><span class="number">16</span>:<span class="number">46</span>:<span class="number">20</span>: 定时器<span class="number">2</span></span><br><span class="line"><span class="comment">// 执行了耗时逻辑，消耗了 5 秒。</span></span><br><span class="line"><span class="number">16</span>:<span class="number">46</span>:<span class="number">26</span>: 定时器<span class="number">3</span></span><br><span class="line"><span class="number">16</span>:<span class="number">46</span>:<span class="number">26</span>: 定时器<span class="number">4</span></span><br><span class="line"><span class="number">16</span>:<span class="number">46</span>:<span class="number">27</span>: 定时器<span class="number">5</span></span><br><span class="line"><span class="number">16</span>:<span class="number">46</span>:<span class="number">28</span>: 定时器<span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>注意 “定时器3” 和 “定时器4” 这两个事件，它们的执行时间都是第 26 秒，其中 “定时器3” 本来是第 21 秒应该执行的事件，但是那个时间点 RunLoop 没空，所以它被推迟到了第 26 秒和 “定时器4” 这个事件一起执行并输出。从这个方面也能看出来，当 RunLoop 繁忙的时候，NSTimer 可能会出现调用不及时的现象。</p>
<h3 id="PerformSelector-与-RunLoop"><a href="#PerformSelector-与-RunLoop" class="headerlink" title="PerformSelector 与 RunLoop"></a>PerformSelector 与 RunLoop</h3><p>当你调用 NSObject 的 <code>performSelecter:afterDelay:</code> 后，系统会自动创建一个 NSTimer 并添加到当前线程的 RunLoop 中。如果当前线程没有 RunLoop 的话，则这个方法就会失效（子线程默认没有 RunLoop）。</p>
<p>注意，调用 <code>performSelector:onThread:</code> 时，系统也会自动创建一个 NSTimer，所以，如果对应线程没有 RunLoop 的话该方法也会失效。</p>
<h3 id="GCD-与-RunLoop"><a href="#GCD-与-RunLoop" class="headerlink" title="GCD 与 RunLoop"></a>GCD 与 RunLoop</h3><p>GCD 和 RunLoop 一般情况下都没有交集，但是当你在子线程调用了 <code>dispatch_async(dispatch_get_main_queue(), block)</code> 时，GCD 会向主线程的 RunLoop 发送消息，此时主线程的 RunLoop 会被唤醒调用 <code>__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()</code> 来处理这个事件。需要注意的是，只有从子线程回到主线程才会使用 RunLoop 处理，从子线程A到子线程B是不会使用目标线程的 RunLoop 来处理的。</p>
<h2 id="我们能利用-RunLoop-干什么"><a href="#我们能利用-RunLoop-干什么" class="headerlink" title="我们能利用 RunLoop 干什么"></a>我们能利用 RunLoop 干什么</h2><h3 id="APP-卡顿监控"><a href="#APP-卡顿监控" class="headerlink" title="APP 卡顿监控"></a>APP 卡顿监控</h3><p>其实现原理是往主线程的 RunLoop 中注册一个 Observer 监听所有状态，然后在回调中开启一个子线程用来判断主线程是否发生了卡顿，判断的逻辑大致是，如果 RunLoop 在某些状态下持续时间过长（一般是 60 ms），则判定为卡顿。如果你想了解更多细节，请查看我写的这个项目：<a target="_blank" rel="noopener" href="https://github.com/internetWei/WXLLagMonitoring">WXLLagMonitoring</a>。</p>
<h3 id="线程保活"><a href="#线程保活" class="headerlink" title="线程保活"></a>线程保活</h3><p>有时候我们可能需要频繁的在子线程中执行一些代码逻辑，如果每次执行都开启一个新线程，可能会带来一些不必要的性能损耗。如果我们能让这个子线程像主线程一样，有任务的时候处理任务，没任务的时候就休眠就好了。如果你想了解更多实现细节，请查看我写的这个项目：<a target="_blank" rel="noopener" href="https://github.com/internetWei/WXLThread">WXLThread</a>。</p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>比如，你可以将多次操作合并成一次操作。其逻辑大致是监听 RunLoop 即将进入休眠的状态，在休眠之前将所有操作合并成一次操作，系统的界面刷新就是这个原理，你在更新 UI 视图后，系统并不会立马更新，而是在 RunLoop 休眠之前将这些更新操作合并成一次更新。</p>
<p>有个框架 FDTemplateLayoutCell 就用到了 RunLoop，它会在 NSDefaultRunLoopMode 模式下注册一个 Observer 并观察即将休眠的状态，在回调中会执行预加载逻辑。</p>
<h2 id="RunLoop-相关疑惑"><a href="#RunLoop-相关疑惑" class="headerlink" title="RunLoop 相关疑惑"></a>RunLoop 相关疑惑</h2><h3 id="CommonModes-中的任务是如何同步的？"><a href="#CommonModes-中的任务是如何同步的？" class="headerlink" title="CommonModes 中的任务是如何同步的？"></a>CommonModes 中的任务是如何同步的？</h3><p>当你执行这样一行代码：<code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]</code> 时，系统是如何让 timer 同时在 NSDefaultRunLoopMode 和 UITrackingRunLoopMode 中运行的？</p>
<p>网络上有些这方面相关的旧文章，他们可能会告诉你：timer 会被添加到 RunLoop 的 _commonModeItems 中，然后在每次进入 Loop 的时候，系统会检查当前 Mode 是否属于 “Common” 模式，如果属于的话，就遍历 _commonModeItems 中的任务并添加到当前 Mode 中去。</p>
<p>这种说法在当时是否准确我不太清楚，但在如今的 RunLoop 里是错误的，其原因我已经在 <a href="#%E5%85%B3%E4%BA%8E-CommonModes">关于 CommonModes</a> 中详细解释了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>iOS 中的 RunLoop 本质上就是一个对象，这个对象内部有一个属性 Mode，Mode 里保存了要执行的所有事件。当线程启动 RunLoop 后，其内部就会开启一个 <code>do while</code> 循环。如果有任务就会从 Mode 中取出并处理，任务执行完后就会进入休眠状态，进入休眠的原理是调用了 <code>mach_msg</code> 函数。除非满足退出条件（超时、强行停止、无事件了等），否则就会进入下一轮循环。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop | Garan no dou</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7005112607707398157">iOS 的响应链小结 | 掘金</a></li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">布多</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://budo.top/2024/04/28/iOS/深入解析 iOS-RunLoop：事件驱动的核心机制/">https://budo.top/2024/04/28/iOS/深入解析 iOS-RunLoop：事件驱动的核心机制/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://budo.top">布多的博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/RunLoop/">RunLoop</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2024/12/11/iOS/2024%20%E5%86%8D%E6%8E%A2ObjC-Category%EF%BC%9A%E5%8A%A8%E6%80%81%E7%89%B9%E6%80%A7%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%9E%81%E8%87%B4%E4%B9%8B%E7%BE%8E/"><i class="fa fa-chevron-left">  </i><span>2024 再探ObjC-Category：动态特性与运行时实现的极致之美</span></a></div><div class="next-post pull-right"><a href="/2023/10/21/iOS/%E6%8F%AD%E5%BC%80%20iOS%20%E4%B8%AD%20weak%20%E6%8C%87%E9%92%88%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1%EF%BC%9A%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5/"><span>揭开 iOS 中 weak 指针的神秘面纱：从原理到实践</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="lv-container" data-id="city" data-uid="MTAyMC81MzU5Ny8zMDA3MA=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div><footer class="footer-bg" style="background-image: url(/images/backgroundImage.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2025 By 布多</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>