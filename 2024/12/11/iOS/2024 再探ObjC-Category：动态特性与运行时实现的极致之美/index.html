<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="2024 再探ObjC-Category：动态特性与运行时实现的极致之美"><meta name="keywords" content="ObjC,Runtime,Category"><meta name="author" content="布多"><meta name="copyright" content="布多"><title>2024 再探ObjC-Category：动态特性与运行时实现的极致之美 | 布多的博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?f0d94d3f99211c3546490e469f6ecbd8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '6.3.0'
} </script><link rel="alternate" href="/atom.xml" title="布多的博客" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Category-%E6%A6%82%E5%BF%B5"><span class="toc-number">2.</span> <span class="toc-text">Category 概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Category-%E4%B9%8B%E7%BC%96%E8%AF%91%E6%9C%9F%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-number">3.</span> <span class="toc-text">Category 之编译期实现细节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Category-%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82%EF%BC%9A%E6%8E%A2%E7%B4%A2%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">Category 之运行时实现细节：探索内部实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Category-%E4%B8%8E-Extension-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.</span> <span class="toc-text">Category 与 Extension 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Extension-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">5.1.</span> <span class="toc-text">Extension 的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Category-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">5.2.</span> <span class="toc-text">Category 的特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.jpg"></div><div class="author-info__name text-center">布多</div><div class="author-info__description text-center">前进！前进！！不择手段地前进！！！</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/internetwei">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">12</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">10</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">4</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友链</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.coderqi.com/">齐小胖之家</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/images/backgroundImage.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">布多的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/about">关于</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">2024 再探ObjC-Category：动态特性与运行时实现的极致之美</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2024-12-11</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/">iOS</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">4.3k</span><span class="post-meta__separator">|</span><span>阅读时长: 16 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>由 布多(budo) 发布于 2024-12-11 • 最后更新于2025-02-26</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Category 是 ObjC 中一个基础且重要的概念。本文将从 Runtime 源码入手，向你介绍 Category 的概念以及底层的实现原理。</p>
<h2 id="Category-概念"><a href="#Category-概念" class="headerlink" title="Category 概念"></a>Category 概念</h2><p>Category 主要是用来给已存在的类动态添加方法实现，也可扩展协议和属性。基于此特性，我们可以用 Category 实现如下功能：</p>
<ul>
<li><p>将一个庞大的类分解成多个 Category，每个 Category 只完成少量的任务，从而提高模块化和代码解耦程度。</p>
</li>
<li><p>在不继承的情况下给已有类动态的添加新方法。</p>
</li>
<li><p>模拟多继承，比如让已有类支持新协议。</p>
</li>
</ul>
<h2 id="Category-之编译期实现细节"><a href="#Category-之编译期实现细节" class="headerlink" title="Category 之编译期实现细节"></a>Category 之编译期实现细节</h2><p>创建一个 ObjC 源代码文件并将其命名为 <code>test_category.m</code>，然后在文件内输入如下代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">WXLCategory</span>)&lt;<span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> () <span class="built_in">NSInteger</span> wxl_ist_prot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>) <span class="built_in">NSInteger</span> wxl_cls_prot;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)wxl_ist_func;</span><br><span class="line">+ (<span class="type">void</span>)wxl_cls_func;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">WXLExtension</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)wxl_ist_func &#123;&#125;</span><br><span class="line">+ (<span class="type">void</span>)wxl_cls_func &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里我特意只写了方法的实现，而没有写属性和协议的实现，后面会解释为什么。</p>
</blockquote>
<p>使用 <code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc test_category.m</code> 命令可以将上述代码编译为 C++ 文件，代码精简后如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">category_t</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">class_t</span> *cls;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">method_list_t</span> *instance_methods;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">method_list_t</span> *class_methods;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">protocol_list_t</span> *protocols;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">prop_list_t</span> *instanceProperties;</span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">prop_list_t</span> *_classProperties;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">category_t</span> _OBJC_$_CATEGORY_NSObject_$_WXLCategory </span><br><span class="line">__attribute__ ((used, <span class="built_in">section</span> (<span class="string">&quot;__DATA, __objc_const&quot;</span>))) = </span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;NSObject&quot;</span>,</span><br><span class="line">	<span class="number">0</span>,</span><br><span class="line">	(<span class="type">const</span> <span class="keyword">struct</span> <span class="type">method_list_t</span> *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_NSObject_$_WXLCategory,</span><br><span class="line">	(<span class="type">const</span> <span class="keyword">struct</span> <span class="type">method_list_t</span> *)&amp;_OBJC_$_CATEGORY_CLASS_METHODS_NSObject_$_WXLCategory,</span><br><span class="line">	(<span class="type">const</span> <span class="keyword">struct</span> <span class="type">protocol_list_t</span> *)&amp;_OBJC_CATEGORY_PROTOCOLS_$_NSObject_$_WXLCategory,</span><br><span class="line">	(<span class="type">const</span> <span class="keyword">struct</span> <span class="type">prop_list_t</span> *)&amp;_OBJC_$_INSTANCE_PROP_LIST_NSObject_$_WXLCategory,</span><br><span class="line">	(<span class="type">const</span> <span class="keyword">struct</span> <span class="type">prop_list_t</span> *)&amp;_OBJC_$_CLASS_PROP_LIST_NSObject_$_WXLCategory,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>_classProperties</code> 变量是我参考 Runtime 源码后手动加上的，你编译的代码可能会没有。</p>
</blockquote>
<p>从编译后的代码中不难看出，一个 Category 对象，其底层其实就是1个 <code>category_t</code> 的结构体对象，这个结构体中包含了实例属性、类属性、实例方法、类方法以及协议等变量用来保存分类中的相关数据。</p>
<p>最后，编译器会把 <code>category_t</code> 相关数据保存在 Mach-O 文件的 objc_const 数据段下，等待运行时解析。</p>
<h2 id="Category-之运行时实现细节：探索内部实现原理"><a href="#Category-之运行时实现细节：探索内部实现原理" class="headerlink" title="Category 之运行时实现细节：探索内部实现原理"></a>Category 之运行时实现细节：探索内部实现原理</h2><p>相关代码整理后如下所示（代码有点长，不想看可以跳过，后面有解释）：</p>
<blockquote>
<p>本文使用的 Runtime 版本是 <a target="_blank" rel="noopener" href="https://github.com/apple-oss-distributions/objc4/tree/objc4-928.2">objc4-928.2</a>，为了方便阅读，我对代码样式和排版略作了修改以及删减了一些不影响主逻辑的冗余代码。</p>
<p>我在 <a target="_blank" rel="noopener" href="https://github.com/internetWei/ObjCRuntimes">这里</a> 维护了一个可以直接运行调试的 Runtime 项目，方便大家直接调试源码。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">load_images</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> _dyld_objc_notify_mapped_info* info)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查该模块是否有 +load 方法的实现。</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">hasLoadMethods</span>((<span class="type">const</span> headerType *)info-&gt;mh,</span><br><span class="line">                        info-&gt;sectionLocationMetadata)) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加载所有分类。</span></span><br><span class="line">    <span class="built_in">loadAllCategoriesIfNeeded</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> didInitialAttachCategories = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loadAllCategoriesIfNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 控制不要重复加载分类数据，每加载一个模块时都可能会来到这里。</span></span><br><span class="line">    <span class="keyword">if</span> (!didInitialAttachCategories) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         遍历所有模块并加载它们的分类数据。</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">         注意：在加载第1个模块时就会执行该函数，</span></span><br><span class="line"><span class="comment">         这意味着在加载第1个模块时就会把所有模块中的分类数据都加载，</span></span><br><span class="line"><span class="comment">         而不是只加载当前模块中的分类数据。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> *hi = FirstHeader; hi != <span class="literal">NULL</span>; hi = hi-&gt;<span class="built_in">getNext</span>()) &#123;</span><br><span class="line">            <span class="built_in">load_categories_nolock</span>(hi);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        didInitialAttachCategories = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">load_categories_nolock</span><span class="params">(header_info *hi)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前模块是否有分类类属性。</span></span><br><span class="line">    <span class="type">bool</span> hasClassProperties = hi-&gt;<span class="built_in">info</span>()-&gt;<span class="built_in">hasCategoryClassProperties</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="type">size_t</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历当前模块中的所有分类数据并进行处理。</span></span><br><span class="line">    <span class="keyword">auto</span> processCatlist = [&amp;](<span class="type">category_t</span> * <span class="type">const</span> *catlist) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="type">category_t</span> *cat = catlist[i];</span><br><span class="line">            Class cls = <span class="built_in">remapClass</span>(cat-&gt;cls);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 把 cat、cls、hi 包装一下，方便后面调用函数时传参。</span></span><br><span class="line">            <span class="type">locstamped_category_t</span> lc&#123;cat, cls, hi&#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 检查这个分类中是否有实例方法、协议、实例属性。</span></span><br><span class="line">            <span class="keyword">if</span> (cat-&gt;instanceMethods ||</span><br><span class="line">                cat-&gt;protocols ||</span><br><span class="line">                cat-&gt;instanceProperties) &#123;</span><br><span class="line">                <span class="comment">// 检查 cls 是否已实现，</span></span><br><span class="line">                <span class="keyword">if</span> (cls-&gt;<span class="built_in">isRealized</span>()) &#123;</span><br><span class="line">                    <span class="comment">// 将分类中的实例方法、协议、实例属性添加到 cls 上。</span></span><br><span class="line">                    <span class="built_in">attachCategories</span>(cls, &amp;lc, <span class="number">1</span>, cls, ATTACH_EXISTING);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 将分类数据和类对象保存起来，等类对象实现后再进行加载。</span></span><br><span class="line">                    objc::unattachedCategories.<span class="built_in">addForClass</span>(lc, cls);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             检查这个分类中是否有类方法、协议、类属性。</span></span><br><span class="line"><span class="comment">             </span></span><br><span class="line"><span class="comment">             注意 `(hasClassProperties &amp;&amp; cat-&gt;_classProperties)` 这段代码，</span></span><br><span class="line"><span class="comment">             可能是因为使用类属性的项目非常少，所以加入了这一个判断。</span></span><br><span class="line"><span class="comment">             </span></span><br><span class="line"><span class="comment">             这里是在给元类对象添加方法和属性，但是，元类对象是没有协议的。不清楚这</span></span><br><span class="line"><span class="comment">             里为什么要判断 `cat-&gt;protocols`。</span></span><br><span class="line"><span class="comment">             </span></span><br><span class="line"><span class="comment">             另外，在后面获取分类的协议列表时也有判断，如果是给元类添加的话就直接返回 </span></span><br><span class="line"><span class="comment">             NULL。感觉这段代码其实可以删掉，不知道是否有其它隐情？</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (cat-&gt;classMethods ||</span><br><span class="line">                cat-&gt;protocols ||</span><br><span class="line">                (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cls-&gt;<span class="built_in">ISA</span>()-&gt;<span class="built_in">isRealized</span>()) &#123;</span><br><span class="line">                    <span class="comment">// 将分类中的类方法、类属性加载到元类上。</span></span><br><span class="line">                    <span class="built_in">attachCategories</span>(cls-&gt;<span class="built_in">ISA</span>(), &amp;lc, <span class="number">1</span>, cls, </span><br><span class="line">                    ATTACH_EXISTING | ATTACH_METACLASS);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 将分类数据和元类对象保存起来，等元类对象实现后再进行加载。</span></span><br><span class="line">                    objc::unattachedCategories.<span class="built_in">addForClass</span>(</span><br><span class="line">                    lc.<span class="built_in">reSignedForMetaclass</span>(cls), </span><br><span class="line">                    cls-&gt;<span class="built_in">ISA</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">processCatlist</span>(hi-&gt;<span class="built_in">catlist</span>(&amp;count));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> cls: 需要把分类数据添加到哪个类上。</span></span><br><span class="line"><span class="comment"> 如果添加的是实例方法、实例属性、协议，这个参数就是类对象；</span></span><br><span class="line"><span class="comment"> 如果添加的是类方法、类属性，这个参数就是元类对象。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> cats_list: 需要被添加的分类数据，注意这是一个数组。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> catsListKey: 分类所属的类对象。</span></span><br><span class="line"><span class="comment"> 不管添加的是实例方法还是类方法，始终指向该分类所属的类对象，不会是元类对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">attachCategories</span><span class="params">(Class cls,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">const</span> <span class="type">locstamped_category_t</span> *cats_list,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">uint32_t</span> cats_count,</span></span></span><br><span class="line"><span class="params"><span class="function">                 Class catsListKey,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">uint32_t</span> ATTACH_BUFSIZ = <span class="number">64</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     一个临时的缓存结构。分类中的方法、属性、协议会被临时添加到这个缓存对象中去，</span></span><br><span class="line"><span class="comment">     当缓存容量满了，或者分类中的数据加载完了，再一次性添加到类中去。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Lists</span> &#123;</span><br><span class="line">        ReversedFixedSizeArray&lt;<span class="type">method_list_t</span> *, ATTACH_BUFSIZ&gt; methods;</span><br><span class="line">        ReversedFixedSizeArray&lt;<span class="type">property_list_t</span> *, ATTACH_BUFSIZ&gt; properties;</span><br><span class="line">        ReversedFixedSizeArray&lt;<span class="type">protocol_list_t</span> *, ATTACH_BUFSIZ&gt; protocols;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    Lists normalLists;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> isMeta = (flags &amp; ATTACH_METACLASS);</span><br><span class="line">    <span class="keyword">auto</span> rwe = cls-&gt;<span class="built_in">data</span>()-&gt;<span class="built_in">extAllocIfNeeded</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; cats_count; i++) &#123;</span><br><span class="line">        <span class="comment">// entry 的原型：locstamped_category_t &#123;cat, cls, hi&#125;</span></span><br><span class="line">        <span class="keyword">auto</span>&amp; entry = cats_list[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取分类中的方法列表。</span></span><br><span class="line">        <span class="type">method_list_t</span> *mlist = entry.<span class="built_in">getCategory</span>(catsListKey)-&gt;<span class="built_in">methodsForMeta</span>(isMeta);</span><br><span class="line">        Lists *lists = &amp;normalLists;</span><br><span class="line">        <span class="type">bool</span> isPreattached = </span><br><span class="line">        entry.hi-&gt;<span class="built_in">info</span>()-&gt;<span class="built_in">dyldCategoriesOptimized</span>() &amp;&amp; !DisablePreattachedCategories;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lists-&gt;methods.<span class="built_in">isFull</span>()) &#123;</span><br><span class="line">                <span class="comment">// 将缓存中的方法全部添加到类/元类中。</span></span><br><span class="line">                rwe-&gt;methods.<span class="built_in">attachLists</span>(lists-&gt;methods.array, </span><br><span class="line">                lists-&gt;methods.count, </span><br><span class="line">                isPreattached, </span><br><span class="line">                PrintPreopt ? <span class="string">&quot;methods&quot;</span> : <span class="literal">nullptr</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 清空缓存。</span></span><br><span class="line">                lists-&gt;methods.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将分类中的方法添加到缓存。</span></span><br><span class="line">            lists-&gt;methods.<span class="built_in">add</span>(mlist);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取分类中的属性列表。</span></span><br><span class="line">        <span class="type">property_list_t</span> *proplist =</span><br><span class="line">        entry.<span class="built_in">getCategory</span>(catsListKey)-&gt;<span class="built_in">propertiesForMeta</span>(isMeta, entry.hi);</span><br><span class="line">        <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lists-&gt;properties.<span class="built_in">isFull</span>()) &#123;</span><br><span class="line">                <span class="comment">// 将缓存中的属性全部添加到类/元类中。</span></span><br><span class="line">                rwe-&gt;properties.<span class="built_in">attachLists</span>(lists-&gt;properties.array, </span><br><span class="line">                lists-&gt;properties.count, </span><br><span class="line">                isPreattached, </span><br><span class="line">                PrintPreopt ? <span class="string">&quot;properties&quot;</span> : <span class="literal">nullptr</span>);</span><br><span class="line">                </span><br><span class="line">                lists-&gt;properties.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将分类中的属性添加到缓存。</span></span><br><span class="line">            lists-&gt;properties.<span class="built_in">add</span>(proplist);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取分类中的协议列表，内部会通过 isMeta 判断如果是元类就返回 NULL。</span></span><br><span class="line">        <span class="type">protocol_list_t</span> *protolist = </span><br><span class="line">        entry.<span class="built_in">getCategory</span>(catsListKey)-&gt;<span class="built_in">protocolsForMeta</span>(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lists-&gt;protocols.<span class="built_in">isFull</span>()) &#123;</span><br><span class="line">                <span class="comment">// 将缓存中的协议全部添加到类/元类中。</span></span><br><span class="line">                rwe-&gt;protocols.<span class="built_in">attachLists</span>(lists-&gt;protocols.array, </span><br><span class="line">                lists-&gt;protocols.count, </span><br><span class="line">                isPreattached, </span><br><span class="line">                PrintPreopt ? <span class="string">&quot;protocols&quot;</span> : <span class="literal">nullptr</span>);</span><br><span class="line">                </span><br><span class="line">                lists-&gt;protocols.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将分类中的协议添加到缓存。</span></span><br><span class="line">            lists-&gt;protocols.<span class="built_in">add</span>(protolist);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将缓存里的方法、属性、协议全部添加到类/元类中。</span></span><br><span class="line">    <span class="keyword">auto</span> attach = [&amp;](Lists *lists, <span class="type">bool</span> isPreattached) &#123;</span><br><span class="line">        <span class="comment">// 将缓存里的方法添加到类/元类中。</span></span><br><span class="line">        rwe-&gt;methods.<span class="built_in">attachLists</span>(lists-&gt;methods.<span class="built_in">begin</span>(), </span><br><span class="line">        lists-&gt;methods.count, </span><br><span class="line">        isPreattached, </span><br><span class="line">        PrintPreopt ? <span class="string">&quot;methods&quot;</span> : <span class="literal">nullptr</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将缓存里的属性添加到类/元类中。</span></span><br><span class="line">        rwe-&gt;properties.<span class="built_in">attachLists</span>(lists-&gt;properties.<span class="built_in">begin</span>(), </span><br><span class="line">        lists-&gt;properties.count, </span><br><span class="line">        isPreattached, </span><br><span class="line">        PrintPreopt ? <span class="string">&quot;properties&quot;</span> : <span class="literal">nullptr</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将缓存里的协议添加到类中。</span></span><br><span class="line">        rwe-&gt;protocols.<span class="built_in">attachLists</span>(lists-&gt;protocols.<span class="built_in">begin</span>(), </span><br><span class="line">        lists-&gt;protocols.count, </span><br><span class="line">        isPreattached, </span><br><span class="line">        PrintPreopt ? <span class="string">&quot;protocols&quot;</span> : <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">attach</span>(&amp;normalLists, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 这个函数的作用是把方法、属性、协议添加到类/元类中，</span></span><br><span class="line"><span class="comment"> 不一定是添加分类中的数据，也有可能是添加类自身的数据。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">attachLists</span><span class="params">(List* <span class="type">const</span> * addedLists,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">uint32_t</span> addedCount,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">bool</span> preoptimized,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">const</span> <span class="type">char</span> *logKind)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个分支通常是用来添加类自身的方法、属性、协议。</span></span><br><span class="line">    <span class="keyword">if</span> (storage.<span class="built_in">isNull</span>() &amp;&amp; addedCount == <span class="number">1</span>) &#123;</span><br><span class="line">        storage.<span class="built_in">set</span>(*addedLists);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这个分支通常是用来处理第1个分类的数据。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (storage.<span class="built_in">isNull</span>() || storage.<span class="keyword">template</span> <span class="built_in">is</span>&lt;List *&gt;()) &#123;</span><br><span class="line">        <span class="comment">// 0 or 1 list -&gt; many lists</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取旧数据。</span></span><br><span class="line">        List *oldList = storage.<span class="keyword">template</span> <span class="built_in">dyn_cast</span>&lt;List *&gt;();</span><br><span class="line">        <span class="type">uint32_t</span> oldCount = oldList ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="type">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 开辟一个新数组，足以容纳旧数据加上分类中的新数据。</span></span><br><span class="line">        <span class="type">array_t</span> *array = (<span class="type">array_t</span> *)<span class="built_in">malloc</span>(<span class="type">array_t</span>::<span class="built_in">byteSize</span>(newCount));</span><br><span class="line">        storage.<span class="built_in">set</span>(array);</span><br><span class="line">        array-&gt;count = newCount;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         将类中原来的数据（方法、属性、协议）放到数组最后面。</span></span><br><span class="line"><span class="comment">         这一步保证了类自身的数据永远处于列表的最后面。         </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (oldList) array-&gt;lists[addedCount] = oldList;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将分类中的数据插入到数组的前面。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; addedCount; i++)</span><br><span class="line">            array-&gt;lists[i] = addedLists[i];</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 这个分支通常是用来加载第2个及之后的分类数据。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="type">array_t</span> *array = storage.<span class="keyword">template</span> <span class="built_in">dyn_cast</span>&lt;<span class="type">array_t</span> *&gt;()) &#123;</span><br><span class="line">        <span class="comment">// many lists -&gt; many lists</span></span><br><span class="line">        <span class="type">uint32_t</span> oldCount = array-&gt;count;</span><br><span class="line">        <span class="type">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">        <span class="type">array_t</span> *newArray = (<span class="type">array_t</span> *)<span class="built_in">malloc</span>(<span class="type">array_t</span>::<span class="built_in">byteSize</span>(newCount));</span><br><span class="line">        newArray-&gt;count = newCount;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 把旧数据按照之前的顺序放到新数组的最后面。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = oldCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            newArray-&gt;lists[i + addedCount] = array-&gt;lists[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         将分类数据依次添加到数组的前面，</span></span><br><span class="line"><span class="comment">         这一步操作会导致最后编译的分类数据将会被添加在数组的最前面。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; addedCount; i++)</span><br><span class="line">            newArray-&gt;lists[i] = addedLists[i];</span><br><span class="line">            </span><br><span class="line">        <span class="built_in">free</span>(array);</span><br><span class="line">        storage.<span class="built_in">set</span>(newArray);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         一般情况下不会来到这个分支，</span></span><br><span class="line"><span class="comment">         在之前的函数 load_categories_nolock 中有这样一行代码：</span></span><br><span class="line"><span class="comment">         `objc::unattachedCategories.addForClass(lc, cls);`</span></span><br><span class="line"><span class="comment">         这个分支就是用来处理这种情况。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">auto</span> *listList = storage.<span class="keyword">template</span> dyn_cast&lt;<span class="type">relative_list_list_t</span>&lt;List&gt; *&gt;()) &#123;</span><br><span class="line">        <span class="comment">// list-of-lists -&gt; many lists</span></span><br><span class="line">        <span class="keyword">auto</span> listListBegin = listList-&gt;<span class="built_in">beginLists</span>();</span><br><span class="line">        <span class="type">uint32_t</span> oldCount = listList-&gt;<span class="built_in">countLists</span>();</span><br><span class="line">        <span class="type">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">        <span class="type">array_t</span> *newArray = (<span class="type">array_t</span> *)<span class="built_in">malloc</span>(<span class="type">array_t</span>::<span class="built_in">byteSize</span>(newCount));</span><br><span class="line">        newArray-&gt;count = newCount;</span><br><span class="line">        </span><br><span class="line">        <span class="type">uint32_t</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; addedCount; i++) &#123;</span><br><span class="line">            newArray-&gt;lists[i] = addedLists[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (; i &lt; newCount; i++) &#123;</span><br><span class="line">            newArray-&gt;lists[i] = *listListBegin;</span><br><span class="line">            ++listListBegin;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        storage.<span class="built_in">set</span>(newArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中不难发现，Category 中的数据（方法、属性、协议）都是在运行时通过 Runtime 动态添加到类中一个叫做 rwe 的对象中。</p>
<p>在 rwe 这个对象中拥有三个变量，分别是：方法列表、属性列表、协议列表，这个变量其实就是一个二维数组。以方法列表为例，类自身的所有方法是一个数组，每个 Category 中的所有方法是一个数组，它们都被放在这个二维数组中，注意，类自身的方法列表放在这个二维数组的最后面，最后编译的那个 Category 中的方法列表放在这个二维数组的最前面。</p>
<p>正是因为这个特点才导致了 Category 中的方法实现会覆盖与类本身同名的方法实现。所以，在开发过程中我们经常会看到很多框架都会给 Category 的方法和属性添加前缀，其目的就是为了降低重名的可能性。</p>
<p>有些人说 Category 不支持添加实例变量是因为 <code>category_t</code> 结构体中没有 <code>ivars</code> 字段。其实并不是添加一个字段的事，根本原因是因为开发者可能会用 Category 给已经编译好的类（例如系统类）添加数据，而这些类的内存布局与地址已经固定死了，如果要给它添加实例变量势必要修改其内存布局与地址。</p>
<p>另外，也不能给 Category 添加 weak 属性，如果一定要添加 weak 属性的话，可以采用中间者模式，即给 Category 添加一个中间者对象，然后给这个中间类声明一个 weak 属性。关于 weak 指针的更多细节请看我的另一篇文章 <a href="/2023/10/21/iOS/%E6%8F%AD%E5%BC%80%20iOS%20%E4%B8%AD%20weak%20%E6%8C%87%E9%92%88%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1%EF%BC%9A%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5/" title="揭开 iOS 中 weak 指针的神秘面纱：从原理到实践">揭开 iOS 中 weak 指针的神秘面纱：从原理到实践</a></p>
<p>我在网上看到有些人说为什么要把 Category 设计成使用 Runtime 运行时加载，直接设计成编译时加载不是更好吗？他们的想法是：“在给项目中某个类（这个类是在项目中创建的），例如 CustomClass 创建分类时，编译器其实能拿到 CustomClass 的实现文件，那么只要把分类中的方法和这个类自身的方法合并不就行了，这样还能实现在 Category 中给这个类添加实例变量。” 乍一看没啥问题。但是，Category 还支持给已经编译好的类（例如系统类）添加方法实现，而这些类的布局和地址已经固定死了，因而不能这么干。</p>
<p>在阅读源码的过程中，我还发现了一些其它问题：</p>
<ol>
<li><p>在前面的 <code>test_category.m</code> 文件中，我特意没有在实现中写上属性和协议的实现。因为经过我的调试发现，Runtime 在解析 Category 中的属性和协议时，只看声明并不看实现，只要有属性、协议声明，不管有没有实现都会被添加到类的属性列表和协议列表中。但是在解析方法的时候是反过来的，只会把有方法实现的那些方法添加到方法列表中。</p>
</li>
<li><p>在第1个函数 load_images 中有这么一个判断：如果该模块中没有 <code>+load</code> 方法实现就不添加 Category 数据。我查阅了许多资料，但是都没有找到可信的证据解释为什么要这样做？如果你知道为什么的话还请留言告知。</p>
</li>
<li><p>Runtime 会在 <code>loadAllCategoriesIfNeeded</code> 函数内一次性加载所有模块中的分类数据，而不是遍历一个模块加载一个模块中的分类数据。我想了一下，这么做有以下好处：降低程序的复杂度和提高性能。如果是遍历一个模块加载一个模块的数据，那就不能只使用一个全局变量 <code>didInitialAttachCategories</code> 来标记分类数据是否已加载？可能要维护一个字典，例如 key 是模块名称，value 表示该模块是否已加载分类。这么做显然比维护一个全局变量成本更高。</p>
</li>
</ol>
<h2 id="Category-与-Extension-的区别"><a href="#Category-与-Extension-的区别" class="headerlink" title="Category 与 Extension 的区别"></a>Category 与 Extension 的区别</h2><p>经常有人把 Category 和 Extension 拿到一起来说，可能是因为它们的声明方式有点像吧，以下是 Category 和 Extension 的声明代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Category 声明</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> (<span class="title">CategoryName</span>) @<span class="title">end</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Extension 声明</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> () @<span class="title">end</span></span></span><br></pre></td></tr></table></figure>

<p>从代码来看，Category 似乎只多了一个 name 而已。所以导致很多人以为它们的底层实现可能差不多，但其实它们的实现压根不一样。</p>
<h3 id="Extension-的特点"><a href="#Extension-的特点" class="headerlink" title="Extension 的特点"></a>Extension 的特点</h3><p>从功能和底层实现上来看，其实 Extension 和 Interface(类声明) 更像一些，Interface 能干的事，它基本上都能干，除了不能指定父类。</p>
<p>Interface 一般是用来对外提供接口数据，但有时候我们会想把一些属性、方法、实例变量隐藏起来。Extension 就是专门用来干这个的，因为 Interface 只能有一个，但 Extension 可以有多个。Extension 和类声明都是编译特性，你可以在 Extension 中声明实例变量、属性、方法、协议，这和在 Interface 中写本质上是一样的。</p>
<blockquote>
<p>需要注意一点，虽然在 Extension 中可以声明实例变量，但仅在拥有 implementation 实现的这个文件中这么做才可以，例如以下代码就可以，因为这个文件中拥有 Book 的实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Book</span> () </span>&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *_name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Book</span></span></span><br><span class="line">- (<span class="type">void</span>)testFun &#123;</span><br><span class="line">    _name = <span class="string">@&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, _name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>例如下面的代码就不行，因为这个文件中没有 Book 类的实现，此时你会得到一个编译错误：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Book</span> () </span>&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *_name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Book</span> (<span class="title">CategoryName</span>)</span></span><br><span class="line">- (<span class="type">void</span>)testFun &#123;</span><br><span class="line">    _name = <span class="string">@&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, _name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>另外，虽然在任何地方都能使用 Extension，但是和上面的实例变量一样，如果需要编译器自动生成实现代码（例如属性），那就不能在 implementation 之外的文件使用，切记！！！</p>
<p>Extension 还有一个好用的功能就是声明私有方法，这样就能在后面的代码中直接调用这个方法了，而不是写成这样：<code>[self performSelector:@selector(testFun)]</code>，网上有很多人是使用 Category 干这个事，其实 Extension 也可以，个人感觉这样更优雅。</p>
<h3 id="Category-的特点"><a href="#Category-的特点" class="headerlink" title="Category 的特点"></a>Category 的特点</h3><p>与 Extension 相比，Category 是编译器加上 Runtime 共同完成的。编译器负责将 Category 编译成 <code>category_t</code> 对象，然后添加到 Mach-O 文件中。Runtime 负责在运行时将 <code>category_t</code> 中的数据解析并添加到对应的类中。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从苹果提供的源码中我们不难发现，其实 Category 的底层实现并不复杂，其本质就是将 Category 转化成一个结构体用来保存相关数据（属性、方法、协议），然后通过 Runtime 在运行时将这个结构体中的数据解析出来并且添加到类中。而这个类对象内部有一个二维数组来存储每个分类中的数据。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">布多</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://budo.top/2024/12/11/iOS/2024 再探ObjC-Category：动态特性与运行时实现的极致之美/">https://budo.top/2024/12/11/iOS/2024 再探ObjC-Category：动态特性与运行时实现的极致之美/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://budo.top">布多的博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ObjC/">ObjC</a><a class="post-meta__tags" href="/tags/Runtime/">Runtime</a><a class="post-meta__tags" href="/tags/Category/">Category</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2025/03/30/iOS/AutoreleasePool%EF%BC%9AiOS%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%90%E7%AB%A0%E4%B8%AD%E7%9A%84%E9%9A%90%E7%A7%98%E6%97%8B%E5%BE%8B/"><i class="fa fa-chevron-left">  </i><span>AutoreleasePool：iOS 内存管理乐章中的隐秘旋律</span></a></div><div class="next-post pull-right"><a href="/2024/04/28/iOS/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%20iOS-RunLoop%EF%BC%9A%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/"><span>深入解析 iOS-RunLoop：事件驱动的核心机制</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="lv-container" data-id="city" data-uid="MTAyMC81MzU5Ny8zMDA3MA=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div><footer class="footer-bg" style="background-image: url(/images/backgroundImage.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2025 By 布多</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>